import System
import System.Collections.Generic
import System.Text
import Newtonsoft.Json
import CodeGen.RepositoryAPI
import CodeGen.Engine
import System.IO
import System.Text.RegularExpressions
import System.Linq
import HarmonyCoreGenerator.Generator
import HarmonyCoreExtensions
import System.Threading
import System.Diagnostics
import CodeGen.MethodCatalogAPI
import Microsoft.Build.Logging
import Microsoft.Build.Framework
import Newtonsoft.Json.Linq
import Newtonsoft.Json

namespace HarmonyCoreGenerator.Model

	{JsonObject(ItemNullValueHandling=NullValueHandling.Ignore)}
	public class Solution
		public readwrite property CreatedWithToolVersion, @string, "1.0"
		public readwrite property WrittenWithToolVersion, @string, "1.0"

		public readwrite property RPSMFIL, @string
		public readwrite property RPSTFIL, @string
		public readwrite property RepositoryProject, @string
		public readwrite property EnableNewtonsoftJson, boolean?
		public readwrite property TraditionalBridge, @TraditionalBridge

		public readwrite property ServicesNamespace, @string
		public readwrite property ControllersNamespace, @string
		public readwrite property ModelsNamespace, @string
		public readwrite property ClientModelsNamespace, @string
		public readwrite property UnitTestsNamespace, @string
		public readwrite property SelfHostNamespace, @string
		public readwrite property TraditionalBridgeNamespace, @string
		public readwrite property UnitTestsBaseNamespace, @string

		public readwrite property DataFolder, @string
		{JsonIgnore}
		public readwrite property SolutionFolder, @string

		public readwrite property APIDocsPath, @string
		public readwrite property APITitle, @string
		public readwrite property APIVersion, @string
		public readwrite property APIDescription, @string
		public readwrite property APITerms, @string
		public readwrite property APIContactName, @string
		public readwrite property APIContactEmail, @string
		public readwrite property APILicenseName, @string
		public readwrite property APILicenseUrl, @string
		public readwrite property APIEnableQueryParams, @string

		public readwrite property ServerProtocol, @string
		public readwrite property ServerName, @string
		public readwrite property ServerHttpPort, @string
		public readwrite property ServerHttpsPort, @string
		public readwrite property ServerBasePath, @string

		public readwrite property OAuthServer, @string
		public readwrite property OAuthApi, @string
		public readwrite property OAuthClient, @string
		public readwrite property OAuthSecret, @string
		public readwrite property OAuthTestUser, @string
		public readwrite property OAuthTestPassword, @string

		public readwrite property CustomAuthController, @string
		public readwrite property CustomAuthEndpointPath, @string
		public readwrite property CustomAuthUserName, @string
		public readwrite property CustomAuthPassword, @string

		public readwrite property SignalRPath, @string

		public readwrite property TemplatesFolder, @string
		public readwrite property ServicesFolder, @string
		public readwrite property ControllersFolder, @string
		public readwrite property ModelsFolder, @string
		public readwrite property SelfHostFolder, @string
		public readwrite property UnitTestFolder, @string
		public readwrite property IsolatedFolder, @string
		public readwrite property TraditionalBridgeFolder, @string
		public readwrite property ServicesProject, @string
		public readwrite property ControllersProject, @string
		public readwrite property ModelsProject, @string
		public readwrite property SelfHostProject, @string
		public readwrite property UnitTestProject, @string
		public readwrite property IsolatedProject, @string
		public readwrite property TraditionalBridgeProject, @string
		public readwrite property FullCollectionEndpoints, boolean?
		public readwrite property PrimaryKeyEndpoints, boolean?
		public readwrite property AlternateKeyEndpoints, boolean?
		public readwrite property CollectionCountEndpoints, boolean?
		public readwrite property IndividualPropertyEndpoints, boolean?
		public readwrite property PutEndpoints, boolean?
		public readwrite property PostEndpoints, boolean?
		public readwrite property PatchEndpoints, boolean?
		public readwrite property DeleteEndpoints, boolean?
		public readwrite property ODataSelect, boolean?
		public readwrite property ODataFilter, boolean?
		public readwrite property ODataOrderBy, boolean?
		public readwrite property ODataTop, boolean?
		public readwrite property ODataSkip, boolean?
		public readwrite property ODataRelations, boolean?
		public readwrite property ODataRelationValidation, boolean?
		public readwrite property GenerateSelfHost, boolean?
		public readwrite property CreateTestFiles, boolean?
		public readwrite property GeneratePostmanTests, boolean?
		public readwrite property GenerateUnitTests, boolean?
		public readwrite property DocumentPropertyEndpoints, boolean?
		public readwrite property GenerateOData, boolean?
		public readwrite property DisableFileLogicals, boolean?
		public readwrite property NoCustomPluralization, boolean?

		public readwrite property Authentication, boolean?
		public readwrite property CustomAuthentication, boolean?
		public readwrite property FieldSecurity, boolean?
		public readwrite property AdapterRouting, boolean?
		public readwrite property StoredProcedureRouting, boolean?
		public readwrite property CaseSensitiveUrls, boolean?
		public readwrite property CrossDomainBrowsing, boolean?
		public readwrite property IISSupport, boolean?
		public readwrite property FieldOverlays, boolean?
		public readwrite property AlternateFieldNames, boolean?
		public readwrite property ReadOnlyProperties, boolean?
		public readwrite property SmcPostmanTests, boolean?
		public readwrite property SmcSignalRHubs, boolean?
		public readwrite property VersioningOrSwagger, VersioningOrSwaggerMode?
		public readwrite property CustomSettings, @Dictionary<string, string>, new Dictionary<string, string>()
		public readwrite property UserTokens, @Dictionary<string, string>

		private _rps, @Repository
		{JsonIgnore}
		public property RPS, @Repository
			method get
			proc
				data altFieldName, boolean, AlternateFieldNames ?? false
				if(_rps == ^null)
				begin
					data localmFil = RPSMFIL
					data localtFil = RPSTFIL

					if(!File.Exists(localmFil))
						localmFil = Path.Combine(SolutionFolder, localmFil)
					if(!File.Exists(localtFil))
						localtFil = Path.Combine(SolutionFolder, localtFil)

					_rps = new Repository(localmFil, localtFil, altFieldName)
				end

				mreturn _rps
			endmethod
		endproperty

		public readwrite property ExtendedStructures, @List<StructureEx>
		public readwrite property ExtendedInterfaces, @List<InterfaceEx>

        public class SolutionGenerationEvents
            public GenerationStarted, @Action<CodeGenTaskSet>
            public GenerationFinished, @Action<CodeGenTaskSet>
            public Message, @Action<CodeGenTask, string>
            public TaskComplete, @Action<CodeGenTask>
            public TaskStarted, @Action<CodeGenTask>
            public Error, @Action<CodeGenTask, string>
        endclass


		public method GetExtendedStructureProperties, @Dictionary<string, Dictionary<string, Object>>
		proc
			data result = new Dictionary<string, Dictionary<string, Object>>()
			data stex, @StructureEx
			foreach stex in ExtendedStructures
			begin
				data stexDictionary = new Dictionary<string, object>()
				if(!(stex.EnableGetAll ?? FullCollectionEndpoints ?? true))
					stexDictionary.Add("NO_GET_ALL_ENDPOINT", true)
				if(!(stex.EnableGetOne ?? PrimaryKeyEndpoints ?? true))
					stexDictionary.Add("NO_GET_ENDPOINT", true)
				if(!(stex.EnablePost ?? PostEndpoints ?? true))
					stexDictionary.Add("NO_POST_ENDPOINT", true)
				if(!(stex.EnablePut ?? PutEndpoints ?? true))
					stexDictionary.Add("NO_PUT_ENDPOINT", true)
				if(!(stex.EnablePatch ?? PatchEndpoints ?? true))
					stexDictionary.Add("NO_PATCH_ENDPOINT", true)
				if(!(stex.EnableDelete ?? DeleteEndpoints ?? true))
					stexDictionary.Add("NO_DELETE_ENDPOINT", true)
				if(!(stex.EnableAltGet ?? AlternateKeyEndpoints ?? true))
					stexDictionary.Add("NO_ALTERNATE_KEY_ENDPOINTS", true)
				if(!(IndividualPropertyEndpoints ?? true))
					stexDictionary.Add("NO_PROPERTY_ENDPOINTS", true)
				if(!(stex.EnableRelations ?? ODataRelations ?? true))
					stexDictionary.Add("HARMONYCORE_RELATIONS_ENABLED", true)
				if(!(stex.EnableRelationValidation ?? ODataRelationValidation ?? true))
					stexDictionary.Add("HARMONYCORE_RELATIONS_VALIDATION_ENABLED", true)

				data fieldLookup, @KeyValuePair<string, Dictionary<string, Object>>
				foreach fieldLookup in stex.Fields
				begin
					stexDictionary.Add(stex.Name + "." + fieldLookup.Key, fieldLookup.Value)
				end

				if(stexDictionary.Count > 0)
					result.Add(stex.Name, stexDictionary)
			end

			mreturn result
		endmethod

		public method GetUserDefinedTokens, @List<UserToken>
		proc
			data result = new List<UserToken>()
			result.Add(new UserToken("SERVICES_NAMESPACE", ServicesNamespace ?? "Services"))
			result.Add(new UserToken("MODELS_NAMESPACE", ModelsNamespace ?? "Services.Models"))
			result.Add(new UserToken("CONTROLLERS_NAMESPACE", ControllersNamespace ?? "Services.Controllers"))
			result.Add(new UserToken("CLIENT_MODELS_NAMESPACE", ClientModelsNamespace ?? "Services.Test.Models"))
			result.Add(new UserToken("UNIT_TESTS_NAMESPACE", UnitTestsNamespace ?? "Services.Test.UnitTests"))
			result.Add(new UserToken("UNIT_TESTS_BASE_NAMESPACE", UnitTestsBaseNamespace ?? "Services.Test"))
			result.Add(new UserToken("SELF_HOST_NAMESPACE", SelfHostNamespace ?? "Services.Host"))
			result.Add(new UserToken("DATA_FOLDER", DataFolder ?? "SampleData"))
			result.Add(new UserToken("API_DOCS_PATH", APIDocsPath ?? "api-docs"))
			result.Add(new UserToken("API_TITLE", APITitle ?? "Harmony Core Sample API"))
			result.Add(new UserToken("API_VERSION", APIVersion ?? "1"))
			result.Add(new UserToken("API_DESCRIPTION", APIDescription ?? "This environment presents an example of using Harmony Core to expose a collection of RESTful Web Service endpoints that allow you to interact with a small sample dataset."))
			result.Add(new UserToken("API_TERMS", APITerms ?? "Open Source"))
			result.Add(new UserToken("API_CONTACT_NAME", APIContactName ?? "Jodah Veloper"))
			result.Add(new UserToken("API_CONTACT_EMAIL", APIContactEmail ?? "jodah.veloper@synergexpsg.com"))
			result.Add(new UserToken("API_LICENSE_NAME", APILicenseName ?? "BSD-2-Clause"))
			result.Add(new UserToken("API_LICENSE_URL", APILicenseUrl ?? "https://opensource.org/licenses/BSD-2-Clause"))
			result.Add(new UserToken("API_ENABLE_QUERY_PARAMS", APIEnableQueryParams ?? "(MaxExpansionDepth=4)"))
			result.Add(new UserToken("SERVER_PROTOCOL", ServerProtocol ?? "https"))
			result.Add(new UserToken("SERVER_NAME", ServerName ?? "localhost"))
			result.Add(new UserToken("SERVER_HTTP_PORT", ServerHttpPort ?? "8085"))
			result.Add(new UserToken("SERVER_HTTPS_PORT", ServerHttpsPort ?? "8086"))
			result.Add(new UserToken("SERVER_BASE_PATH", ServerBasePath ?? "odata"))

			result.Add(new UserToken("OAUTH_SERVER", OAuthServer ?? "http://localhost:5000"))
			result.Add(new UserToken("OAUTH_API", OAuthApi ?? "api1"))
			result.Add(new UserToken("OAUTH_CLIENT", OAuthClient ?? "ro.client"))
			result.Add(new UserToken("OAUTH_SECRET", OAuthSecret ?? "CBF7EBE6-D46E-41A7-903B-766A280616C3"))
			result.Add(new UserToken("OAUTH_TEST_USER", OAuthTestUser ?? "jodah"))
			result.Add(new UserToken("OAUTH_TEST_PASSWORD", OAuthTestPassword ?? "P@ssw0rd"))
			result.Add(new UserToken("CUSTOM_AUTH_CONTROLLER_PATH", CustomAuthController ?? "Authentication"))
			result.Add(new UserToken("CUSTOM_AUTH_ENDPOINT_PATH", CustomAuthEndpointPath ?? "GetToken"))
			result.Add(new UserToken("CUSTOM_AUTH_USERNAME", CustomAuthUserName ?? "username"))
			result.Add(new UserToken("CUSTOM_AUTH_PASSWORD", CustomAuthPassword ?? "password"))
			
			if(UserTokens != ^null)
			begin
				data kvp, KeyValuePair<string, string>
				foreach kvp in UserTokens
				begin
					result.Add(new UserToken(kvp.Key, kvp.Value))
				end
			end


			mreturn result
		endmethod

		private static method FixRPS, void
			targetSolution, @Solution
		proc
			if(File.Exists(targetSolution.RPSMFIL) && File.Exists(targetSolution.RPSTFIL))
			begin
				mreturn
			end

			data repositoryFile = "Repository.synproj"
			data projectDir = Path.Combine(targetSolution.SolutionFolder, "Repository")

			if(!String.IsNullOrWhiteSpace(targetSolution.RepositoryProject))
			begin
				projectDir = Path.Combine(targetSolution.SolutionFolder, Path.GetDirectoryName(targetSolution.RepositoryProject))
				repositoryFile = Path.GetFileName(targetSolution.RepositoryProject)
            end

			
			data rpsOutputFolder = Path.Combine(projectDir, "bin", "Debug")
			data rpsMFile = Path.Combine(rpsOutputFolder, "rpsmain.ism") 
			data rpsTFile = Path.Combine(rpsOutputFolder, "rpstext.ism")

			if(!System.IO.File.Exists(Path.Combine(projectDir, repositoryFile)))
            begin
                rpsMFile = Environment.GetEnvironmentVariable("RPSMFIL")
                rpsTFile = Environment.GetEnvironmentVariable("RPSTFIL")
                Console.WriteLine("FixRPS(): Couldnt find a valid repository project attempting to fallback to existing RPSMFIL({0}) | RPSTFIL({1}) from environment", rpsMFile ?? "not found", rpsTFile ?? "not found")
            end

			if(File.Exists(rpsMFile) && File.Exists(rpsTFile))
			begin
				targetSolution.RPSMFIL = FileTools.GetRelativePath(targetSolution.SolutionFolder,rpsMFile)
				targetSolution.RPSTFIL = FileTools.GetRelativePath(targetSolution.SolutionFolder,rpsTFile)
				mreturn
			end

			
            
			data basePath = GetDotnetBasePath()

			data projectOptions =  new Microsoft.Build.Definition.ProjectOptions()
			data evalContext = Microsoft.Build.Evaluation.Context.EvaluationContext.Create(Microsoft.Build.Evaluation.Context.EvaluationContext.SharingPolicy.Isolated)
			projectOptions.EvaluationContext = evalContext
			projectOptions.GlobalProperties = new Dictionary<String, String>()
			projectOptions.GlobalProperties.Add("SolutionDir", targetSolution.SolutionFolder + "\")
			projectOptions.GlobalProperties.Add("Configuration", "Debug")
			projectOptions.GlobalProperties.Add("Platform", "AnyCPU")
            projectOptions.GlobalProperties.Add("NuGetRestoreTargets", Path.Combine(basePath, "Nuget.targets"))
			data msbuildRepositoryProject = Microsoft.Build.Evaluation.ProjectCollection.GlobalProjectCollection.LoadProject(Path.Combine(projectDir, repositoryFile), projectOptions.GlobalProperties, projectOptions.ToolsVersion)
			data logger = new ConsoleLogger(LoggerVerbosity.Minimal)
			msbuildRepositoryProject.Build("Build", new ILogger[#] { logger })
			logger.Shutdown()
			
			if(File.Exists(rpsMFile) && File.Exists(rpsTFile))
			begin
				targetSolution.RPSMFIL = FileTools.GetRelativePath(targetSolution.SolutionFolder,rpsMFile)
				targetSolution.RPSTFIL = FileTools.GetRelativePath(targetSolution.SolutionFolder,rpsTFile)
				mreturn
			end
			;;need to also combined with output path possibly
			rpsMFile = msbuildRepositoryProject.GetPropertyValue("MOutputName")
			rpsTFile = msbuildRepositoryProject.GetPropertyValue("TOutputName")

			if(string.IsNullOrWhiteSpace(Path.GetDirectoryName(rpsMFile)))
				rpsMFile = Path.Combine(projectDir, rpsMFile)

			if(string.IsNullOrWhiteSpace(Path.GetDirectoryName(rpsTFile)))
				rpsTFile = Path.Combine(projectDir, rpsTFile)
					 
			rpsOutputFolder = Path.GetDirectoryName(rpsMFile)
			
			if(!File.Exists(rpsMFile) && !rpsMFile.EndsWith(".ism", StringComparison.CurrentCultureIgnoreCase))
				rpsMFile += ".ism"

			if(!File.Exists(rpsTFile) && !rpsTFile.EndsWith(".ism", StringComparison.CurrentCultureIgnoreCase))
				rpsTFile += ".ism"

			;;msbuildRepositoryProject.ProjectCollection.UnloadProject(msbuildRepositoryProject)
			targetSolution._rps = ^null
			if (File.Exists(rpsMFile)) then
			begin
				targetSolution.RPSMFIL = FileTools.GetRelativePath(targetSolution.SolutionFolder,rpsMFile)
			end
			else
			begin
				throw new InvalidOperationException(String.Format("Repository main file '{0}' was not found in the expected location!",rpsMFile))
			end

			if (File.Exists(rpsTFile)) then
			begin
				targetSolution.RPSTFIL = FileTools.GetRelativePath(targetSolution.SolutionFolder,rpsTFile)
			end
			else
			begin
				throw new InvalidOperationException(String.Format("Repository text file '{0}' was not found in the expected location!",rpsTFile))
			end 
		endmethod

        public static method GetDotnetBasePath, @string
        proc
            data basePath = Environment.GetEnvironmentVariable("DOTNET_BASE_PATH")
            try
            begin
                data dotnetInfo = new Process()
                dotnetInfo.StartInfo = new ProcessStartInfo("dotnet", "--info")
                dotnetInfo.StartInfo.RedirectStandardOutput = true
                dotnetInfo.Start()
                data dotnetInfoOutput = dotnetInfo.StandardOutput.ReadToEnd()

                data basePathPosition = dotnetInfoOutput.IndexOf("Base Path:") + 10
                if(basePathPosition < 10)
                    throw new Exception(string.Format("failed to find dotnet.exe path, base was {0}", dotnetInfoOutput))

                data endOfPathLine = dotnetInfoOutput.IndexOf(Environment.NewLine, basePathPosition)

                if(endOfPathLine < 0)
                    throw new Exception(string.Format("failed to find dotnet.exe path, base was {0}", dotnetInfoOutput))

                basePath = dotnetInfoOutput.Substring(basePathPosition, endOfPathLine - basePathPosition).Trim()
            end			
            catch(ex, @Exception)
            begin
                if(string.IsNullOrWhiteSpace(basePath))
                    throw
            end
            endtry
			mreturn basePath
		endmethod

		private static method FixProps, void
			targetSolution, @Solution
		proc
			targetSolution.TemplatesFolder = targetSolution.TemplatesFolder ?? "Templates"
			targetSolution.ServicesFolder = targetSolution.ServicesFolder ?? "Services"
			targetSolution.ControllersFolder = targetSolution.ControllersFolder ?? "Services.Controllers"
			targetSolution.ModelsFolder = targetSolution.ModelsFolder ?? "Services.Models"
			targetSolution.SelfHostFolder = targetSolution.SelfHostFolder ?? "Services.Host"
			targetSolution.UnitTestFolder = targetSolution.UnitTestFolder ?? "Services.Test"
			targetSolution.IsolatedFolder = targetSolution.IsolatedFolder ?? "Isolated"
			targetSolution.TraditionalBridgeFolder = targetSolution.TraditionalBridgeFolder ?? "TraditionalBridge"
			targetSolution.ServicesProject = targetSolution.ServicesProject ?? "Services"
			targetSolution.ControllersProject = targetSolution.ControllersProject ?? "Services.Controllers"
			targetSolution.ModelsProject = targetSolution.ModelsProject ?? "Services.Models"
			targetSolution.SelfHostProject = targetSolution.SelfHostProject ?? "Services.Host"
			targetSolution.UnitTestProject = targetSolution.UnitTestProject ?? "Services.Test"
			targetSolution.IsolatedProject = targetSolution.IsolatedProject ?? "Isolated"
			targetSolution.TraditionalBridgeProject = targetSolution.TraditionalBridgeProject ?? "TraditionalBridge"
		endmethod

		public static method LoadSolution, @Solution
			targetJsonFile, @string
			solutionDir, @string
		proc
			data jsonText = File.ReadAllText(targetJsonFile)
			data jsonObject = JsonConvert.DeserializeObject<Solution>(jsonText)
			jsonObject.SolutionFolder = solutionDir 
			FixRPS(jsonObject)
			FixProps(jsonObject)
			mreturn jsonObject
		endmethod

		private static method ReadAllBatchLines ,[#]string
			required in aFilename   ,string
			endparams

			record
				inArray         ,[#]string
				outArray        ,[#]string
				ctr             ,int
				outArrayLen     ,int
				isContinuation  ,Boolean
			endrecord

		proc

			inArray = File.ReadAllLines(aFilename)

			outArrayLen = 0
			for ctr from 1 thru inArray.Length
			begin
				if (isContinuation == true) then
					inArray[outArrayLen] = concatBatchLines(inArray[outArrayLen], inArray[ctr])
				else
					inArray[outArrayLen+=1] = inArray[ctr]

				if (inArray[outArrayLen].EndsWith("^")) then
					isContinuation = true
				else
					isContinuation = false
			end

			outArray = new string[outArrayLen]

			for ctr from 1 thru outArrayLen
				outArray[ctr] = inArray[ctr]

			mreturn outArray

		endmethod

		private static method concatBatchLines, string
			required in aLine1  ,string
			required in aLine2  ,string
			endparams

		proc

			if (aLine1.EndsWith("^"))
				mreturn String.Concat(aLine1.Substring(0, aLine1.Length-1), aLine2)

			mreturn String.Concat(aLine1, aLine2)

		endmethod

		public static method LoadSolution, @Solution
			targetRegenBat, @string
			userTokens, @string
			solutionDir, @string
		proc
			data templatesFolder = Path.Combine(solutionDir, "Templates")
			data result = new Solution()
			data structures = new List<StructureEx>()
			data interfaces = new List<InterfaceEx>()
			data setMatcher = new Regex("^set\s(\w+)\s?=\s?([^\v]+)$")
			data batTextLines = ReadAllBatchLines(targetRegenBat)
			data line, @string

			data useSourceSubfolder = false

			result.SolutionFolder = solutionDir
			foreach line in batTextLines
            begin

                if(line.ToLower().Contains("-o %traditionalbridgeproject%\source\dispatchers"))
				begin
                    useSourceSubfolder = true
                    if(result.TraditionalBridge != ^null)
						result.TraditionalBridge.GenerateIntoSourceFolder = true
                end

				data lineMatch = setMatcher.Match(line)
				;;if((lineMatch?.Groups?.Count ?? 0) == 2)
				if(lineMatch != ^null && lineMatch.Groups != ^null && lineMatch.Groups.Count == 3)
				begin
					data key = lineMatch.Groups[1].Value.ToLower()
					data tmpValue, @string, lineMatch.Groups[2].Value
                    data value, @string, Regex.Replace(tmpValue, "%solutiondir%", "", RegexOptions.IgnoreCase)
					data trimmedValue = value.Trim()
					
                    try
					begin
                        Environment.SetEnvironmentVariable(key, value)
                    end
                    catch(ex, @Exception)
                    begin
						Console.WriteLine(ex.ToString())
                    end
					endtry

					using key select
					(String.Empty),
						nop
					("no_custom_pluralization"),
					begin
						result.NoCustomPluralization = true
                    end
                    ("smc_interfaces"),
                    begin
                        data splitInterfaces = value.Split(new char[#] { ' ' }, StringSplitOptions.RemoveEmptyEntries)
                        AddOrMerge(interfaces, splitInterfaces.Select(lambda(intName) { new InterfaceEx() { Name = intName, GenerateWebAPIController=true, GenerateInterface=true, EnabledGenerators = GetBridgeGenerators(true, false).ToList() } }))
                    end
                    ("smc_interfaces_rest"),
                    begin
                        data splitInterfaces = value.Split(new char[#] { ' ' }, StringSplitOptions.RemoveEmptyEntries)
                        AddOrMerge(interfaces, splitInterfaces.Select(lambda(intName) { new InterfaceEx() { Name = intName, GenerateWebAPIController=true, GenerateInterface=true, EnabledGenerators = GetBridgeGenerators(false, false).ToList() } }))
                    end
                    ("smc_interfaces_signalr"),
                    begin
                        data splitInterfaces = value.Split(new char[#] { ' ' }, StringSplitOptions.RemoveEmptyEntries)
                        AddOrMerge(interfaces, splitInterfaces.Select(lambda(intName) { new InterfaceEx() { Name = intName, GenerateSignalRHub = true, GenerateInterface=true, EnabledGenerators = GetBridgeGenerators(false, true).ToList() } }))
                    end
                    ("smc_interfaces_internal"),
                    begin
                        data splitInterfaces = value.Split(new char[#] { ' ' }, StringSplitOptions.RemoveEmptyEntries)
                        AddOrMerge(interfaces, splitInterfaces.Select(lambda(intName) { new InterfaceEx() { Name = intName, GenerateInterface=true, EnabledGenerators = GetBridgeGenerators(false, false).ToList() } }))
                    end
					("servicesproject"),
					begin
						result.ServicesProject = value 
						result.ServicesNamespace = value 
						result.ServicesFolder = value
					end
					("repositoryproject"),
					begin
						result.RepositoryProject = value 
					end
					("modelsproject"),
					begin
						result.ModelsProject = value 
						result.ModelsNamespace = value 
						result.ModelsFolder = value
					end
					("controllersproject"),
					begin
						result.ControllersProject = value 
						result.ControllersNamespace = value 
						result.ControllersFolder = value
					end
					("hostproject"),
					begin
						result.SelfHostFolder = value 
						result.SelfHostNamespace = value 
						result.SelfHostProject = value  
					end
					("testproject"),
					begin
						result.UnitTestFolder = value 
						result.UnitTestsNamespace = value 
						result.UnitTestFolder = value
					end
					("traditionalbridgeproject"),
					begin
						result.TraditionalBridgeProject = value 
						result.TraditionalBridgeNamespace = value 
						result.TraditionalBridgeFolder = value
					end

					("data_structures"),
					begin
                        structures.AddRange(LoadStructureNames(value, GetODataGenerators))
					end

					("data_aliases"),
					begin
						if(string.Compare(trimmedValue, "%data_structures%", true) != 0)
						begin
							data splitStructures = value.Split(new char[#] { ' ' }, StringSplitOptions.RemoveEmptyEntries)
							data index = 1
							for index from 1 thru Math.Min(splitStructures.Length, structures.Count) by 1
							begin
								structures[index - 1].Aliases = new List<string>() { splitStructures[index] }
							end
						end
					end

					("data_files"),
					begin
						if(string.Compare(trimmedValue, "%data_structures%", true) != 0)
						begin
                            data splitStructures = value.Split(new char[#] { ' ' }, StringSplitOptions.RemoveEmptyEntries)

                            ;;this is probably duplicate info if the structure is pointing to a json file
							;;skip it we did the glue above in data_structures
                            if(splitStructures.Length > 1 || !File.Exists(splitStructures[1]))
                            begin
								data index = 1
								for index from 1 thru Math.Min(splitStructures.Length, structures.Count) by 1
								begin
									data targetAlias = structures[index - 1].Aliases.FirstOrDefault() ?? structures[index - 1].Name
									structures[index - 1].Files = new Dictionary<string, string>() { { targetAlias, splitStructures[index]} }
								end
                            end

						end
					end

					("custom_structures"),
					begin
                        structures.AddRange(LoadStructureNames(value, GetCustomGenerators))
					end

;					("custom_aliases"),
;					begin
;						if(string.Compare(value, "%custom_structures%", true) != 0)
;						begin
;							data splitStructures = value.Split(new char[#] { ' ' }, StringSplitOptions.RemoveEmptyEntries)
;							data index = 1
;							for index from 1 thru Math.Min(splitStructures.Length, result.ExtendedStructures.Count) by 1
;							begin
;								structures[index - 1].Alias = splitStructures[index]
;							end
;						end
;					end
					("bridge_structures"),
                    begin
                        structures.AddRange(LoadStructureNames(value, lambda() { GetBridgeGenerators(false, false) }))
					end
					("enable_odata_environment"),
					begin
						result.GenerateOData = true
					end
					("enable_self_host_generation"),
					begin
						result.GenerateSelfHost = true
					end
					("enable_create_test_files"),
					begin
						result.CreateTestFiles = true
					end
					("do_not_set_file_logicals"),
					begin
						result.DisableFileLogicals = true
					end
					("enable_get_all"),
					begin
						result.FullCollectionEndpoints = true
					end
					("enable_get_one"),
					begin
						result.PrimaryKeyEndpoints = true
					end
					("enable_postman_tests"),
					begin
						result.GeneratePostmanTests = true
					end
					("enable_alternate_keys"),
					begin
						result.AlternateKeyEndpoints = true
					end
					("enable_count"),
					begin
						result.CollectionCountEndpoints = true
					end
					("enable_property_endpoints"),
					begin
						result.IndividualPropertyEndpoints = true
					end
					("enable_select"),
					begin
						result.ODataSelect = true
					end
					("enable_filter"),
					begin
						result.ODataFilter = true
					end
					("enable_orderby"),
					begin
						result.ODataOrderBy = true
					end
					("enable_top"),
					begin
						result.ODataTop = true
					end
					("enable_skip"),
					begin
						result.ODataSkip = true
					end
					("enable_relations"),
					begin
						result.ODataRelations = true
					end
					("enable_relations_validation"),
					begin
						result.ODataRelationValidation = true
					end
					("enable_put"),
					begin
						result.PutEndpoints = true
					end
					("enable_post"),
					begin
						result.PostEndpoints = true
					end
					("enable_patch"),
					begin
						result.PatchEndpoints = true
					end
					("enable_delete"),
					begin
						result.DeleteEndpoints = true
					end
					("enable_sproc"),
					begin
						result.StoredProcedureRouting = true
					end
					("enable_adapter_routing"),
					begin
						result.AdapterRouting = true
					end
					("enable_authentication"),
					begin
						result.Authentication = true
					end
					("enable_custom_authentication"),
					begin
						result.CustomAuthentication = true
					end
					("enable_field_security"),
					begin
						result.FieldSecurity = true
					end
					("enable_signalr"),
					begin
						result.SmcSignalRHubs = true
					end
					("enable_unit_test_generation"),
					begin
						result.GenerateUnitTests = true
					end
					("enable_case_sensitive_url"),
					begin
						result.CaseSensitiveUrls = true
					end
					("enable_cors"),
					begin
						result.CrossDomainBrowsing = true
					end
					("enable_iis_support"),
					begin
						result.IISSupport = true
					end
					("enable_overlays"),
					begin
						result.FieldOverlays = true
					end
					("enable_alternate_field_names"),
					begin
						result.AlternateFieldNames = true
					end
					("enable_read_only_properties"),
					begin
						result.ReadOnlyProperties = true
					end
					("enable_traditional_bridge_generation"),
					begin
						if(result.TraditionalBridge == ^null) 
							result.TraditionalBridge = new TraditionalBridge()
					end
					("enable_xfserverplus_migration"),
					begin
						if(result.TraditionalBridge == ^null) 
							result.TraditionalBridge = new TraditionalBridge()

						result.TraditionalBridge.EnableXFServerPlusMigration = true
					end
					;("enable_xfserverplus_model_generation"),
					;begin
					;	if(result.TraditionalBridge == ^null) 
					;		result.TraditionalBridge = new TraditionalBridge()
					;
					;	result.TraditionalBridge.Model = true
					;end
					("enable_bridge_sample_dispatchers"),
					begin
						if(result.TraditionalBridge == ^null) 
							result.TraditionalBridge = new TraditionalBridge()

						result.TraditionalBridge.EnableSampleDispatchers = true
					end
					("enable_bridge_optional_parameters"),
					begin
						if(result.TraditionalBridge == ^null) 
							result.TraditionalBridge = new TraditionalBridge()

						result.TraditionalBridge.EnableOptionalParameters = true
					end
					("enable_newtonsoft"),
					begin
						result.EnableNewtonsoftJson = true
					end
					("smc_xml_file"),
					begin
						if(result.TraditionalBridge == ^null) 
							result.TraditionalBridge = new TraditionalBridge()

						result.TraditionalBridge.XFServerSMCPath = value
					end
					("smc_interface"),
					begin
						if(result.TraditionalBridge == ^null) 
							result.TraditionalBridge = new TraditionalBridge()

						data splitInterfaces = value.Split(new char[#] { ' ' }, StringSplitOptions.RemoveEmptyEntries)
						interfaces.AddRange(splitInterfaces.Select(lambda(ifaceName) { new InterfaceEx() { Name = ifaceName, GenerateInterface = true, GenerateWebAPIController = true, GenerateSignalRHub = result.SmcSignalRHubs } }))
					end
                    (),
						if(!value.Contains("%~"))
							Environment.SetEnvironmentVariable(key, Environment.ExpandEnvironmentVariables(value))
					endusing
				end
			end

			data structureLookup = new Dictionary<string, StructureEx>(StringComparer.CurrentCultureIgnoreCase)

			data struct, @StructureEx
			foreach struct in structures
			begin
				data existingStruct, @StructureEx
				if(structureLookup.TryGetValue(struct.Name, existingStruct)) then
				begin
					data newGenerator, @string
					foreach newGenerator in struct.EnabledGenerators
					begin
						if(!existingStruct.EnabledGenerators.Contains(newGenerator))
							existingStruct.EnabledGenerators.Add(newGenerator)
					end

					existingStruct.Aliases.AddRange(struct.Aliases)
					data fileKvp, @KeyValuePair<string, string>
					foreach fileKvp in struct.Files
					begin
						if(existingStruct.Files.ContainsKey(fileKvp.Key))
						begin
							if(string.Compare(fileKvp.Value, existingStruct.Files[fileKvp.Key], true) == 0) then
								nextloop
							else
								throw new InvalidOperationException(string.Format("duplicate alias -> file mapping detected {0} -> {1} and {2} -> {3}", fileKvp.Key, fileKvp.Value, fileKvp.Key, existingStruct.Files[fileKvp.Key]))
						end

						existingStruct.Files.Add(fileKvp.Key, fileKvp.Value)
					end

				end
				else
				begin
					structureLookup.Add(struct.Name, struct)
				end
			end

			;;Customization file defailts to templates directory
            data customizationFile = Path.Combine(templatesFolder, "HarmonyCoreCustomization.json")

			;;If not there, look in the current directory
            if (!File.Exists(customizationFile))
            begin
                customizationFile = "HarmonyCoreCustomization.json"
            end

			;;Do we have a customization file?
			if (File.Exists(customizationFile))
			begin
				data json = File.ReadAllText(customizationFile)
				data configFileObject = (@JObject)JsonConvert.DeserializeObject(json)
				data configProp = configFileObject.Property("CustomRelations")
				if(configProp != ^null && configProp.Value != ^null)
				begin
					data customRelationSpecs = configProp.Value.ToObject<List<CustomRelationSpec>>()
					data rel, @CustomRelationSpec
					foreach rel in customRelationSpecs
					begin
						if(structureLookup.ContainsKey(rel.FromStructure))
						begin
							data targetStructure = structureLookup[rel.FromStructure]
							if(targetStructure.RelationsSpecs == ^null)
								targetStructure.RelationsSpecs = new List<CustomRelationSpec>()

							targetStructure.RelationsSpecs.Add(rel)
						end
					end
				end
			end


			result.ExtendedStructures = structureLookup.Values.ToList()
			result.ExtendedInterfaces = interfaces

			data tempContext = new CodeGenContext(new CodeGenTaskSet())
			tempContext.Taskset = new CodeGenTaskSet()
			tempContext.Taskset.Tasks.Add(new CodeGenTask() { UserTokenFile = userTokens })
			tempContext.CurrentTask = tempContext.Taskset.Tasks.First()
			UserTokenCollection.LoadTokensFromFile(tempContext)

			

			;;data rel, @CustomRelationSpec
			;;foreach rel in relations.Relations

			data ut, @UserToken
			foreach ut in tempContext.UserTokens
			begin
				using ut.Name.ToLower() select
				("services_namespace"),
					result.ServicesNamespace = ut.Value
				("models_namespace"),
					result.ModelsNamespace = ut.Value
				("client_models_namespace"),
					result.ClientModelsNamespace = ut.Value
				("unit_tests_namespace"),
					result.UnitTestsNamespace = ut.Value
				("data_folder"),
					result.DataFolder = ut.Value
				("api_docs_path"),
					result.APIDocsPath = ut.Value
				("api_title"),
					result.APITitle = ut.Value
				("api_version"),
					result.APIVersion = ut.Value
				("api_description"),
					result.APIDescription = ut.Value
				("api_terms"),
					result.APITerms = ut.Value
				("api_contact_name"),
					result.APIContactName = ut.Value
				("api_contact_email"),
					result.APIContactEmail = ut.Value
				("api_license_name"),
					result.APILicenseName = ut.Value
				("api_license_url"),
					result.APILicenseUrl = ut.Value
				("api_enable_query_params"),
					result.APIEnableQueryParams = ut.Value
				("server_name"),
					result.ServerName = ut.Value
				("server_http_port"),
					result.ServerHttpPort = ut.Value
				("server_https_port"),
					result.ServerHttpsPort = ut.Value
				("server_base_path"),
					result.ServerBasePath = ut.Value
				("oauth_server"),
					result.OAuthServer = ut.Value
				("oauth_api"),
					result.OAuthApi = ut.Value
				("oauth_client"),
					result.OAuthClient = ut.Value
				("oauth_secret"),
					result.OAuthSecret = ut.Value
				("oauth_test_user"),
					result.OAuthTestUser = ut.Value
				("oauth_test_password"),
					result.OAuthTestPassword = ut.Value
				("custom_auth_controller_path"),
					result.CustomAuthController = ut.Value
				("custom_auth_endpoint_path"),
					result.CustomAuthEndpointPath = ut.Value
				("custom_auth_username"),
					result.CustomAuthUserName = ut.Value
				("custom_auth_password"),
					result.CustomAuthPassword = ut.Value
				("signalr_path"),
					result.SignalRPath = ut.Value
				("roles_get"),
					nop
				("roles_post"),
					nop
				("roles_put"),
					nop
				("roles_patch"),
					nop
				("roles_delete"),
					nop
				("bridge_smc_interface"),
					nop
				(),
				begin
					if(result.UserTokens == ^null)
						result.UserTokens = new Dictionary<string, string>()

					result.UserTokens.Add(ut.Name, ut.Value)
				end
				endusing
			end


			FixRPS(result)
			FixProps(result)

			mreturn result
		endmethod

        private static method LoadStructureNames, @List<StructureEx>
            value, @string
			getGenerators, @Func<Hashset<string>>
        proc
			data structures = new List<StructureEx>()
            ;;create structureex for each data structure, default to adding model generator
            ;;wait until later processing to add additional generators
            data splitStructures = value.Split(new char[#] { ' ' }, StringSplitOptions.RemoveEmptyEntries)
            &    .SelectMany<string, string>(lambda(splitStr) { Environment.ExpandEnvironmentVariables(splitStr).Split(new char[#] { ' ' }, StringSplitOptions.RemoveEmptyEntries) }).ToArray()

            ;;if there is only one structure specified and it happens to have a matching file on disk
            ;;we have to load it as a json file array of Codegen.StructureDefinition
            ;;pull this data out and translate into StructureEx format
            data tempExpandedStructureFile = Environment.ExpandEnvironmentVariables(splitStructures.FirstOrDefault() ?? "")
            if(splitStructures.Length >= 1 && File.Exists(tempExpandedStructureFile)) then
            begin
                data structureFile, @string
                foreach structureFile in splitStructures
                begin
                    data expandedStructureFile = Environment.ExpandEnvironmentVariables(structureFile)
                    data structureDefinitions = JsonConvert.DeserializeObject<[#]StructureDefinition>(File.ReadAllText(expandedStructureFile))
                    lambda mapToStructure(strDef)
                    begin
                        data aliases, @List<string>, ^null
                        if(!string.IsNullOrWhiteSpace(strDef.Alias))
                        begin
                            aliases = new List<string>() { strDef.Alias }
                        end

                        data files, @Dictionary<string, string>, ^null
                        if(!string.IsNullOrWhiteSpace(strDef.File))
                        begin
                            files = new Dictionary<string, string>() { { strDef.Structure, strDef.File } }
                        end

                        mreturn new StructureEx() { Name = strDef.Structure, Aliases = aliases, Files = files, EnabledGenerators = getGenerators() }
                    end

                    structures.AddRange(structureDefinitions.Select(mapToStructure))
                end
            end
            else
                structures.AddRange(splitStructures.Select(lambda(strName) { new StructureEx() { Name = strName, EnabledGenerators = getGenerators() } }))

			mreturn structures
		endmethod

        public method GenerateSolution, @GenerateResult
            messageHandler, @Action<CodeGenTask, string>
            cancelToken, CancellationToken
            additionalGenerators, @Dictionary<string, GeneratorBase>
        proc
			mreturn GenerateSolution(new SolutionGenerationEvents() { Message = messageHandler, Error = messageHandler }, cancelToken, additionalGenerators)
		endmethod


		public method GenerateSolution, @GenerateResult
			handlers, @SolutionGenerationEvents
			cancelToken, CancellationToken
			additionalGenerators, @Dictionary<string, GeneratorBase>
		proc
			data result = new GenerateResult()

			;;gather all generators from structureex's 
			data loadedRelations = new List<CustomRelationSpec>()
			data structLookup = new Dictionary<string, StructureEx>(StringComparer.InvariantCultureIgnoreCase)
			data rpsLookup = new Dictionary<string, RpsStructure>(StringComparer.InvariantCultureIgnoreCase)
			data interfaceLookup = new Dictionary<string, InterfaceEx>(StringComparer.InvariantCultureIgnoreCase)
			data smcLookup = new Dictionary<string, SmcInterface>(StringComparer.InvariantCultureIgnoreCase)
			data generators = additionalGenerators == ^null ? new Dictionary<string, GeneratorBase>() : new Dictionary<string, GeneratorBase>(additionalGenerators)
			data rpsStruct, @RpsStructure
			foreach rpsStruct in RPS.Structures
			begin
				rpsLookup.Add(rpsStruct.Name, rpsStruct)
			end

			data struct, @StructureEx 
			foreach struct in ExtendedStructures
			begin
				if(!rpsLookup.ContainsKey(struct.Name)) then
					result.ValidationErrors.Add(string.Format("Failed to match structure {0} with a structure from rps", struct.Name))
				else
					structLookup.Add(struct.Name, struct)

				data generator, @string
				foreach generator in struct.EnabledGenerators
				begin
					if(!generators.ContainsKey(generator))
					begin
						generators.Add(generator, (@GeneratorBase)Activator.CreateInstance(Type.GetType("HarmonyCoreGenerator.Generator." + generator)))
					end
				end

				if(struct.RelationsSpecs != ^null)
				begin
					data relation, @CustomRelationSpec
					foreach relation in struct.RelationsSpecs
					begin
						loadedRelations.Add(relation)
					end
				end

			end

			if(this.TraditionalBridge?.SMC != ^null)
			begin



				data iface, @SmcInterface
				foreach iface in this.TraditionalBridge.SMC.Interfaces
				begin
					smcLookup.Add(iface.Name, iface)
				end

				data ifacex, @InterfaceEx
				foreach ifacex in ExtendedInterfaces
				begin
					if(!smcLookup.ContainsKey(ifacex.Name)) then
						result.ValidationErrors.Add(string.Format("Failed to match interface {0} with an interface from smc", ifacex.Name))
					else
					begin
						
						interfaceLookup.Add(ifacex.Name, ifacex)
						if(!generators.ContainsKey(^nameof(TraditionalBridgeGenerator)))
						begin
							generators.Add(^nameof(TraditionalBridgeGenerator), new TraditionalBridgeGenerator())
						end
						if(ifacex.GenerateWebAPIController && !generators.ContainsKey(^nameof(WebApiGenerator)))
						begin
							generators.Add(^nameof(WebApiGenerator), new WebApiGenerator())
						end
						if(ifacex.GenerateSignalRHub && !generators.ContainsKey(^nameof(SignalRGenerator)))
						begin
							generators.Add(^nameof(SignalRGenerator), new SignalRGenerator())
						end
						if(ifacex.GenerateODataController && !generators.ContainsKey(^nameof(ODataGenerator)))
						begin
							generators.Add(^nameof(ODataGenerator), new ODataGenerator())
						end
						;;if the interface exists we may need to go add all of its struct parameters into the extended structure list
						iface = smcLookup[ifacex.Name]
						data smcMeth, @SmcMethod
						foreach smcMeth in iface.Methods
						begin
							data param, @SmcParameter
							foreach param in smcMeth.Parameters
							begin
								if(!string.IsNullOrWhiteSpace(param.StructureName))
								begin
									if(!rpsLookup.ContainsKey(param.StructureName)) then
										result.ValidationErrors.Add(string.Format("Failed to match structure {0} with a structure from rps", param.StructureName))
									else if(!structLookup.ContainsKey(param.StructureName))
									begin
										data generators1 = new HashSet<string>()
										generators1.Add(^nameof(TraditionalBridgeGenerator))
										struct = new StructureEx() { Name = param.StructureName, EnabledGenerators = generators1 }
										structLookup.Add(struct.Name, struct)
									end
								
									if(!generators.ContainsKey(^nameof(ModelGenerator)))
									begin
										generators.Add(^nameof(ModelGenerator), new ModelGenerator())
									end
								end
							end
						end
					end
				end
			end

			;;snap this off so we dont accidentally persist odd changes to the structure list
			data originalStructures = ExtendedStructures
			ExtendedStructures = structLookup.Values.ToList()

			data orderedGenerators = generators.Values.OrderBy(lambda(gen) { gen.Priority } ).ToList()

			;;run defaults
			data genInstance, @GeneratorBase
			foreach genInstance in orderedGenerators
			begin
				genInstance.ApplyDefaults(this)
			end

			;;run validation
			foreach genInstance in orderedGenerators
			begin
				result.ValidationErrors.AddRange(genInstance.ValidateSolution(this))
			end

			if(result.ValidationErrors.Count > 0)
				mreturn result
			
			;;run task creation
			foreach genInstance in orderedGenerators
			begin
				result.CodeGenTasks.AddRange(genInstance.GenerateTasks(this))
			end

			;;put back the structures we want to persist on disk
			ExtendedStructures = originalStructures
			
			data taskPart, @CodeGenTask
			foreach taskPart in result.CodeGenTasks
			begin
				lambda TaskCompletedHandler(tsk)
				begin
					data message, @LogEntry
					foreach message in tsk.Messages
					begin
						handlers?.Message(tsk, message.Message)
					end

                    handlers?.TaskComplete(tsk)

					cancelToken.ThrowIfCancellationRequested()
				end

                lambda TaskStartedHandler(tsk)
                begin
                    handlers?.TaskStarted(tsk)
				end

                taskPart.TaskComplete += TaskCompletedHandler
                taskPart.StartingTask += TaskStartedHandler
			end


			;;extract list of files that should be created from tasks
			;;create code generator context w/extended structure/field properties

			
            data taskSet = new CodeGenTaskSet()

			taskSet.Tasks.AddRange<CodeGenTask>(result.CodeGenTasks)
			taskSet.RepositoryMainFile = RPSMFIL
			taskSet.RepositoryTextFile = RPSTFIL
			taskSet.LoggingLevel = LoggingLevel.Normal
			if(this.TraditionalBridge != ^null)
			begin
				data cgt, @CodeGenTask
				foreach cgt in taskSet.Tasks
				begin
					cgt.MethodCatalogFile = Environment.ExpandEnvironmentVariables(this.TraditionalBridge.XFServerSMCPath)
				end
			end

			taskSet.TemplateFolder = Path.Combine(SolutionFolder, "Templates")

			;; Set defines
			if (CreateTestFiles)
				taskSet.Defines.Add("DEFINED_ENABLE_CREATE_TEST_FILES")
			if (DisableFileLogicals)
				taskSet.Defines.Add("DEFINED_DO_NOT_SET_FILE_LOGICALS")
			if (FullCollectionEndpoints)
				taskSet.Defines.Add("DEFINED_ENABLE_GET_ALL")
			if (PrimaryKeyEndpoints)
				taskSet.Defines.Add("DEFINED_ENABLE_GET_ONE")
			if (AlternateKeyEndpoints)
				taskSet.Defines.Add("DEFINED_ENABLE_ALTERNATE_KEYS")
			if (CollectionCountEndpoints)
				taskSet.Defines.Add("DEFINED_ENABLE_COUNT")
			if (IndividualPropertyEndpoints)
				taskSet.Defines.Add("DEFINED_ENABLE_PROPERTY_ENDPOINTS")
			if (ODataSelect)
				taskSet.Defines.Add("DEFINED_ENABLE_SELECT")
			if (ODataFilter)
				taskSet.Defines.Add("DEFINED_ENABLE_FILTER")
			if (ODataOrderBy)
				taskSet.Defines.Add("DEFINED_ENABLE_ORDERBY")
			if (ODataTop)
				taskSet.Defines.Add("DEFINED_ENABLE_TOP")
			if (ODataSkip)
				taskSet.Defines.Add("DEFINED_ENABLE_SKIP")
			if (ODataRelations)
				taskSet.Defines.Add("DEFINED_ENABLE_RELATIONS")
			if (ODataRelationValidation)
				taskSet.Defines.Add("DEFINED_ENABLE_RELATIONS_VALIDATION")
			if (PutEndpoints)
				taskSet.Defines.Add("DEFINED_ENABLE_PUT")
			if (PostEndpoints)
				taskSet.Defines.Add("DEFINED_ENABLE_POST")
			if (PatchEndpoints)
				taskSet.Defines.Add("DEFINED_ENABLE_PATCH")
			if (DeleteEndpoints)
				taskSet.Defines.Add("DEFINED_ENABLE_DELETE")
			if (StoredProcedureRouting)
				taskSet.Defines.Add("DEFINED_ENABLE_SPROC")
			if (AdapterRouting)
				taskSet.Defines.Add("DEFINED_ENABLE_ADAPTER_ROUTING")
			if (Authentication)
				taskSet.Defines.Add("DEFINED_ENABLE_AUTHENTICATION")
			if (CustomAuthentication)
				taskSet.Defines.Add("DEFINED_ENABLE_CUSTOM_AUTHENTICATION")
			if (FieldSecurity)
				taskSet.Defines.Add("DEFINED_ENABLE_FIELD_SECURITY")
			if (SmcSignalRHubs)
				taskSet.Defines.Add("DEFINED_ENABLE_SIGNALR")
			if (CaseSensitiveUrls)
				taskSet.Defines.Add("DEFINED_ENABLE_CASE_SENSITIVE_URL")
			if (CrossDomainBrowsing)
				taskSet.Defines.Add("DEFINED_ENABLE_CORS")
			if (IISSupport)
				taskSet.Defines.Add("DEFINED_ENABLE_IIS_SUPPORT")
			if (ReadOnlyProperties)
				taskSet.Defines.Add("DEFINED_ENABLE_READ_ONLY_PROPERTIES")
			if (TraditionalBridge != ^null && TraditionalBridge.EnableSampleDispatchers)
				taskSet.Defines.Add("DEFINED_ENABLE_BRIDGE_SAMPLE_DISPATCHERS")
			if (EnableNewtonsoftJson)
				taskSet.Defines.Add("DEFINED_ENABLE_NEWTONSOFT")

			data context = new CodeGenContext(taskSet)
			context.ExtendedRepositoryProperties = GetExtendedStructureProperties()
			
			;;compiler bug
			;;context.Structures = new RpsStructureCollection(RpsLoadMode.Load, AlternateFieldNames ?? false)
			;;internal compiler error
			;;data altFieldNames = AlternateFieldNames ?? false
			data altFieldNames = false
			if(AlternateFieldNames.HasValue)
				altFieldNames = AlternateFieldNames.Value

			context.Structures = new RpsStructureCollection(RpsLoadMode.Load, altFieldNames)
			context.Properties.TryAdd(^typeof(HarmonyCoreExtensions.Helpers.RelationLookup), new HarmonyCoreExtensions.Helpers.RelationLookup(context.Structures, loadedRelations))
			;;create code generator
			data codegenInstance = new CodeGenerator(taskSet, context)
			;;record difference between files that exist on disk and predicted file list
			;;pass taskset to codegenerator
            ;;run code generator
			handlers?.GenerationStarted(taskSet)

			result.Failed = codegenInstance.GenerateCode()
            result.Messages = taskSet.Messages.ToList()

			if(handlers?.GenerationFinished != ^null)
				handlers.GenerationFinished(taskSet)
			;;return generator result
			;;   errors
			;;   created files
			;;   removed files?? how can we track files that should be removed
			
			mreturn result
		endmethod

        private static method AddOrMerge, void
            collection, @List<InterfaceEx>
            source, @IEnumerable<InterfaceEx>
        proc
            data sourceIface, @InterfaceEx
            foreach sourceIface in source
            begin
				data foundMergeTarget = false
                data targetIface, @InterfaceEx
                foreach targetIface in collection
                begin
                    if(string.Compare(targetIface.Name, sourceIface.Name, true) == 0)
                    begin
                        targetIface.EnabledGenerators = targetIface.EnabledGenerators.Union(sourceIface.EnabledGenerators).ToList()
                        targetIface.GenerateInterface = NullableOr(targetIface.GenerateInterface, sourceIface.GenerateInterface)
                        targetIface.GenerateODataController = NullableOr(targetIface.GenerateODataController, sourceIface.GenerateODataController)
                        targetIface.GenerateSignalRHub = NullableOr(targetIface.GenerateSignalRHub, sourceIface.GenerateSignalRHub)
                        targetIface.GenerateWebAPIController = NullableOr(targetIface.GenerateWebAPIController, sourceIface.GenerateWebAPIController)
                    end
                end
                if(!foundMergeTarget)
					collection.Add(sourceIface)
            end
        endmethod

        private static method GetBridgeGenerators, @HashSet<string>
            includeWebApi, boolean
			includeSignalR, boolean
        proc
			data result = new HashSet<string>()
			result.Add(^nameof(ModelGenerator))
            result.Add(^nameof(TraditionalBridgeGenerator))
            if(includeWebApi)
                result.Add(^nameof(WebApiGenerator))
            if(includeSignalR)
                result.Add(^nameof(SignalRGenerator))

			mreturn result
		endmethod

		private static method GetODataGenerators, @HashSet<string>
		proc
			data result = new HashSet<string>()
			result.Add(^nameof(ModelGenerator))
			result.Add(^nameof(ODataGenerator))
			result.Add(^nameof(EFCoreGenerator))
			mreturn result
		endmethod

		private static method GetCustomGenerators, @HashSet<string>
		proc
			data result = new HashSet<string>()
			result.Add(^nameof(ModelGenerator))
			mreturn result
		endmethod

        private static method NullableOr, Nullable<Boolean>
            input1, Nullable<Boolean>
            input2, Nullable<Boolean>
        proc
            if(input1 == ^null)
                mreturn input2

            if(input2 == ^null)
                mreturn input1

            data result, boolean, input1.Value || input2.Value
			mreturn result
        endmethod


	endclass

	;;duplicate from Codegen/Codegen.dbl
    public class StructureDefinition

        {JsonProperty(Required=Required.Always)}
        public readwrite property Structure, string

        public readwrite property Alias, string

        public readwrite property File, string
	
    endclass

	public class GenerateResult
		public readwrite property ValidationErrors, @List<string>, new List<string>()
		public readwrite property CodeGenTasks, @List<CodeGenTask>, new List<CodeGenTask>()
		public readwrite property Messages, @List<LogEntry>, new List<LogEntry>()
		public readwrite property Failed, boolean, true
	endclass

	public Enum VersioningOrSwaggerMode
		None,               0
		ApiVersioning,      1
		GenerateSwaggerDoc, 2
	endenum
endnamespace
