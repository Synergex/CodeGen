import System
import System.Collections.Generic
import System.Text
import Newtonsoft.Json
import CodeGen.RepositoryAPI
import CodeGen.Engine
import System.IO
import System.Text.RegularExpressions
import System.Linq
import HarmonyCoreGenerator.Generator
import HarmonyCoreExtensions
import System.Threading
import System.Diagnostics
import CodeGen.MethodCatalogAPI
import Microsoft.Build.Logging
import Microsoft.Build.Framework
import Newtonsoft.Json.Linq
import Newtonsoft.Json

namespace HarmonyCoreGenerator.Model

    {JsonObject(ItemNullValueHandling=NullValueHandling.Ignore)}
    public class Solution
        public readwrite property CreatedWithToolVersion, @string, "1.0"
        public readwrite property WrittenWithToolVersion, @string, "1.0"

        public readwrite property RPSMFIL, @string
        public readwrite property RPSTFIL, @string
        public readwrite property RepositoryProject, @string
        public readwrite property EnableNewtonsoftJson, boolean?
        public readwrite property TraditionalBridge, @TraditionalBridge

        public readwrite property ServicesNamespace, @string
        public readwrite property ControllersNamespace, @string
        public readwrite property ModelsNamespace, @string
        public readwrite property ClientModelsNamespace, @string
        public readwrite property UnitTestsNamespace, @string
        public readwrite property SelfHostNamespace, @string
        public readwrite property TraditionalBridgeNamespace, @string
        public readwrite property UnitTestsBaseNamespace, @string

        public readwrite property DataFolder, @string
        {JsonIgnore}
        public readwrite property SolutionFolder, @string

        public readwrite property APIDocsPath, @string
        public readwrite property APITitle, @string
        public readwrite property APIVersion, @string
        public readwrite property APIDescription, @string
        public readwrite property APITerms, @string
        public readwrite property APIContactName, @string
        public readwrite property APIContactEmail, @string
        public readwrite property APILicenseName, @string
        public readwrite property APILicenseUrl, @string
        public readwrite property APIEnableQueryParams, @string

        public readwrite property ServerProtocol, @string
        public readwrite property ServerName, @string
        public readwrite property ServerHttpPort, @string
        public readwrite property ServerHttpsPort, @string
        public readwrite property ServerBasePath, @string

        public readwrite property OAuthServer, @string
        public readwrite property OAuthApi, @string
        public readwrite property OAuthClient, @string
        public readwrite property OAuthSecret, @string
        public readwrite property OAuthTestUser, @string
        public readwrite property OAuthTestPassword, @string

        public readwrite property CustomAuthController, @string
        public readwrite property CustomAuthEndpointPath, @string
        public readwrite property CustomAuthUserName, @string
        public readwrite property CustomAuthPassword, @string

        public readwrite property SignalRPath, @string

        public readwrite property TemplatesFolder, @string
        public readwrite property ServicesFolder, @string
        public readwrite property ControllersFolder, @string
        public readwrite property ModelsFolder, @string
        public readwrite property SelfHostFolder, @string
        public readwrite property UnitTestFolder, @string
        public readwrite property IsolatedFolder, @string
        public readwrite property TraditionalBridgeFolder, @string
        public readwrite property ServicesProject, @string
        public readwrite property ControllersProject, @string
        public readwrite property ModelsProject, @string
        public readwrite property SelfHostProject, @string
        public readwrite property UnitTestProject, @string
        public readwrite property IsolatedProject, @string
        public readwrite property TraditionalBridgeProject, @string
        public readwrite property FullCollectionEndpoints, boolean?
        public readwrite property PrimaryKeyEndpoints, boolean?
        public readwrite property AlternateKeyEndpoints, boolean?
        public readwrite property CollectionCountEndpoints, boolean?
        public readwrite property IndividualPropertyEndpoints, boolean?
        public readwrite property PutEndpoints, boolean?
        public readwrite property PostEndpoints, boolean?
        public readwrite property PatchEndpoints, boolean?
        public readwrite property DeleteEndpoints, boolean?
        public readwrite property ODataSelect, boolean?
        public readwrite property ODataFilter, boolean?
        public readwrite property ODataOrderBy, boolean?
        public readwrite property ODataTop, boolean?
        public readwrite property ODataSkip, boolean?
        public readwrite property ODataRelations, boolean?
        public readwrite property ODataRelationValidation, boolean?
        public readwrite property GenerateSelfHost, boolean?
        public readwrite property CreateTestFiles, boolean?
        public readwrite property GeneratePostmanTests, boolean?
        public readwrite property GenerateUnitTests, boolean?
        public readwrite property DocumentPropertyEndpoints, boolean?
        public readwrite property GenerateOData, boolean?
        public readwrite property DisableFileLogicals, boolean?
        public readwrite property NoCustomPluralization, boolean?

        public readwrite property Authentication, boolean?
        public readwrite property CustomAuthentication, boolean?
        public readwrite property FieldSecurity, boolean?
        public readwrite property AdapterRouting, boolean?
        public readwrite property StoredProcedureRouting, boolean?
        public readwrite property CaseSensitiveUrls, boolean?
        public readwrite property CrossDomainBrowsing, boolean?
        public readwrite property IISSupport, boolean?
        public readwrite property FieldOverlays, boolean?
        public readwrite property AlternateFieldNames, boolean?
        public readwrite property ReadOnlyProperties, boolean?
        public readwrite property SmcPostmanTests, boolean?
        public readwrite property SmcSignalRHubs, boolean?
        public readwrite property SignalRHubs, boolean?
        public readwrite property DisableTraditionalBridgeDOMembers, boolean?
        public readwrite property VersioningOrSwagger, VersioningOrSwaggerMode?
        public readwrite property CustomSettings, @Dictionary<string, string>, new Dictionary<string, string>()
        public readwrite property UserTokens, @Dictionary<string, string>

        private _rps, @Repository
        {JsonIgnore}
        public property RPS, @Repository
            method get
            proc
                data altFieldName, boolean, AlternateFieldNames ?? false
                if(_rps == ^null)
                begin
                    data localmFil = Environment.ExpandEnvironmentVariables(RPSMFIL)
                    data localtFil = Environment.ExpandEnvironmentVariables(RPSTFIL)

                    if(!File.Exists(localmFil))
                        localmFil = Path.Combine(SolutionFolder, localmFil)

                    if(!File.Exists(localtFil))
                        localtFil = Path.Combine(SolutionFolder, localtFil)

                    _rps = new Repository(localmFil, localtFil, altFieldName)
                end

                mreturn _rps
            endmethod
        endproperty

        public readwrite property ExtendedStructures, @List<StructureEx>
        public readwrite property ExtendedInterfaces, @List<InterfaceEx>

        public class SolutionGenerationEvents
            public GenerationStarted, @Action<CodeGenTaskSet>
            public GenerationFinished, @Action<CodeGenTaskSet>
            public Message, @Action<CodeGenTask, string>
            public TaskComplete, @Action<CodeGenTask>
            public TaskStarted, @Action<CodeGenTask>
            public Error, @Action<CodeGenTask, string>
        endclass


        public method GetExtendedStructureProperties, @Dictionary<string, Dictionary<string, Object>>
        proc
            data result = new Dictionary<string, Dictionary<string, Object>>()
            data stex, @StructureEx
            foreach stex in ExtendedStructures
            begin
                data stexDictionary = new Dictionary<string, object>()
                if(!(stex.EnableGetAll ?? FullCollectionEndpoints ?? true))
                    stexDictionary.Add("NO_GET_ALL_ENDPOINT", true)
                if(!(stex.EnableGetOne ?? PrimaryKeyEndpoints ?? true))
                    stexDictionary.Add("NO_GET_ENDPOINT", true)
                if(!(stex.EnablePost ?? PostEndpoints ?? true))
                    stexDictionary.Add("NO_POST_ENDPOINT", true)
                if(!(stex.EnablePut ?? PutEndpoints ?? true))
                    stexDictionary.Add("NO_PUT_ENDPOINT", true)
                if(!(stex.EnablePatch ?? PatchEndpoints ?? true))
                    stexDictionary.Add("NO_PATCH_ENDPOINT", true)
                if(!(stex.EnableDelete ?? DeleteEndpoints ?? true))
                    stexDictionary.Add("NO_DELETE_ENDPOINT", true)
                if(!(stex.EnableAltGet ?? AlternateKeyEndpoints ?? true))
                    stexDictionary.Add("NO_ALTERNATE_KEY_ENDPOINTS", true)
                if(!(IndividualPropertyEndpoints ?? true))
                    stexDictionary.Add("NO_PROPERTY_ENDPOINTS", true)
                if(!(stex.EnableRelations ?? ODataRelations ?? true))
                    stexDictionary.Add("HARMONYCORE_RELATIONS_ENABLED", true)
                if(!(stex.EnableRelationValidation ?? ODataRelationValidation ?? true))
                    stexDictionary.Add("HARMONYCORE_RELATIONS_VALIDATION_ENABLED", true)

                data fieldLookup, @KeyValuePair<string, Dictionary<string, Object>>
                foreach fieldLookup in stex.Fields
                begin
                    stexDictionary.Add(stex.Name + "." + fieldLookup.Key, fieldLookup.Value)
                end

                if(stexDictionary.Count > 0)
                    result.Add(stex.Name, stexDictionary)
            end

            mreturn result
        endmethod

        public method GetUserDefinedTokens, @List<UserToken>
        proc
            data result = new List<UserToken>()
            result.Add(new UserToken("SERVICES_NAMESPACE", ServicesNamespace ?? "Services"))
            result.Add(new UserToken("MODELS_NAMESPACE", ModelsNamespace ?? "Services.Models"))
            result.Add(new UserToken("CONTROLLERS_NAMESPACE", ControllersNamespace ?? "Services.Controllers"))
            result.Add(new UserToken("CLIENT_MODELS_NAMESPACE", ClientModelsNamespace ?? "Services.Test.Models"))
            result.Add(new UserToken("UNIT_TESTS_NAMESPACE", UnitTestsNamespace ?? "Services.Test.UnitTests"))
            result.Add(new UserToken("UNIT_TESTS_BASE_NAMESPACE", UnitTestsBaseNamespace ?? "Services.Test"))
            result.Add(new UserToken("SELF_HOST_NAMESPACE", SelfHostNamespace ?? "Services.Host"))
            result.Add(new UserToken("DATA_FOLDER", DataFolder ?? "SampleData"))
            result.Add(new UserToken("API_DOCS_PATH", APIDocsPath ?? "api-docs"))
            result.Add(new UserToken("API_TITLE", APITitle ?? "Harmony Core Sample API"))
            result.Add(new UserToken("API_VERSION", APIVersion ?? "1"))
            result.Add(new UserToken("API_DESCRIPTION", APIDescription ?? "This environment presents an example of using Harmony Core to expose a collection of RESTful Web Service endpoints that allow you to interact with a small sample dataset."))
            result.Add(new UserToken("API_TERMS", APITerms ?? "Open Source"))
            result.Add(new UserToken("API_CONTACT_NAME", APIContactName ?? "Jodah Veloper"))
            result.Add(new UserToken("API_CONTACT_EMAIL", APIContactEmail ?? "jodah.veloper@synergexpsg.com"))
            result.Add(new UserToken("API_LICENSE_NAME", APILicenseName ?? "BSD-2-Clause"))
            result.Add(new UserToken("API_LICENSE_URL", APILicenseUrl ?? "https://opensource.org/licenses/BSD-2-Clause"))
            result.Add(new UserToken("API_ENABLE_QUERY_PARAMS", APIEnableQueryParams ?? "(MaxExpansionDepth=4)"))
            result.Add(new UserToken("SERVER_PROTOCOL", ServerProtocol ?? "https"))
            result.Add(new UserToken("SERVER_NAME", ServerName ?? "localhost"))
            result.Add(new UserToken("SERVER_HTTP_PORT", ServerHttpPort ?? "8085"))
            result.Add(new UserToken("SERVER_HTTPS_PORT", ServerHttpsPort ?? "8086"))
            result.Add(new UserToken("SERVER_BASE_PATH", ServerBasePath ?? "odata"))

            result.Add(new UserToken("OAUTH_SERVER", OAuthServer ?? "http://localhost:5000"))
            result.Add(new UserToken("OAUTH_API", OAuthApi ?? "api1"))
            result.Add(new UserToken("OAUTH_CLIENT", OAuthClient ?? "ro.client"))
            result.Add(new UserToken("OAUTH_SECRET", OAuthSecret ?? "CBF7EBE6-D46E-41A7-903B-766A280616C3"))
            result.Add(new UserToken("OAUTH_TEST_USER", OAuthTestUser ?? "jodah"))
            result.Add(new UserToken("OAUTH_TEST_PASSWORD", OAuthTestPassword ?? "P@ssw0rd"))
            result.Add(new UserToken("CUSTOM_AUTH_CONTROLLER_PATH", CustomAuthController ?? "Authentication"))
            result.Add(new UserToken("CUSTOM_AUTH_ENDPOINT_PATH", CustomAuthEndpointPath ?? "GetToken"))
            result.Add(new UserToken("CUSTOM_AUTH_USERNAME", CustomAuthUserName ?? "username"))
            result.Add(new UserToken("CUSTOM_AUTH_PASSWORD", CustomAuthPassword ?? "password"))
            
            if(UserTokens != ^null)
            begin
                data kvp, KeyValuePair<string, string>
                foreach kvp in UserTokens
                begin
                    result.Add(new UserToken(kvp.Key, kvp.Value))
                end
            end


            mreturn result
        endmethod

        private static method FixRPS, void
            targetSolution, @Solution
        proc
            
            if(File.Exists(targetSolution.RPSMFIL) && File.Exists(targetSolution.RPSTFIL))
            begin
                mreturn
            end

            if(!string.IsNullOrWhiteSpace(targetSolution.RPSMFIL) && !string.IsNullOrWhiteSpace(targetSolution.RPSTFIL))
            begin
                data expandedMFIL = Environment.ExpandEnvironmentVariables(targetSolution.RPSMFIL)
                data expandedTFIL = Environment.ExpandEnvironmentVariables(targetSolution.RPSTFIL)

                if(File.Exists(expandedMFIL) && File.Exists(expandedTFIL))
                begin
                    ;;dont actually replace the setting value, it will get persisted to the file
                    ;;targetSolution.RPSMFIL = FileTools.GetRelativePath(targetSolution.SolutionFolder,expandedMFIL)
                    ;;targetSolution.RPSTFIL = FileTools.GetRelativePath(targetSolution.SolutionFolder,expandedTFIL)
                    mreturn
                end
            end

            data repositoryFile = "Repository.synproj"
            data projectDir = Path.Combine(targetSolution.SolutionFolder, "Repository")

            if(!String.IsNullOrWhiteSpace(targetSolution.RepositoryProject))
            begin
                projectDir = Path.Combine(targetSolution.SolutionFolder, Path.GetDirectoryName(targetSolution.RepositoryProject))
                repositoryFile = Path.GetFileName(targetSolution.RepositoryProject)
            end

            
            data rpsOutputFolder = Path.Combine(projectDir, "bin", "Debug")
            data rpsMFile = Path.Combine(rpsOutputFolder, "rpsmain.ism") 
            data rpsTFile = Path.Combine(rpsOutputFolder, "rpstext.ism")

            if(!System.IO.File.Exists(Path.Combine(projectDir, repositoryFile)))
            begin
                rpsMFile = Environment.GetEnvironmentVariable("RPSMFIL")
                rpsTFile = Environment.GetEnvironmentVariable("RPSTFIL")
                Console.WriteLine("FixRPS(): Couldnt find a valid repository project attempting to fallback to existing RPSMFIL({0}) | RPSTFIL({1}) from environment", rpsMFile ?? "not found", rpsTFile ?? "not found")
            end

            if(File.Exists(rpsMFile) && File.Exists(rpsTFile))
            begin
                targetSolution.RPSMFIL = FileTools.GetRelativePath(targetSolution.SolutionFolder,rpsMFile)
                targetSolution.RPSTFIL = FileTools.GetRelativePath(targetSolution.SolutionFolder,rpsTFile)
                mreturn
            end

            
            
            data basePath = GetDotnetBasePath()

            data projectOptions =  new Microsoft.Build.Definition.ProjectOptions()
            data evalContext = Microsoft.Build.Evaluation.Context.EvaluationContext.Create(Microsoft.Build.Evaluation.Context.EvaluationContext.SharingPolicy.Isolated)
            projectOptions.EvaluationContext = evalContext
            projectOptions.GlobalProperties = new Dictionary<String, String>()
            projectOptions.GlobalProperties.Add("SolutionDir", targetSolution.SolutionFolder + "\")
            projectOptions.GlobalProperties.Add("Configuration", "Debug")
            projectOptions.GlobalProperties.Add("Platform", "AnyCPU")
            projectOptions.GlobalProperties.Add("NuGetRestoreTargets", Path.Combine(basePath, "Nuget.targets"))
            data msbuildRepositoryProject = Microsoft.Build.Evaluation.ProjectCollection.GlobalProjectCollection.LoadProject(Path.Combine(projectDir, repositoryFile), projectOptions.GlobalProperties, projectOptions.ToolsVersion)
            data logger = new ConsoleLogger(LoggerVerbosity.Minimal)
            msbuildRepositoryProject.Build("Build", new ILogger[#] { logger })
            logger.Shutdown()
            
            if(File.Exists(rpsMFile) && File.Exists(rpsTFile))
            begin
                targetSolution.RPSMFIL = FileTools.GetRelativePath(targetSolution.SolutionFolder,rpsMFile)
                targetSolution.RPSTFIL = FileTools.GetRelativePath(targetSolution.SolutionFolder,rpsTFile)
                mreturn
            end
            ;;need to also combined with output path possibly
            rpsMFile = msbuildRepositoryProject.GetPropertyValue("MOutputName")
            rpsTFile = msbuildRepositoryProject.GetPropertyValue("TOutputName")

            if(string.IsNullOrWhiteSpace(Path.GetDirectoryName(rpsMFile)))
                rpsMFile = Path.Combine(projectDir, rpsMFile)

            if(string.IsNullOrWhiteSpace(Path.GetDirectoryName(rpsTFile)))
                rpsTFile = Path.Combine(projectDir, rpsTFile)
                     
            rpsOutputFolder = Path.GetDirectoryName(rpsMFile)
            
            if(!File.Exists(rpsMFile) && !rpsMFile.EndsWith(".ism", StringComparison.CurrentCultureIgnoreCase))
                rpsMFile += ".ism"

            if(!File.Exists(rpsTFile) && !rpsTFile.EndsWith(".ism", StringComparison.CurrentCultureIgnoreCase))
                rpsTFile += ".ism"

            ;;msbuildRepositoryProject.ProjectCollection.UnloadProject(msbuildRepositoryProject)
            targetSolution._rps = ^null
            if (File.Exists(rpsMFile)) then
            begin
                targetSolution.RPSMFIL = FileTools.GetRelativePath(targetSolution.SolutionFolder,rpsMFile)
            end
            else
            begin
                throw new InvalidOperationException(String.Format("Repository main file '{0}' was not found in the expected location!",rpsMFile))
            end

            if (File.Exists(rpsTFile)) then
            begin
                targetSolution.RPSTFIL = FileTools.GetRelativePath(targetSolution.SolutionFolder,rpsTFile)
            end
            else
            begin
                throw new InvalidOperationException(String.Format("Repository text file '{0}' was not found in the expected location!",rpsTFile))
            end 
        endmethod

        public static method GetDotnetBasePath, @string
        proc
            data basePath = Environment.GetEnvironmentVariable("DOTNET_BASE_PATH")
            try
            begin
                data dotnetInfo = new Process()
                dotnetInfo.StartInfo = new ProcessStartInfo("dotnet", "--info")
                dotnetInfo.StartInfo.RedirectStandardOutput = true
                dotnetInfo.Start()
                data dotnetInfoOutput = dotnetInfo.StandardOutput.ReadToEnd()

                data basePathPosition = dotnetInfoOutput.IndexOf("Base Path:") + 10
                if(basePathPosition < 10)
                    throw new Exception(string.Format("failed to find dotnet.exe path, base was {0}", dotnetInfoOutput))

                data endOfPathLine = dotnetInfoOutput.IndexOf(Environment.NewLine, basePathPosition)

                if(endOfPathLine < 0)
                    throw new Exception(string.Format("failed to find dotnet.exe path, base was {0}", dotnetInfoOutput))

                basePath = dotnetInfoOutput.Substring(basePathPosition, endOfPathLine - basePathPosition).Trim()
            end			
            catch(ex, @Exception)
            begin
                if(string.IsNullOrWhiteSpace(basePath))
                    throw
            end
            endtry
            mreturn basePath
        endmethod

        private static method FixProps, void
            targetSolution, @Solution
        proc
            targetSolution.TemplatesFolder = targetSolution.TemplatesFolder ?? "Templates"
            targetSolution.ServicesFolder = targetSolution.ServicesFolder ?? "Services"
            targetSolution.ControllersFolder = targetSolution.ControllersFolder ?? "Services.Controllers"
            targetSolution.ModelsFolder = targetSolution.ModelsFolder ?? "Services.Models"
            targetSolution.SelfHostFolder = targetSolution.SelfHostFolder ?? "Services.Host"
            targetSolution.UnitTestFolder = targetSolution.UnitTestFolder ?? "Services.Test"
            targetSolution.IsolatedFolder = targetSolution.IsolatedFolder ?? "Isolated"
            targetSolution.TraditionalBridgeFolder = targetSolution.TraditionalBridgeFolder ?? "TraditionalBridge"
            targetSolution.ServicesProject = targetSolution.ServicesProject ?? "Services"
            targetSolution.ControllersProject = targetSolution.ControllersProject ?? "Services.Controllers"
            targetSolution.ModelsProject = targetSolution.ModelsProject ?? "Services.Models"
            targetSolution.SelfHostProject = targetSolution.SelfHostProject ?? "Services.Host"
            targetSolution.UnitTestProject = targetSolution.UnitTestProject ?? "Services.Test"
            targetSolution.IsolatedProject = targetSolution.IsolatedProject ?? "Isolated"
            targetSolution.TraditionalBridgeProject = targetSolution.TraditionalBridgeProject ?? "TraditionalBridge"
        endmethod

        public static method LoadSolution, @Solution
            targetJsonFile, @string
            solutionDir, @string
        proc
            data jsonText = File.ReadAllText(targetJsonFile)
            data jsonObject = JsonConvert.DeserializeObject<Solution>(jsonText)
            jsonObject.SolutionFolder = solutionDir 
            FixRPS(jsonObject)
            FixProps(jsonObject)
            mreturn jsonObject
        endmethod

        private static method ReadAllBatchLines ,[#]string
            required in aFilename   ,string
            endparams

            record
                inArray         ,[#]string
                outArray        ,[#]string
                ctr             ,int
                outArrayLen     ,int
                isContinuation  ,Boolean
            endrecord

        proc

            inArray = File.ReadAllLines(aFilename)

            outArrayLen = 0
            for ctr from 1 thru inArray.Length
            begin
                if (isContinuation == true) then
                    inArray[outArrayLen] = concatBatchLines(inArray[outArrayLen], inArray[ctr])
                else
                    inArray[outArrayLen+=1] = inArray[ctr]

                if (inArray[outArrayLen].EndsWith("^")) then
                    isContinuation = true
                else
                    isContinuation = false
            end

            outArray = new string[outArrayLen]

            for ctr from 1 thru outArrayLen
                outArray[ctr] = inArray[ctr]

            mreturn outArray

        endmethod

        private static method concatBatchLines, string
            required in aLine1  ,string
            required in aLine2  ,string
            endparams

        proc

            if (aLine1.EndsWith("^"))
                mreturn String.Concat(aLine1.Substring(0, aLine1.Length-1), aLine2)

            mreturn String.Concat(aLine1, aLine2)

        endmethod

        public static method LoadSolution, @Solution
            targetRegenBat, @string
            userTokens, @string
            solutionDir, @string
        proc
            data templatesFolder = Path.Combine(solutionDir, "Templates")
            data result = new Solution()
            data structures = new List<StructureEx>()
            data interfaces = new List<InterfaceEx>()
            data setMatcher = new Regex("^set\s(\w+)\s?=\s?([^\v]+)$")
            data batTextLines = ReadAllBatchLines(targetRegenBat)
            data line, @string

            data useSourceSubfolder = false

            result.SolutionFolder = solutionDir
            foreach line in batTextLines
            begin

                if(line.ToLower().Contains("-o %traditionalbridgeproject%\source\dispatchers"))
                begin
                    useSourceSubfolder = true
                    if(result.TraditionalBridge != ^null)
                        result.TraditionalBridge.GenerateIntoSourceFolder = true
                end

                data lineMatch = setMatcher.Match(line)
                ;;if((lineMatch?.Groups?.Count ?? 0) == 2)
                if(lineMatch != ^null && lineMatch.Groups != ^null && lineMatch.Groups.Count == 3)
                begin
                    data key = lineMatch.Groups[1].Value.ToLower()
                    data tmpValue, @string, lineMatch.Groups[2].Value
                    data value, @string, Regex.Replace(tmpValue, "%solutiondir%", "", RegexOptions.IgnoreCase)
                    data trimmedValue = value.Trim()
                    
                    try
                    begin
                        Environment.SetEnvironmentVariable(key, value)
                    end
                    catch(ex, @Exception)
                    begin
                        Console.WriteLine(ex.ToString())
                    end
                    endtry

                    using key select
                    (String.Empty),
                        nop
                    ("no_custom_pluralization"),
                    begin
                        result.NoCustomPluralization = true
                    end
                    ("smc_interfaces"),
                    begin
                        data splitInterfaces = value.Split(new char[#] { ' ' }, StringSplitOptions.RemoveEmptyEntries)
                        AddOrMerge(interfaces, splitInterfaces.Select(lambda(intName) { new InterfaceEx() { Name = intName, GenerateWebAPIController=true, GenerateInterface=true, EnabledGenerators = GetBridgeGenerators(true, false).ToList() } }))
                    end
                    ("smc_interfaces_rest"),
                    begin
                        data splitInterfaces = value.Split(new char[#] { ' ' }, StringSplitOptions.RemoveEmptyEntries)
                        AddOrMerge(interfaces, splitInterfaces.Select(lambda(intName) { new InterfaceEx() { Name = intName, GenerateWebAPIController=true, GenerateInterface=true, EnabledGenerators = GetBridgeGenerators(false, false).ToList() } }))
                    end
                    ("smc_interfaces_signalr"),
                    begin
                        data splitInterfaces = value.Split(new char[#] { ' ' }, StringSplitOptions.RemoveEmptyEntries)
                        AddOrMerge(interfaces, splitInterfaces.Select(lambda(intName) { new InterfaceEx() { Name = intName, GenerateSignalRHub = true, GenerateInterface=true, EnabledGenerators = GetBridgeGenerators(false, true).ToList() } }))
                    end
                    ("smc_interfaces_internal"),
                    begin
                        data splitInterfaces = value.Split(new char[#] { ' ' }, StringSplitOptions.RemoveEmptyEntries)
                        AddOrMerge(interfaces, splitInterfaces.Select(lambda(intName) { new InterfaceEx() { Name = intName, GenerateInterface=true, EnabledGenerators = GetBridgeGenerators(false, false).ToList() } }))
                    end
                    ("servicesproject"),
                    begin
                        result.ServicesProject = value 
                        result.ServicesNamespace = value 
                        result.ServicesFolder = value
                    end
                    ("repositoryproject"),
                    begin
                        result.RepositoryProject = value 
                    end
                    ("modelsproject"),
                    begin
                        result.ModelsProject = value 
                        result.ModelsNamespace = value 
                        result.ModelsFolder = value
                    end
                    ("controllersproject"),
                    begin
                        result.ControllersProject = value 
                        result.ControllersNamespace = value 
                        result.ControllersFolder = value
                    end
                    ("hostproject"),
                    begin
                        result.SelfHostFolder = value 
                        result.SelfHostNamespace = value 
                        result.SelfHostProject = value  
                    end
                    ("testproject"),
                    begin
                        result.UnitTestFolder = value 
                        result.UnitTestsNamespace = value 
                        result.UnitTestFolder = value
                    end
                    ("traditionalbridgeproject"),
                    begin
                        result.TraditionalBridgeProject = value 
                        result.TraditionalBridgeNamespace = value 
                        result.TraditionalBridgeFolder = value
                    end

                    ("data_structures"),
                    begin
                        structures.AddRange(LoadStructureNames(value, GetODataGenerators))
                    end

                    ("data_aliases"),
                    begin
                        if(string.Compare(trimmedValue, "%data_structures%", true) != 0)
                        begin
                            data splitStructures = value.Split(new char[#] { ' ' }, StringSplitOptions.RemoveEmptyEntries)
                            data index = 1
                            for index from 1 thru Math.Min(splitStructures.Length, structures.Count) by 1
                            begin
                                structures[index - 1].Aliases = new List<string>() { splitStructures[index] }
                            end
                        end
                    end

                    ("data_files"),
                    begin
                        if(string.Compare(trimmedValue, "%data_structures%", true) != 0)
                        begin
                            data splitStructures = value.Split(new char[#] { ' ' }, StringSplitOptions.RemoveEmptyEntries)

                            ;;this is probably duplicate info if the structure is pointing to a json file
                            ;;skip it we did the glue above in data_structures
                            if(splitStructures.Length > 1 || !File.Exists(splitStructures[1]))
                            begin
                                data index = 1
                                for index from 1 thru Math.Min(splitStructures.Length, structures.Count) by 1
                                begin
                                    data targetAlias = structures[index - 1].Aliases.FirstOrDefault() ?? structures[index - 1].Name
                                    structures[index - 1].Files = new Dictionary<string, string>() { { targetAlias, splitStructures[index]} }
                                end
                            end

                        end
                    end

                    ("custom_structures"),
                    begin
                        structures.AddRange(LoadStructureNames(value, GetCustomGenerators))
                    end

;					("custom_aliases"),
;					begin
;						if(string.Compare(value, "%custom_structures%", true) != 0)
;						begin
;							data splitStructures = value.Split(new char[#] { ' ' }, StringSplitOptions.RemoveEmptyEntries)
;							data index = 1
;							for index from 1 thru Math.Min(splitStructures.Length, result.ExtendedStructures.Count) by 1
;							begin
;								structures[index - 1].Alias = splitStructures[index]
;							end
;						end
;					end
                    ("bridge_structures"),
                    begin
                        structures.AddRange(LoadStructureNames(value, lambda() { GetBridgeGenerators(false, false) }))
                    end
                    ("enable_odata_environment"),
                    begin
                        result.GenerateOData = true
                    end
                    ("enable_self_host_generation"),
                    begin
                        result.GenerateSelfHost = true
                    end
                    ("enable_create_test_files"),
                    begin
                        result.CreateTestFiles = true
                    end
                    ("do_not_set_file_logicals"),
                    begin
                        result.DisableFileLogicals = true
                    end
                    ("enable_get_all"),
                    begin
                        result.FullCollectionEndpoints = true
                    end
                    ("enable_get_one"),
                    begin
                        result.PrimaryKeyEndpoints = true
                    end
                    ("enable_postman_tests"),
                    begin
                        result.GeneratePostmanTests = true
                    end
                    ("enable_alternate_keys"),
                    begin
                        result.AlternateKeyEndpoints = true
                    end
                    ("enable_count"),
                    begin
                        result.CollectionCountEndpoints = true
                    end
                    ("enable_property_endpoints"),
                    begin
                        result.IndividualPropertyEndpoints = true
                    end
                    ("enable_select"),
                    begin
                        result.ODataSelect = true
                    end
                    ("enable_filter"),
                    begin
                        result.ODataFilter = true
                    end
                    ("enable_orderby"),
                    begin
                        result.ODataOrderBy = true
                    end
                    ("enable_top"),
                    begin
                        result.ODataTop = true
                    end
                    ("enable_skip"),
                    begin
                        result.ODataSkip = true
                    end
                    ("enable_relations"),
                    begin
                        result.ODataRelations = true
                    end
                    ("enable_relations_validation"),
                    begin
                        result.ODataRelationValidation = true
                    end
                    ("enable_put"),
                    begin
                        result.PutEndpoints = true
                    end
                    ("enable_post"),
                    begin
                        result.PostEndpoints = true
                    end
                    ("enable_patch"),
                    begin
                        result.PatchEndpoints = true
                    end
                    ("enable_delete"),
                    begin
                        result.DeleteEndpoints = true
                    end
                    ("enable_sproc"),
                    begin
                        result.StoredProcedureRouting = true
                    end
                    ("enable_adapter_routing"),
                    begin
                        result.AdapterRouting = true
                    end
                    ("enable_authentication"),
                    begin
                        result.Authentication = true
                    end
                    ("enable_custom_authentication"),
                    begin
                        result.CustomAuthentication = true
                    end
                    ("enable_field_security"),
                    begin
                        result.FieldSecurity = true
                    end
                    ("enable_signalr"),
                    begin
                        result.SmcSignalRHubs = true
                        result.SignalRHubs = true
                    end
                    ("enable_unit_test_generation"),
                    begin
                        result.GenerateUnitTests = true
                    end
                    ("enable_case_sensitive_url"),
                    begin
                        result.CaseSensitiveUrls = true
                    end
                    ("enable_cors"),
                    begin
                        result.CrossDomainBrowsing = true
                    end
                    ("enable_iis_support"),
                    begin
                        result.IISSupport = true
                    end
                    ("enable_overlays"),
                    begin
                        result.FieldOverlays = true
                    end
                    ("enable_alternate_field_names"),
                    begin
                        result.AlternateFieldNames = true
                    end
                    ("enable_read_only_properties"),
                    begin
                        result.ReadOnlyProperties = true
                    end
                    ("enable_traditional_bridge_generation"),
                    begin
                        if(result.TraditionalBridge == ^null) 
                            result.TraditionalBridge = new TraditionalBridge()
                    end
                    ("enable_xfserverplus_migration"),
                    begin
                        if(result.TraditionalBridge == ^null) 
                            result.TraditionalBridge = new TraditionalBridge()

                        result.TraditionalBridge.EnableXFServerPlusMigration = true
                    end
                    ;("enable_xfserverplus_model_generation"),
                    ;begin
                    ;	if(result.TraditionalBridge == ^null) 
                    ;		result.TraditionalBridge = new TraditionalBridge()
                    ;
                    ;	result.TraditionalBridge.Model = true
                    ;end
                    ("enable_bridge_sample_dispatchers"),
                    begin
                        if(result.TraditionalBridge == ^null) 
                            result.TraditionalBridge = new TraditionalBridge()

                        result.TraditionalBridge.EnableSampleDispatchers = true
                    end
                    ("enable_bridge_optional_parameters"),
                    begin
                        if(result.TraditionalBridge == ^null) 
                            result.TraditionalBridge = new TraditionalBridge()

                        result.TraditionalBridge.EnableOptionalParameters = true
                    end
                    ("enable_newtonsoft"),
                    begin
                        result.EnableNewtonsoftJson = true
                    end
                    ("smc_xml_file"),
                    begin
                        if(result.TraditionalBridge == ^null) 
                            result.TraditionalBridge = new TraditionalBridge()

                        result.TraditionalBridge.XFServerSMCPath = value
                    end
                    ("smc_interface"),
                    begin
                        if(result.TraditionalBridge == ^null) 
                            result.TraditionalBridge = new TraditionalBridge()

                        data splitInterfaces = value.Split(new char[#] { ' ' }, StringSplitOptions.RemoveEmptyEntries)
                        interfaces.AddRange(splitInterfaces.Select(lambda(ifaceName) { new InterfaceEx() { Name = ifaceName, GenerateInterface = true, GenerateWebAPIController = true, GenerateSignalRHub = result.SmcSignalRHubs } }))
                    end
                    (),
                        if(!value.Contains("%~"))
                            Environment.SetEnvironmentVariable(key, Environment.ExpandEnvironmentVariables(value))
                    endusing
                end
            end

            data structureLookup = new Dictionary<string, StructureEx>(StringComparer.CurrentCultureIgnoreCase)

            data struct, @StructureEx
            foreach struct in structures
            begin
                data existingStruct, @StructureEx
                if(structureLookup.TryGetValue(struct.Name, existingStruct)) then
                begin
                    data newGenerator, @string
                    foreach newGenerator in struct.EnabledGenerators
                    begin
                        if(!existingStruct.EnabledGenerators.Contains(newGenerator))
                            existingStruct.EnabledGenerators.Add(newGenerator)
                    end

                    existingStruct.Aliases.AddRange(struct.Aliases)
                    data fileKvp, @KeyValuePair<string, string>
                    foreach fileKvp in struct.Files
                    begin
                        if(existingStruct.Files.ContainsKey(fileKvp.Key))
                        begin
                            if(string.Compare(fileKvp.Value, existingStruct.Files[fileKvp.Key], true) == 0) then
                                nextloop
                            else
                                throw new InvalidOperationException(string.Format("duplicate alias -> file mapping detected {0} -> {1} and {2} -> {3}", fileKvp.Key, fileKvp.Value, fileKvp.Key, existingStruct.Files[fileKvp.Key]))
                        end

                        existingStruct.Files.Add(fileKvp.Key, fileKvp.Value)
                    end

                end
                else
                begin
                    structureLookup.Add(struct.Name, struct)
                end
            end

            ;;Customization file defailts to templates directory
            data customizationFile = Path.Combine(templatesFolder, "HarmonyCoreCustomization.json")

            ;;If not there, look in the current directory
            if (!File.Exists(customizationFile))
            begin
                customizationFile = "HarmonyCoreCustomization.json"
            end

            ;;Do we have a customization file?
            if (File.Exists(customizationFile))
            begin
                data json = File.ReadAllText(customizationFile)
                data configFileObject = (@JObject)JsonConvert.DeserializeObject(json)
                data configProp = configFileObject.Property("CustomRelations")
                if(configProp != ^null && configProp.Value != ^null)
                begin
                    data customRelationSpecs = configProp.Value.ToObject<List<CustomRelationSpec>>()
                    data rel, @CustomRelationSpec
                    foreach rel in customRelationSpecs
                    begin
                        if(structureLookup.ContainsKey(rel.FromStructure))
                        begin
                            data targetStructure = structureLookup[rel.FromStructure]
                            if(targetStructure.RelationsSpecs == ^null)
                                targetStructure.RelationsSpecs = new List<CustomRelationSpec>()

                            targetStructure.RelationsSpecs.Add(rel)
                        end
                    end
                end
            end


            result.ExtendedStructures = structureLookup.Values.ToList()
            result.ExtendedInterfaces = interfaces

            data tempContext = new CodeGenContext(new CodeGenTaskSet())
            tempContext.Taskset = new CodeGenTaskSet()
            tempContext.Taskset.Tasks.Add(new CodeGenTask() { UserTokenFile = userTokens })
            tempContext.CurrentTask = tempContext.Taskset.Tasks.First()
            UserTokenCollection.LoadTokensFromFile(tempContext)

            

            ;;data rel, @CustomRelationSpec
            ;;foreach rel in relations.Relations

            data ut, @UserToken
            foreach ut in tempContext.UserTokens
            begin
                using ut.Name.ToLower() select
                ("services_namespace"),
                    result.ServicesNamespace = ut.Value
                ("models_namespace"),
                    result.ModelsNamespace = ut.Value
                ("client_models_namespace"),
                    result.ClientModelsNamespace = ut.Value
                ("unit_tests_namespace"),
                    result.UnitTestsNamespace = ut.Value
                ("data_folder"),
                    result.DataFolder = ut.Value
                ("api_docs_path"),
                    result.APIDocsPath = ut.Value
                ("api_title"),
                    result.APITitle = ut.Value
                ("api_version"),
                    result.APIVersion = ut.Value
                ("api_description"),
                    result.APIDescription = ut.Value
                ("api_terms"),
                    result.APITerms = ut.Value
                ("api_contact_name"),
                    result.APIContactName = ut.Value
                ("api_contact_email"),
                    result.APIContactEmail = ut.Value
                ("api_license_name"),
                    result.APILicenseName = ut.Value
                ("api_license_url"),
                    result.APILicenseUrl = ut.Value
                ("api_enable_query_params"),
                    result.APIEnableQueryParams = ut.Value
                ("server_name"),
                    result.ServerName = ut.Value
                ("server_http_port"),
                    result.ServerHttpPort = ut.Value
                ("server_https_port"),
                    result.ServerHttpsPort = ut.Value
                ("server_base_path"),
                    result.ServerBasePath = ut.Value
                ("oauth_server"),
                    result.OAuthServer = ut.Value
                ("oauth_api"),
                    result.OAuthApi = ut.Value
                ("oauth_client"),
                    result.OAuthClient = ut.Value
                ("oauth_secret"),
                    result.OAuthSecret = ut.Value
                ("oauth_test_user"),
                    result.OAuthTestUser = ut.Value
                ("oauth_test_password"),
                    result.OAuthTestPassword = ut.Value
                ("custom_auth_controller_path"),
                    result.CustomAuthController = ut.Value
                ("custom_auth_endpoint_path"),
                    result.CustomAuthEndpointPath = ut.Value
                ("custom_auth_username"),
                    result.CustomAuthUserName = ut.Value
                ("custom_auth_password"),
                    result.CustomAuthPassword = ut.Value
                ("signalr_path"),
                    ;;shipped bat files all had incorrect values here so we need to ignore them
                ;;result.SignalRPath = ut.Value
                    nop
                ("roles_get"),
                    nop
                ("roles_post"),
                    nop
                ("roles_put"),
                    nop
                ("roles_patch"),
                    nop
                ("roles_delete"),
                    nop
                ("bridge_smc_interface"),
                    nop
                (),
                begin
                    if(result.UserTokens == ^null)
                        result.UserTokens = new Dictionary<string, string>()

                    result.UserTokens.Add(ut.Name, ut.Value)
                end
                endusing
            end


            FixRPS(result)
            FixProps(result)

            mreturn result
        endmethod

        private static method LoadStructureNames, @List<StructureEx>
            value, @string
            getGenerators, @Func<Hashset<string>>
        proc
            data structures = new List<StructureEx>()
            ;;create structureex for each data structure, default to adding model generator
            ;;wait until later processing to add additional generators
            data splitStructures = value.Split(new char[#] { ' ' }, StringSplitOptions.RemoveEmptyEntries)
            &    .SelectMany<string, string>(lambda(splitStr) { Environment.ExpandEnvironmentVariables(splitStr).Split(new char[#] { ' ' }, StringSplitOptions.RemoveEmptyEntries) }).ToArray()

            ;;if there is only one structure specified and it happens to have a matching file on disk
            ;;we have to load it as a json file array of Codegen.StructureDefinition
            ;;pull this data out and translate into StructureEx format
            data tempExpandedStructureFile = Environment.ExpandEnvironmentVariables(splitStructures.FirstOrDefault() ?? "")
            if(splitStructures.Length >= 1 && File.Exists(tempExpandedStructureFile)) then
            begin
                data structureFile, @string
                foreach structureFile in splitStructures
                begin
                    data expandedStructureFile = Environment.ExpandEnvironmentVariables(structureFile)
                    data structureDefinitions = JsonConvert.DeserializeObject<[#]StructureDefinition>(File.ReadAllText(expandedStructureFile))
                    lambda mapToStructure(strDef)
                    begin
                        data aliases, @List<string>, ^null
                        if(!string.IsNullOrWhiteSpace(strDef.Alias))
                        begin
                            aliases = new List<string>() { strDef.Alias }
                        end

                        data files, @Dictionary<string, string>, ^null
                        if(!string.IsNullOrWhiteSpace(strDef.File))
                        begin
                            files = new Dictionary<string, string>() { { strDef.Structure, strDef.File } }
                        end

                        mreturn new StructureEx() { Name = strDef.Structure, Aliases = aliases, Files = files, EnabledGenerators = getGenerators() }
                    end

                    structures.AddRange(structureDefinitions.Select(mapToStructure))
                end
            end
            else
                structures.AddRange(splitStructures.Select(lambda(strName) { new StructureEx() { Name = strName, EnabledGenerators = getGenerators() } }))

            mreturn structures
        endmethod

        public method GenerateSolution, @GenerateResult
            messageHandler, @Action<CodeGenTask, string>
            cancelToken, CancellationToken
            additionalGenerators, @Dictionary<string, GeneratorBase>
        proc
            mreturn GenerateSolution(new SolutionGenerationEvents() { Message = messageHandler, Error = messageHandler }, cancelToken, additionalGenerators)
        endmethod


        public method GenerateSolution, @GenerateResult
            handlers, @SolutionGenerationEvents
            cancelToken, CancellationToken
            additionalGenerators, @Dictionary<string, GeneratorBase>
        proc
            data result = new GenerateResult()

            ;;gather all generators from structureex's 
            data loadedRelations = new List<CustomRelationSpec>()
            data structLookup = new Dictionary<string, StructureEx>(StringComparer.InvariantCultureIgnoreCase)
            data rpsLookup = new Dictionary<string, RpsStructure>(StringComparer.InvariantCultureIgnoreCase)
            data interfaceLookup = new Dictionary<string, InterfaceEx>(StringComparer.InvariantCultureIgnoreCase)
            data smcLookup = new Dictionary<string, SmcInterface>(StringComparer.InvariantCultureIgnoreCase)
            data generators = additionalGenerators == ^null ? new Dictionary<string, GeneratorBase>() : new Dictionary<string, GeneratorBase>(additionalGenerators)
            data rpsStruct, @RpsStructure
            foreach rpsStruct in RPS.Structures
            begin
                rpsLookup.Add(rpsStruct.Name, rpsStruct)
            end

            data struct, @StructureEx 
            foreach struct in ExtendedStructures
            begin
                if(!rpsLookup.ContainsKey(struct.Name)) then
                    result.ValidationErrors.Add(string.Format("Failed to match structure {0} with a structure from rps", struct.Name))
                else
                    structLookup.Add(struct.Name, struct)

                data generator, @string
                foreach generator in struct.EnabledGenerators
                begin
                    if(!generators.ContainsKey(generator))
                    begin
                        generators.Add(generator, (@GeneratorBase)Activator.CreateInstance(Type.GetType("HarmonyCoreGenerator.Generator." + generator)))
                    end
                end

                if(struct.RelationsSpecs != ^null)
                begin
                    data relation, @CustomRelationSpec
                    foreach relation in struct.RelationsSpecs
                    begin
                        loadedRelations.Add(relation)
                    end
                end

            end

            if(this.TraditionalBridge?.SMC != ^null)
            begin



                data iface, @SmcInterface
                foreach iface in this.TraditionalBridge.SMC.Interfaces
                begin
                    smcLookup.Add(iface.Name, iface)
                end

                data ifacex, @InterfaceEx
                foreach ifacex in ExtendedInterfaces
                begin
                    if(!smcLookup.ContainsKey(ifacex.Name)) then
                        result.ValidationErrors.Add(string.Format("Failed to match interface {0} with an interface from smc", ifacex.Name))
                    else
                    begin
                        
                        interfaceLookup.Add(ifacex.Name, ifacex)
                        if(!generators.ContainsKey(^nameof(TraditionalBridgeGenerator)))
                        begin
                            generators.Add(^nameof(TraditionalBridgeGenerator), new TraditionalBridgeGenerator())
                        end
                        if(ifacex.GenerateWebAPIController && !generators.ContainsKey(^nameof(WebApiGenerator)))
                        begin
                            generators.Add(^nameof(WebApiGenerator), new WebApiGenerator())
                        end
                        if(ifacex.GenerateSignalRHub && !generators.ContainsKey(^nameof(SignalRGenerator)))
                        begin
                            generators.Add(^nameof(SignalRGenerator), new SignalRGenerator())
                        end
                        if(ifacex.GenerateODataController && !generators.ContainsKey(^nameof(ODataGenerator)))
                        begin
                            generators.Add(^nameof(ODataGenerator), new ODataGenerator())
                        end
                        ;;if the interface exists we may need to go add all of its struct parameters into the extended structure list
                        iface = smcLookup[ifacex.Name]
                        data smcMeth, @SmcMethod
                        foreach smcMeth in iface.Methods
                        begin
                            data param, @SmcParameter
                            foreach param in smcMeth.Parameters
                            begin
                                if(!string.IsNullOrWhiteSpace(param.StructureName))
                                begin
                                    if(!rpsLookup.ContainsKey(param.StructureName)) then
                                        result.ValidationErrors.Add(string.Format("Failed to match structure {0} with a structure from rps", param.StructureName))
                                    else if(!structLookup.ContainsKey(param.StructureName))
                                    begin
                                        data generators1 = new HashSet<string>()
                                        generators1.Add(^nameof(TraditionalBridgeGenerator))
                                        struct = new StructureEx() { Name = param.StructureName, EnabledGenerators = generators1 }
                                        structLookup.Add(struct.Name, struct)
                                    end
                                
                                    if(!generators.ContainsKey(^nameof(ModelGenerator)))
                                    begin
                                        generators.Add(^nameof(ModelGenerator), new ModelGenerator())
                                    end
                                end
                            end
                        end
                    end
                end
            end

            ;;snap this off so we dont accidentally persist odd changes to the structure list
            data originalStructures = ExtendedStructures
            ExtendedStructures = structLookup.Values.ToList()

            data orderedGenerators = generators.Values.OrderBy(lambda(gen) { gen.Priority } ).ToList()

            ;;run defaults
            data genInstance, @GeneratorBase
            foreach genInstance in orderedGenerators
            begin
                genInstance.ApplyDefaults(this)
            end

            ;;run validation
            foreach genInstance in orderedGenerators
            begin
                result.ValidationErrors.AddRange(genInstance.ValidateSolution(this))
            end

            if(result.ValidationErrors.Count > 0)
                mreturn result
            
            ;;run task creation
            foreach genInstance in orderedGenerators
            begin
                result.CodeGenTasks.AddRange(genInstance.GenerateTasks(this))
            end

            result.CodeGenTasks.Reverse()

            ;;put back the structures we want to persist on disk
            ExtendedStructures = originalStructures
            
            data taskPart, @CodeGenTask
            foreach taskPart in result.CodeGenTasks
            begin
                lambda TaskCompletedHandler(tsk)
                begin
                    data message, @LogEntry
                    if(handlers?.Message != ^null)
                    begin
                        foreach message in tsk.Messages
                        begin
                            handlers.Message(tsk, message.Message)
                        end
                    end

                    if(handlers?.TaskComplete != ^null)
                        handlers.TaskComplete(tsk)

                    cancelToken.ThrowIfCancellationRequested()
                end

                lambda TaskStartedHandler(tsk)
                begin
                    if(handlers?.TaskStarted != ^null)
                        handlers.TaskStarted(tsk)
                end

                taskPart.TaskComplete += TaskCompletedHandler
                taskPart.StartingTask += TaskStartedHandler
            end


            ;;extract list of files that should be created from tasks
            ;;create code generator context w/extended structure/field properties

            
            data taskSet = new CodeGenTaskSet()

            taskSet.Tasks.AddRange<CodeGenTask>(result.CodeGenTasks)
            taskSet.RepositoryMainFile = RPSMFIL
            taskSet.RepositoryTextFile = RPSTFIL
            taskSet.LoggingLevel = LoggingLevel.Normal
            if(this.TraditionalBridge != ^null)
            begin
                if(String.IsNullOrWhiteSpace(this.TraditionalBridge.XFServerSMCPath) || !File.Exists(Environment.ExpandEnvironmentVariables(this.TraditionalBridge.XFServerSMCPath))) then
                begin
                    handlers.Message(taskSet.Tasks.FirstOrDefault(), "XFServerPlus migration was enabled but no valid SMC was found. Bypassing XFServerPlus migration generation for all tasks");
                end
                else
                begin
                    data cgt, @CodeGenTask
                    foreach cgt in taskSet.Tasks
                    begin
                        cgt.MethodCatalogFile = Environment.ExpandEnvironmentVariables(this.TraditionalBridge.XFServerSMCPath)
                    end
                end



                
            end

            taskSet.TemplateFolder = Path.Combine(SolutionFolder, "Templates")

            ;; Set defines
            if (CreateTestFiles)
                taskSet.Defines.Add("DEFINED_ENABLE_CREATE_TEST_FILES")
            if (DisableFileLogicals)
                taskSet.Defines.Add("DEFINED_DO_NOT_SET_FILE_LOGICALS")
            if (FullCollectionEndpoints)
                taskSet.Defines.Add("DEFINED_ENABLE_GET_ALL")
            if (PrimaryKeyEndpoints)
                taskSet.Defines.Add("DEFINED_ENABLE_GET_ONE")
            if (AlternateKeyEndpoints)
                taskSet.Defines.Add("DEFINED_ENABLE_ALTERNATE_KEYS")
            if (CollectionCountEndpoints)
                taskSet.Defines.Add("DEFINED_ENABLE_COUNT")
            if (IndividualPropertyEndpoints)
                taskSet.Defines.Add("DEFINED_ENABLE_PROPERTY_ENDPOINTS")
            if (ODataSelect)
                taskSet.Defines.Add("DEFINED_ENABLE_SELECT")
            if (ODataFilter)
                taskSet.Defines.Add("DEFINED_ENABLE_FILTER")
            if (ODataOrderBy)
                taskSet.Defines.Add("DEFINED_ENABLE_ORDERBY")
            if (ODataTop)
                taskSet.Defines.Add("DEFINED_ENABLE_TOP")
            if (ODataSkip)
                taskSet.Defines.Add("DEFINED_ENABLE_SKIP")
            if (ODataRelations)
                taskSet.Defines.Add("DEFINED_ENABLE_RELATIONS")
            if (ODataRelationValidation)
                taskSet.Defines.Add("DEFINED_ENABLE_RELATIONS_VALIDATION")
            if (PutEndpoints)
                taskSet.Defines.Add("DEFINED_ENABLE_PUT")
            if (PostEndpoints)
                taskSet.Defines.Add("DEFINED_ENABLE_POST")
            if (PatchEndpoints)
                taskSet.Defines.Add("DEFINED_ENABLE_PATCH")
            if (DeleteEndpoints)
                taskSet.Defines.Add("DEFINED_ENABLE_DELETE")
            if (StoredProcedureRouting)
                taskSet.Defines.Add("DEFINED_ENABLE_SPROC")
            if (AdapterRouting)
                taskSet.Defines.Add("DEFINED_ENABLE_ADAPTER_ROUTING")
            if (Authentication)
                taskSet.Defines.Add("DEFINED_ENABLE_AUTHENTICATION")
            if (CustomAuthentication)
                taskSet.Defines.Add("DEFINED_ENABLE_CUSTOM_AUTHENTICATION")
            if (FieldSecurity)
                taskSet.Defines.Add("DEFINED_ENABLE_FIELD_SECURITY")
            if (SmcSignalRHubs || SignalRHubs)
                taskSet.Defines.Add("DEFINED_ENABLE_SIGNALR")
            if (CaseSensitiveUrls)
                taskSet.Defines.Add("DEFINED_ENABLE_CASE_SENSITIVE_URL")
            if (CrossDomainBrowsing)
                taskSet.Defines.Add("DEFINED_ENABLE_CORS")
            if (IISSupport)
                taskSet.Defines.Add("DEFINED_ENABLE_IIS_SUPPORT")
            if (ReadOnlyProperties)
                taskSet.Defines.Add("DEFINED_ENABLE_READ_ONLY_PROPERTIES")
            if (TraditionalBridge != ^null && TraditionalBridge.EnableSampleDispatchers)
                taskSet.Defines.Add("DEFINED_ENABLE_BRIDGE_SAMPLE_DISPATCHERS")
            if (EnableNewtonsoftJson)
                taskSet.Defines.Add("DEFINED_ENABLE_NEWTONSOFT")
            if(DisableTraditionalBridgeDOMembers)
                taskSet.Defines.Add("DEFINED_DISABLE_TRADITIONALBRIDGE_DO_MEMBERS")


            data context = new CodeGenContext(taskSet)
            context.ExtendedRepositoryProperties = GetExtendedStructureProperties()

            ;;compiler bug
            ;;context.Structures = new RpsStructureCollection(RpsLoadMode.Load, AlternateFieldNames ?? false)
            ;;internal compiler error
            ;;data altFieldNames = AlternateFieldNames ?? false
            data altFieldNames = false
            if(AlternateFieldNames.HasValue)
                altFieldNames = AlternateFieldNames.Value

            if(context.Repository == ^null)
                context.Repository = RPS

			context.Structures = new RpsStructureCollection(context.Repository,RpsLoadMode.Load,altFieldNames)
			context.Properties.TryAdd(^typeof(HarmonyCoreExtensions.Helpers.RelationLookup), new HarmonyCoreExtensions.Helpers.RelationLookup(context.Structures, loadedRelations))
			;;create code generator
			data codegenInstance = new CodeGenerator(taskSet, context)
			;;record difference between files that exist on disk and predicted file list
			;;pass taskset to codegenerator
            ;;run code generator
            if(handlers?.GenerationStarted != ^null)
                handlers.GenerationStarted(taskSet)

            result.Failed = codegenInstance.GenerateCode()
            result.Messages = taskSet.Messages.ToList()

            if(handlers?.GenerationFinished != ^null)
                handlers.GenerationFinished(taskSet)
            ;;return generator result
            ;;   errors
            ;;   created files
            ;;   removed files?? how can we track files that should be removed
            
            mreturn result
        endmethod

        private static method AddOrMerge, void
            collection, @List<InterfaceEx>
            source, @IEnumerable<InterfaceEx>
        proc
            data sourceIface, @InterfaceEx
            foreach sourceIface in source
            begin
                data foundMergeTarget = false
                data targetIface, @InterfaceEx
                foreach targetIface in collection
                begin
                    if(string.Compare(targetIface.Name, sourceIface.Name, true) == 0)
                    begin
                        targetIface.EnabledGenerators = targetIface.EnabledGenerators.Union(sourceIface.EnabledGenerators).ToList()
                        targetIface.GenerateInterface = NullableOr(targetIface.GenerateInterface, sourceIface.GenerateInterface)
                        targetIface.GenerateODataController = NullableOr(targetIface.GenerateODataController, sourceIface.GenerateODataController)
                        targetIface.GenerateSignalRHub = NullableOr(targetIface.GenerateSignalRHub, sourceIface.GenerateSignalRHub)
                        targetIface.GenerateWebAPIController = NullableOr(targetIface.GenerateWebAPIController, sourceIface.GenerateWebAPIController)
                    end
                end
                if(!foundMergeTarget)
                    collection.Add(sourceIface)
            end
        endmethod

        private static method GetBridgeGenerators, @HashSet<string>
            includeWebApi, boolean
            includeSignalR, boolean
        proc
            data result = new HashSet<string>()
            result.Add(^nameof(ModelGenerator))
            result.Add(^nameof(TraditionalBridgeGenerator))
            if(includeWebApi)
                result.Add(^nameof(WebApiGenerator))
            if(includeSignalR)
                result.Add(^nameof(SignalRGenerator))

            mreturn result
        endmethod

        private static method GetODataGenerators, @HashSet<string>
        proc
            data result = new HashSet<string>()
            result.Add(^nameof(ModelGenerator))
            result.Add(^nameof(ODataGenerator))
            result.Add(^nameof(EFCoreGenerator))
            mreturn result
        endmethod

        private static method GetCustomGenerators, @HashSet<string>
        proc
            data result = new HashSet<string>()
            result.Add(^nameof(ModelGenerator))
            mreturn result
        endmethod

        private static method NullableOr, Nullable<Boolean>
            input1, Nullable<Boolean>
            input2, Nullable<Boolean>
        proc
            if(input1 == ^null)
                mreturn input2

            if(input2 == ^null)
                mreturn input1

            data result, boolean, input1.Value || input2.Value
            mreturn result
        endmethod


    endclass

    ;;duplicate from Codegen/Codegen.dbl
    public class StructureDefinition

        {JsonProperty(Required=Required.Always)}
        public readwrite property Structure, string

        public readwrite property Alias, string

        public readwrite property File, string
    
    endclass

    public class GenerateResult
        public readwrite property ValidationErrors, @List<string>, new List<string>()
        public readwrite property CodeGenTasks, @List<CodeGenTask>, new List<CodeGenTask>()
        public readwrite property Messages, @List<LogEntry>, new List<LogEntry>()
        public readwrite property Failed, boolean, true
    endclass

    public Enum VersioningOrSwaggerMode
        None,               0
        ApiVersioning,      1
        GenerateSwaggerDoc, 2
    endenum
endnamespace
