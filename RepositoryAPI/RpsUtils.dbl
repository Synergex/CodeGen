;;*****************************************************************************
;;
;; Title:       RpsUtils.dbl
;;
;; Type:        Class
;;
;; Description: Utilities and structures for the Synergy/DE Repository classes
;;
;; Date:        19th October 2007
;;
;; Author:      Steve Ives, Synergex Professional Services Group
;;              http://www.synergex.com
;;
;;*****************************************************************************
;;
;; Copyright (c) 2012, Synergex International, Inc.
;; All rights reserved.
;;
;; Redistribution and use in source and binary forms, with or without
;; modification, are permitted provided that the following conditions are met:
;;
;; * Redistributions of source code must retain the above copyright notice,
;;   this list of conditions and the following disclaimer.
;;
;; * Redistributions in binary form must reproduce the above copyright notice,
;;   this list of conditions and the following disclaimer in the documentation
;;   and/or other materials provided with the distribution.
;;
;; THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
;; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
;; IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
;; ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
;; LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
;; CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
;; SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
;; INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
;; CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
;; ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
;; POSSIBILITY OF SUCH DAMAGE.
;;
;;*****************************************************************************

import CodeGen.RepositoryAPI

namespace CodeGen.RepositoryAPI

    ;;; <summary>
    ;;; 
    ;;; </summary>
    public class RpsUtils

        ;;; <summary>
        ;;; Convert an alpha to lowercase
        ;;; </summary>
        ;;; <param name="InText"></param>
        ;;; <returns></returns>
        public static method LowerCase, a
            required in InText, a
            endparams
            record
                MemHandle, int
            endrecord
        proc
            MemHandle = %mem_proc(DM_ALLOC,%trim(InText))
            ^m(MemHandle) = InText
            locase ^m(MemHandle)
            mreturn ^m(MemHandle)
        endmethod

        ;;; <summary>
        ;;; Convert a string to lowercase
        ;;; </summary>
        ;;; <param name="InText"></param>
        ;;; <returns></returns>
        public static method LowerCase, String
            required in InText, String
            endparams
        proc
            mreturn InText.Trim().ToLower()
        endmethod

        ;;; <summary>
        ;;; Trims and converts an alpha to UPPERCASE
        ;;; </summary>
        ;;; <param name="inAlpha">Alpha to process</param>
        ;;; <returns>Resulting alpha value</returns>
        public static method UpperCase, a
            required in inAlpha, a
            endparams
            record
                MemHandle, int
            endrecord
        proc
            MemHandle = %mem_proc(DM_ALLOC,%trim(inAlpha))
            ^m(MemHandle) = inAlpha
            upcase ^m(MemHandle)
            mreturn ^m(MemHandle)
        endmethod

        ;;; <summary>
        ;;; Trims and converts a string to UPPERCASE
        ;;; </summary>
        ;;; <param name="inString">String to process</param>
        ;;; <returns>Resulting string value</returns>
        public static method UpperCase, String
            required in inString, String
            endparams
        proc
            mreturn inString.Trim().ToUpper()
        endmethod

        ;;; <summary>
        ;;; Convert an alpha to Mixed_Case
        ;;; </summary>
        ;;; <param name="InText"></param>
        ;;; <returns></returns>
        public static method MixedCase, a
            required in InText, a
            endparams
            record local_data
                Position, int
                Length, int
                MemHandle, int
            endrecord
            structure chr
                ,a1
            endstructure
        proc
            MemHandle = %mem_proc(DM_ALLOC,%trim(InText))
            ^m(MemHandle) = InText

            if (Length=%trimz(^m(MemHandle)))
            begin
                locase ^m(MemHandle)
                upcase ^m(chr(1:1),MemHandle)

                Position=1
                repeat
                begin
                    Position=%instr(Position,^m(MemHandle),"_")
                    if (Position) && (Position<Length) then
                        upcase ^m(chr(Position+=1:1),MemHandle)
                    else
                        exitloop
                end

                Position=1
                repeat
                begin
                    Position=%instr(Position,^m(MemHandle),".")
                    if (Position) && (Position<Length) then
                        upcase ^m(chr(Position+=1:1),MemHandle)
                    else
                        exitloop
                end

            end

            mreturn ^m(MemHandle)

        endmethod

        ;;; <summary>
        ;;; Determine if a string contains a numeric value
        ;;; </summary>
        ;;; <param name="a_string"></param>
        ;;; <returns></returns>
        public static method IsNumeric ,int
            required in a_string, a
            endparams
            stack record
                numeric     ,i4
                d18         ,d18
            endrecord
        proc

            try
            begin
                d18 = %atrim(a_string)
                numeric = 1
            end
            catch (ex)
                clear numeric
            endtry

            mreturn numeric

        endmethod

        ;;; <summary>
        ;;; Remove leading spaces from an alpha value
        ;;; </summary>
        ;;; <param name="inAlpha">Alpha value to process</param>
        ;;; <returns>Resulting alpha value</returns>
        public static method RemoveLeading, a
            required in inAlpha, a
            endparams
            stack record
                pos, int
            endrecord
        proc

            if (!inAlpha) then
                mreturn ""
            else
            begin
                clear pos
                repeat
                begin
                    if (inAlpha(pos+=1:1))
                        exitloop
                end
                mreturn inAlpha(pos,trim(inAlpha))
            end

        endmethod

        ;;; <summary>
        ;;; Get the mapped structure name for a structure
        ;;; </summary>
        ;;; <param name="aStructureName"></param>
        ;;; <param name="aUserText"></param>
        ;;; <param name="aLongDescription"></param>
        ;;; <returns></returns>
        public static method GetMappedStructure, String
            required in aStructureName, String
            required in aUserText, String
            required in aLongDescription, String
            endparams
            record
                mappedStructure, a30
                pos1, int
                pos2, int
            endrecord
        proc
            mappedStructure = ""
            if (pos1=%instr(1,aUserText.ToUpper(),"@MAP=")) then
            begin
                pos2=%instr(pos1,aUserText,";")
                if ((!pos2)||(pos2<pos1+6)) then
                    throw new RpsStructureException("Structure "+aStructureName+" has an invalid @MAP specification in user text.")
                else
                begin
                    ;TODO: Bug workaround for a Traditional Synergy issue????
                    ;mappedStructure = aUserText(pos1+5,pos2-1).ToUpper()
                    data tmpUserText, a80
                    tmpUserText = aUserText
                    upcase tmpUserText
                    mappedStructure = tmpUserText(pos1+5,pos2-1)
                end
            end
            else
            begin
                if (pos1=%instr(1,aLongDescription.ToUpper(),"@MAP="))
                begin
                    pos2=%instr(pos1,aLongDescription,";")
                    if ((!pos2)||(pos2<pos1+6)) then
                        throw new RpsStructureException("Structure "+aStructureName+" has an invalid @MAP specification in long description.")
                    else
                    begin
                        ;TODO: Bug workaround for a Traditional Synergy issue????
                        ;mappedStructure = aLongDescription(pos1+5,pos2-1).ToUpper()
                        data tmpLongDesc, a2048
                        tmpLongDesc = aLongDescription
                        upcase tmpLongDesc
                        mappedStructure = tmpLongDesc(pos1+5,pos2-1)
                    end
                end
            end
            mreturn %atrim(mappedStructure)
        endmethod

        ;;; <summary>
        ;;; Get the mapped field name for a field
        ;;; </summary>
        ;;; <param name="aStructureName"></param>
        ;;; <param name="aFieldName"></param>
        ;;; <param name="aUserText"></param>
        ;;; <param name="aLongDescription"></param>
        ;;; <returns></returns>
        public static method GetMappedField, String
            required in aStructureName, String
            required in aFieldName, String
            required in aUserText, String
            required in aLongDescription, String
            endparams
            record
                mappedField, String
                pos1, int
                pos2, int
            endrecord
        proc
            mappedField = ""
            if (pos1=instr(1,aUserText.ToUpper(),"@MAP=")) then
            begin
                pos2=instr(pos1,aUserText,";")
                if (pos2>=pos1+6) then
                    mappedField = RpsUtils.UpperCase(aUserText(pos1+5,pos2-1))
                else
                    throw new RpsFieldException("Field "+aStructureName+"."+aFieldName+" has an invalid @MAP specification in user text")
            end
            else
            begin
                if (pos1=instr(1,aLongDescription.ToUpper(),"@MAP="))
                begin
                    pos2=instr(pos1,aLongDescription,";")
                    if (pos2>=pos1+6) then
                        mappedField = RpsUtils.UpperCase(aLongDescription(pos1+5,pos2-1))
                    else
                        throw new RpsFieldException("Field "+aStructureName+"."+aFieldName+" has an invalid @MAP specification in long description")
                end
            end
            mreturn mappedField
        endmethod

        ;;; <summary>
        ;;; Get the mapping conversion function for a field
        ;;; </summary>
        ;;; <param name="aStructureName"></param>
        ;;; <param name="aFieldName"></param>
        ;;; <param name="aUserText"></param>
        ;;; <param name="aLongDescription"></param>
        ;;; <returns></returns>
        public static method GetMappingFunction, String
            required in aStructureName, String
            required in aFieldName, String
            required in aUserText, String
            required in aLongDescription, String
            endparams
            record
                functionName, String
                pos1, int
                pos2, int
            endrecord
        proc
            functionName = ""
            if (pos1=instr(1,aUserText,"@MAPF=")) then
            begin
                pos2=instr(pos1,UpperCase(aUserText),";")
                if (pos2>=pos1+7) then
                    functionName = aUserText(pos1+6,pos2-1)
                else
                    throw new RpsFieldException("Field "+aStructureName+"."+aFieldName+" has an invalid @MAPF=func; specification in user text")
            end
            else
            begin
                if (pos1=instr(1,aLongDescription,"@MAPF="))
                begin
                    pos2=instr(pos1,UpperCase(aLongDescription),";")
                    if (pos2>=pos1+7) then
                        functionName = aLongDescription(pos1+6,pos2-1)
                    else
                        throw new RpsFieldException("Field "+aStructureName+"."+aFieldName+" has an invalid @MAPF=func; specification in long description")
                end
            end
            mreturn functionName
        endmethod

        ;;; <summary>
        ;;; Get the mapping unconversion function for a field
        ;;; </summary>
        ;;; <param name="aStructureName"></param>
        ;;; <param name="aFieldName"></param>
        ;;; <param name="aUserText"></param>
        ;;; <param name="aLongDescription"></param>
        ;;; <returns></returns>
        public static method GetUnMappingFunction, String
            required in aStructureName, String
            required in aFieldName, String
            required in aUserText, String
            required in aLongDescription, String
            endparams
            record
                functionName, String
                pos1, int
                pos2, int
            endrecord
        proc
            functionName = ""
            if (pos1=instr(1,RpsUtils.UpperCase(aUserText),"@UNMAPF=")) then
            begin
                pos2=instr(pos1,aUserText,";")
                if (pos2>=pos1+9) then
                    functionName = aUserText(pos1+8,pos2-1)
                else
                    throw new RpsFieldException("Field "+aStructureName+"."+aFieldName+" has an invalid @UNMAPF=func; specification in user text")
            end
            else
            begin
                if (pos1=instr(1,RpsUtils.UpperCase(aLongDescription),"@UNMAPF="))
                begin
                    pos2=instr(pos1,aLongDescription,";")
                    if (pos2>=pos1+9) then
                        functionName = aLongDescription(pos1+8,pos2-1)
                    else
                        throw new RpsFieldException("Field "+aStructureName+"."+aFieldName+" has an invalid @UNMAPF=func; specification in long description")
                end
            end
            mreturn functionName
        endmethod
		
    endclass

    structure strIdentifier
        ,a30
    endstructure

.define DDINFO_STRUCTURE
    .include "RPSLIB:ddinfo.def"
.undefine DDINFO_STRUCTURE

    ;;; <summary>
    ;;; Color palette numbers
    ;;; </summary>
    public enum RpsColorPalette
        Palette1, 1
        Palette2, 2
        Palette3, 3
        Palette4, 4
        Palette5, 5
        Palette6, 6
        Palette7, 7
        Palette8, 8
        Palette9, 9
        Palette10, 10
        Palette11, 11
        Palette12, 12
        Palette13, 13
        Palette14, 14
        Palette15, 15
        Palette16, 16
    endenum

    ;;; <summary>
    ;;; Types of break field
    ;;; </summary>
    public enum RpsFieldBreak
        None, 0
        Change, 1
        Always, 2
        OnReturn, 3
    endenum

    ;;; <summary>
    ;;; Coerced field types
    ;;; </summary>
    public enum RpsFieldCoercedType
        ;;For decimal and integer fields / templates
        CtNone,          0
        CtByte,          1
        CtShort,         2
        CtInt,           3
        CtLong,          4
        CtSbyte,         5
        CtUshort,        6
        CtUint,          7
        CtUlong,         8
        CtBoolean,       9
        ;;For implied decimal fields / templates
        CtDouble,       10      ;;Actual RPS value is 1
        CtFloat,        11      ;;Actual RPS value is 2
        ;;For date and time fields / templates
        CtNullDateTime, 12      ;;Actual RPS value is 1
    endenum

    ;;; <summary>
    ;;; Field data types
    ;;; </summary>
    public enum RpsFieldDataType
        Alpha, 1
        Decimal, 2
        Integer, 3
        User, 4
        Boolean, 5
        Enum, 6
        Binary, 7
        StructField, 8
        AutoSequence, 9
        AutoTime, 10
    endenum

    ;;; <summary>
    ;;; Field default actions
    ;;; </summary>
    public enum RpsFieldDefaultAction
        None, 0
        Default, 1
        Copy, 2
        Increment, 3
        Decrement, 4
    endenum

    ;;; <summary>
    ;;; Field group status
    ;;; </summary>
    public enum RpsFieldGroup
        No, 0
        Yes, 1
        Overlay, 2
    endenum

    ;;; <summary>
    ;;; Are field negative values allowed?
    ;;; </summary>
    public enum RpsFieldNegatives
        None ,0
        Allowed ,1
        Only, 2
        OrZero, 3
    endenum

    ;;; <summary>
    ;;; Field selection type
    ;;; </summary>
    public enum RpsFieldSelectionType
        Window, 1
        List, 2
    endenum

    ;;; <summary>
    ;;; Field timeout type
    ;;; </summary>
    public enum RpsFieldTimeout
        None, 0
        Time, 1
        Immediate, 2
        Global, 3
        Forever, 4
    endenum

    ;;; <summary>
    ;;; Field display format type
    ;;; </summary>
    public enum RpsFormatType
        Alpha, 1
        Numeric, 2
    endenum

    ;;; <summary>
    ;;; Key duplicate types
    ;;; </summary>
    public enum RpsKeyDuplicates
        NoDuplicates, 0
        Duplicates, 1
    endenum

    ;;; <summary>
    ;;; Key duplicate insert positions
    ;;; </summary>
    public enum RpsKeyInsertDups
        AtFront, 0
        AtEnd, 1
    endenum

    ;;; <summary>
    ;;; Null key type
    ;;; </summary>
    public enum RpsKeyNullType
        None, 0
        Replicating, 1
        NonReplicating, 2
        Short, 3
    endenum

    ;;; <summary>
    ;;; Key ordering sequence
    ;;; </summary>
    public enum RpsKeyOrder
        Ascending, 0
        Descending, 1
    endenum

    ;;; <summary>
    ;;; Key segment data type
    ;;; </summary>
    public enum RpsKeySegmentDataType
        Unspecified, 0
        Alpha, 1
        NoCaseAlpha, 2
        Decimal, 3
        SignedInteger, 4
        UnsignedInteger, 5
        AutoSequence, 6
        AutoTimestampUpdated, 7
        AutoTimestampCreated, 8
    endenum

    ;;; <summary>
    ;;; Key segment order
    ;;; </summary>
    public enum RpsKeySegmentOrder
        Unspecified, 0
        Ascending, 1
        Descending, 2
    endenum

    ;;; <summary>
    ;;; Key type
    ;;; </summary>
    public enum RpsKeyType
        Foreign, 0
        Access, 1
    endenum

    ;;; <summary>
    ;;; Key segment type
    ;;; </summary>
    public enum RpsKeySegmentType
        Field, 1
        Literal, 2
        External, 3
        RecordNumber, 4
    endenum

    ;;; <summary>
    ;;; On-screen positioning mode
    ;;; </summary>
    public enum RpsPositionMode
        None, 0
        Absolute, 1
        Relative, 2
    endenum

    ;;; <summary>
    ;;; Field subclass
    ;;; </summary>
    public enum RpsFieldSubclass
        None, 0
        DateYYMMDD, 1
        DateYYYYMMDD, 2
        DateYYJJJ, 3
        DateYYYYJJJ, 4
        DateYYPP, 5
        DateYYYYPP, 6
        TimeHHMMSS, 7
        TimeHHMM, 8
        Binary, 9
        UserAlpha, 10
        UserNumeric, 11
        UserDate, 12
    endenum

    ;;; <summary>
    ;;; Field view as type
    ;;; </summary>
    public enum RpsFieldViewAs
        Field, 0
        RadioButtons, 2
        CheckBox ,3
    endenum

    ;;; <summary>
    ;;; File page size
    ;;; </summary>
    public enum RpsFilePageSize
        PageSize1024, 0
        PageSize512, 1
        PageSize2048, 2
        PageSize4096, 3
        PageSize8192, 4
        PageSize16384, 5
        PageSize32768, 6
    endenum

    ;;; <summary>
    ;;; File addressing mode
    ;;; </summary>
    public enum RpsFileAddressing
        Addressing32Bit, 0
        Addressing40Bit, 1
    endenum

    ;;; <summary>
    ;;; Global display format type
    ;;; </summary>
    public enum RpsGlobalFormatType
        Format, 4
        DateFormat, 5
        TimeFormat, 6
    endenum

    ;;Field justification
    public enum RpsJustification
        Left, 0
        Right, 1
        Center, 2
    endenum

    ;;; <summary>
    ;;; Record type
    ;;; </summary>
    public enum RpsRecordType
        FixedLength, 0
        VariableLength, 1
        MultipleFixedLength, 2
    endenum

    ;;; <summary>
    ;;; Tag comparison mode
    ;;; </summary>
    public enum RpsTagComparison
        None, 0
        CompareAnd, 1
        CompareOr, 2
    endenum

    ;;; <summary>
    ;;; Tag comparison operator
    ;;; </summary>
    public enum RpsTagOperator
        OpEQ, 1
        OpNE, 2
        OpLE, 3
        OpLT, 4
        OpGE, 5
        OpGT, 6
    endenum

    ;;; <summary>
    ;;; Tag type
    ;;; </summary>
    public enum RpsTagType
        None, 0
        FieldAndValue, 1
        RecordSize, 2
    endenum

    ;;; <summary>
    ;;; Repository load mode
    ;;; Used to determine if a new object should automatically load
    ;;; it's content.  For example, if an RpsStructureCollection is passed Load
    ;;; then it will load all repository structures into the collection. If passed
    ;;; NoLoad then it will not initially load any structures.
    ;;; </summary>
    public enum RpsLoadMode
        NoLoad  ,0
        Load    ,1
    endenum

endnamespace

