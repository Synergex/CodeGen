;; *****************************************************************************
;; 
;;  Title:       ExpressionEvaluatorFieldLoop.dbl
;; 
;;  Type:        Partial class
;; 
;;  Description: Evaluates field loop expression nodes
;; 
;;  Date:        30th August 2014
;; 
;;  Author:      Steve Ives, Synergex Professional Services Group
;;               http://www.synergex.com
;; 
;; *****************************************************************************
;; 
;;  Copyright (c) 2014, Synergex International, Inc.
;;  All rights reserved.
;; 
;;  Redistribution and use in source and binary forms, with or without
;;  modification, are permitted provided that the following conditions are met:
;; 
;;  * Redistributions of source code must retain the above copyright notice,
;;    this list of conditions and the following disclaimer.
;; 
;;  * Redistributions in binary form must reproduce the above copyright notice,
;;    this list of conditions and the following disclaimer in the documentation
;;    and/or other materials provided with the distribution.
;; 
;;  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
;;  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
;;  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
;;  ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
;;  LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
;;  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
;;  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
;;  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
;;  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
;;  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
;;  POSSIBILITY OF SUCH DAMAGE.
;; 
;; *****************************************************************************

import System
import System.Collections.Generic
import System.Linq
import System.Text
import System.Threading.Tasks
import CodeGen.RepositoryAPI
import System.IO

.array 0

namespace CodeGen.Engine

    public partial class ExpressionEvaluator

        fieldLoopExpressionEvaluators, @Dictionary<string, Func<Token, FileNode, IEnumerable<LoopNode>, boolean>>

        private method registerFieldLoopExpressions, void
            endparams
        proc

            fieldLoopExpressionEvaluators = new Dictionary<string, Func<Token, FileNode, IEnumerable<LoopNode>, boolean>>()

            fieldLoopExpressionEvaluators.Add("ALLOW_LIST", evaluateFieldAllowList)
            fieldLoopExpressionEvaluators.Add("ALPHA", evaluateFieldAlpha)
            fieldLoopExpressionEvaluators.Add("ALTERNATE_NAME", evaluateFieldAlternateName)
            fieldLoopExpressionEvaluators.Add("ARRAY", evaluateFieldArray)
            fieldLoopExpressionEvaluators.Add("ARRAY_FIRST", evaluateFieldArrayFirst)
            fieldLoopExpressionEvaluators.Add("ARRAY1", evaluateFieldArray1)
            fieldLoopExpressionEvaluators.Add("ARRAY1_FIRST", evaluateFieldArray1First)
            fieldLoopExpressionEvaluators.Add("ARRAY2", evaluateFieldArray2)
            fieldLoopExpressionEvaluators.Add("ARRAY2_FIRST", evaluateFieldArray2First)
            fieldLoopExpressionEvaluators.Add("ARRAY3", evaluateFieldArray3)
            fieldLoopExpressionEvaluators.Add("ARRAY3_FIRST", evaluateFieldArray3First)
            fieldLoopExpressionEvaluators.Add("ARRAY4", evaluateFieldArray4)
            fieldLoopExpressionEvaluators.Add("ARRAY4_FIRST", evaluateFieldArray4First)
            fieldLoopExpressionEvaluators.Add("ARRIVE", evaluateFieldArrive)
            fieldLoopExpressionEvaluators.Add("AUTO_SEQUENCE", evaluateFieldAutoSequence)
            fieldLoopExpressionEvaluators.Add("AUTO_TIMESTAMP", evaluateFieldAutoTime)
            fieldLoopExpressionEvaluators.Add("AUTO_TIMESTAMP_CREATED", evaluateFieldAutoTimeCreated)
            fieldLoopExpressionEvaluators.Add("AUTO_TIMESTAMP_UPDATED", evaluateFieldAutoTimeUpdated)
            fieldLoopExpressionEvaluators.Add("BINARY", evaluateFieldBinary)
            fieldLoopExpressionEvaluators.Add("BOLD", evaluateFieldBold)
            fieldLoopExpressionEvaluators.Add("BOOLEAN", evaluateFieldBoolean)
            fieldLoopExpressionEvaluators.Add("BREAK", evaluateFieldBreak)
            fieldLoopExpressionEvaluators.Add("BREAK_ALWAYS", evaluateFieldBreakAlways)
            fieldLoopExpressionEvaluators.Add("BREAK_CHANGE", evaluateFieldBreakChange)
            fieldLoopExpressionEvaluators.Add("BREAK_RETURN", evaluateFieldBreakReturn)
            fieldLoopExpressionEvaluators.Add("BZERO", evaluateFieldBzero)
            fieldLoopExpressionEvaluators.Add("CHANGE", evaluateFieldChange)
            fieldLoopExpressionEvaluators.Add("CHECKBOX", evaluateFieldCheckBox)
            fieldLoopExpressionEvaluators.Add("COERCE_BOOLEAN", evaluateFieldCoerceBoolean)
            fieldLoopExpressionEvaluators.Add("COMBOBOX", evaluateFieldComboBox)
            fieldLoopExpressionEvaluators.Add("CUSTOM_DBL_TYPE", evaluateFieldCustomDblType)
            fieldLoopExpressionEvaluators.Add("CUSTOM_SQL_TYPE", evaluateFieldCustomSqlType)
            fieldLoopExpressionEvaluators.Add("CUSTOM_CONVERT_FUNCTION", evaluateFieldCustomConvertFunction)
            fieldLoopExpressionEvaluators.Add("CUSTOM_STRING_FUNCTION", evaluateFieldCustomStringFunction)
            fieldLoopExpressionEvaluators.Add("DATE", evaluateFieldDate)
            fieldLoopExpressionEvaluators.Add("DATE_JULIAN", evaluateFieldDateJulian)
            fieldLoopExpressionEvaluators.Add("DATE_NOT_JULIAN", evaluateFieldDateNotJulian)
            fieldLoopExpressionEvaluators.Add("DATE_NOT_NULLABLE", evaluateFieldDateNotNullable)
            fieldLoopExpressionEvaluators.Add("DATE_NOT_PERIOD", evaluateFieldDateNotPeriod)
            fieldLoopExpressionEvaluators.Add("DATE_NOT_YMD", evaluateFieldDateNotYMD)
            fieldLoopExpressionEvaluators.Add("DATE_NOT_YYYYMMDD", evaluateFieldDateNotYYYYMMDD)
            fieldLoopExpressionEvaluators.Add("DATE_NULLABLE", evaluateFieldDateNullable)
            fieldLoopExpressionEvaluators.Add("DATE_PERIOD", evaluateFieldDatePeriod)
            fieldLoopExpressionEvaluators.Add("DATE_YMD", evaluateFieldDateYMD)
            fieldLoopExpressionEvaluators.Add("DATE_YYJJJ", evaluateFieldDayeYYJJJ)
            fieldLoopExpressionEvaluators.Add("DATE_YYMMDD", evaluateFieldDateYYMMDD)
            fieldLoopExpressionEvaluators.Add("DATE_YYPP", evaluateFieldDateYYPP)
            fieldLoopExpressionEvaluators.Add("DATE_YYYYJJJ", evaluateFieldDateYYYYJJJ)
            fieldLoopExpressionEvaluators.Add("DATE_YYYYMMDD", evaluateFieldDateYYYYMMDD)
            fieldLoopExpressionEvaluators.Add("DATE_YYYYPP", evaluateFieldYYYYPP)
            fieldLoopExpressionEvaluators.Add("DATEORTIME", evaluateFieldDateOrTime)
            fieldLoopExpressionEvaluators.Add("DATETODAY", evaluateFieldDateToday)
            fieldLoopExpressionEvaluators.Add("DECIMAL", evaluateFieldDecimal)
            fieldLoopExpressionEvaluators.Add("DEFAULT", evaluateFieldDefault)
            fieldLoopExpressionEvaluators.Add("DESCRIPTION", evaluateFieldDescription)
            fieldLoopExpressionEvaluators.Add("DISABLED", evaluateFieldDisabled)
            fieldLoopExpressionEvaluators.Add("DISPLAY", evaluateFieldDisplay)
            fieldLoopExpressionEvaluators.Add("DISPLAY_LENGTH", evaluateFieldDisplayLength)
            fieldLoopExpressionEvaluators.Add("DRILL", evaluateFieldDrill)
            fieldLoopExpressionEvaluators.Add("ECHO", evaluateFieldEcho)
            fieldLoopExpressionEvaluators.Add("EDITFORMAT", evaluateFieldEditFormat)
            fieldLoopExpressionEvaluators.Add("ENABLED", evaluateFieldEnabled)
            fieldLoopExpressionEvaluators.Add("ENUM", evaluateFieldEnum)
            fieldLoopExpressionEvaluators.Add("ENUMERATED", evaluateFieldEnumerated)
            fieldLoopExpressionEvaluators.Add("EXPLICIT_GROUP", evaluateFieldExplicitGroup)
            fieldLoopExpressionEvaluators.Add("EXPLICIT_GROUP_NO_EXPAND", evaluateFieldExplicitGroupNoExpand)
            fieldLoopExpressionEvaluators.Add("FIELD_POSITION", evaluateFieldPosition)
            fieldLoopExpressionEvaluators.Add("FIRST_UNIQUE_KEY_SEGMENT", evaluateFirstUniqueKeySegment)
            fieldLoopExpressionEvaluators.Add("FORMAT", evaluateFieldFormat)
            fieldLoopExpressionEvaluators.Add("GROUP", evaluateFieldGroup)
            fieldLoopExpressionEvaluators.Add("GROUP_OVERLAY", evaluateFieldGroupOverlay)
            fieldLoopExpressionEvaluators.Add("GROUP_MEMBER_PREFIX", evaluateFieldGroupMemberPrefix)
            fieldLoopExpressionEvaluators.Add("GROUP_MEMBER_PREFIX_COMPILER", evaluateFieldGroupMemberPrefixCompiler)
            fieldLoopExpressionEvaluators.Add("HEADING", evaluateFieldHeading)
            fieldLoopExpressionEvaluators.Add("HELPID", evaluateFieldHelpID)
            fieldLoopExpressionEvaluators.Add("HYPERLINK", evaluateFieldHyperlink)
            fieldLoopExpressionEvaluators.Add("I1", evaluateFieldI1)
            fieldLoopExpressionEvaluators.Add("I124", evaluateFieldI123)
            fieldLoopExpressionEvaluators.Add("I2", evaluateFieldI2)
            fieldLoopExpressionEvaluators.Add("I4", evaluateFieldI4)
            fieldLoopExpressionEvaluators.Add("I8", evaluateFieldI8)
            fieldLoopExpressionEvaluators.Add("IMPLICIT_GROUP", evaluateFieldImplicitGroup)
            fieldLoopExpressionEvaluators.Add("IMPLICIT_GROUP_NO_EXPAND", evaluateFieldImplicitGroupNoExpand)
            fieldLoopExpressionEvaluators.Add("INFOLINE", evaluateFieldInfoLine)
            fieldLoopExpressionEvaluators.Add("INPUT_CENTER", evaluateFieldInputCenter)
            fieldLoopExpressionEvaluators.Add("INPUT_LEFT", evaluateFieldInputLeft)
            fieldLoopExpressionEvaluators.Add("INPUT_RIGHT", evaluateFieldInputRight)
            fieldLoopExpressionEvaluators.Add("INTEGER", evaluateFieldInteger)
            fieldLoopExpressionEvaluators.Add("KEYSEGMENT", evaluateFieldKeySegment)
            fieldLoopExpressionEvaluators.Add("LANGUAGE", evaluateFieldLanguage)
            fieldLoopExpressionEvaluators.Add("LEAVE", evaluateFieldLeave)
            fieldLoopExpressionEvaluators.Add("LENGTH_OVER_8", evaluateFieldLengthOver8)
            fieldLoopExpressionEvaluators.Add("LONGDESC", evaluateFieldLongDescription)
            fieldLoopExpressionEvaluators.Add("MAPPED", evaluateFieldMapped)
            fieldLoopExpressionEvaluators.Add("MAPPEDSTR", evaluateFieldMappedStr)
            fieldLoopExpressionEvaluators.Add("NAME_LINK",evaluateFieldNameLink)
            fieldLoopExpressionEvaluators.Add("NEGATIVE_ALLOWED", evaluateFieldNegativeAllowed)
            fieldLoopExpressionEvaluators.Add("NEGATIVE_ORZERO", evaluateFieldNegativeOrZero)
            fieldLoopExpressionEvaluators.Add("NEGATIVE_REQUIRED", evaluateFieldNegativeRequired)
            fieldLoopExpressionEvaluators.Add("NOALLOW_LIST", evaluateFieldNoAllowList)
            fieldLoopExpressionEvaluators.Add("NOALTERNATE_NAME", evaluateFieldNoAlternateName)
            fieldLoopExpressionEvaluators.Add("NOARRIVE", evaluateFieldNoArrive)
            fieldLoopExpressionEvaluators.Add("NOBREAK", evaluateFieldNoBreak)
            fieldLoopExpressionEvaluators.Add("NOCHANGE", evaluateFieldNoChange)
            fieldLoopExpressionEvaluators.Add("NOCHECKBOX", evaluateFieldNoCheckBox)
            fieldLoopExpressionEvaluators.Add("NODEFAULT", evaluateFieldNoDefault)
            fieldLoopExpressionEvaluators.Add("NODESCRIPTION", evaluateFieldNoDescription)
            fieldLoopExpressionEvaluators.Add("NODISPLAY", evaluateFieldNoDisplay)
            fieldLoopExpressionEvaluators.Add("NODISPLAY_LENGTH", evaluateFieldNoDisplayLength)
            fieldLoopExpressionEvaluators.Add("NODRILL", evaluateFieldNoDrill)
            fieldLoopExpressionEvaluators.Add("NOECHO", evaluateFieldNoEcho)
            fieldLoopExpressionEvaluators.Add("NOEDITFORMAT", evaluateFieldNoEditFormat)
            fieldLoopExpressionEvaluators.Add("NOFORMAT", evaluateFieldNoFormat)
            fieldLoopExpressionEvaluators.Add("NOHELPID", evaluateFieldNoHelpID)
            fieldLoopExpressionEvaluators.Add("NOHYPERLINK", evaluateFieldNoHyperlink)
            fieldLoopExpressionEvaluators.Add("NOINFOLINE", evaluateFieldNoInfoLine)
            fieldLoopExpressionEvaluators.Add("NOLANGUAGE", evaluateFieldNoLanguage)
            fieldLoopExpressionEvaluators.Add("NOLEAVE", evaluateFieldNoLeave)
            fieldLoopExpressionEvaluators.Add("NOLONGDESC", evaluateFieldNoLongDescription)
            fieldLoopExpressionEvaluators.Add("NONEGATIVE", evaluateFieldNoNegative)
            fieldLoopExpressionEvaluators.Add("NOPAINTCHAR", evaluateFieldNoPaintChar)
            fieldLoopExpressionEvaluators.Add("NOPRECISION", evaluateFieldNoPrecision)
            fieldLoopExpressionEvaluators.Add("NOPROMPT", evaluateFieldNoPrompt)
            fieldLoopExpressionEvaluators.Add("NORANGE", evaluateFieldNoRange)
            fieldLoopExpressionEvaluators.Add("NOREPORT", evaluateFieldNoReport)
            fieldLoopExpressionEvaluators.Add("NOSELECTIONS", evaluateFieldNoSelections)
            fieldLoopExpressionEvaluators.Add("NOSELWND", evaluateFieldNoSelWnd)
            fieldLoopExpressionEvaluators.Add("NOTALPHA", evaluateFieldNotAlpha)
            fieldLoopExpressionEvaluators.Add("NOTARRAY", evaluateFieldNotArray)
            fieldLoopExpressionEvaluators.Add("NOTBINARY", evaluateFieldNotBinary)
            fieldLoopExpressionEvaluators.Add("NOTBOOLEAN", evaluateFieldNotBoolean)
            fieldLoopExpressionEvaluators.Add("NOTBZERO", evaluateFieldNotBzero)
            fieldLoopExpressionEvaluators.Add("NOTDATE", evaluateFieldNotDate)
            fieldLoopExpressionEvaluators.Add("NOTDATEORTIME", evaluateFieldNotDateOrTime)
            fieldLoopExpressionEvaluators.Add("NOTDATETODAY", evaluateFieldNotDateToday)
            fieldLoopExpressionEvaluators.Add("NOTDECIMAL", evaluateFieldNotDecimal)
            fieldLoopExpressionEvaluators.Add("NOTENUM", evaluateFieldNotEnum)
            fieldLoopExpressionEvaluators.Add("NOTENUMERATED", evaluateFieldNotEnumerated)
            fieldLoopExpressionEvaluators.Add("NOTIMEOUT", evaluateFieldNoTimeout)
            fieldLoopExpressionEvaluators.Add("NOTINTEGER", evaluateFieldNotInteger)
            fieldLoopExpressionEvaluators.Add("NOTNUMERIC", evaluateFieldNotNumeric)
            fieldLoopExpressionEvaluators.Add("NOTOOLKIT", evaluateFieldNoToolkit)
            fieldLoopExpressionEvaluators.Add("NOTOVERLAY", evaluateFieldNotOverlay)
            fieldLoopExpressionEvaluators.Add("NOTPKSEGMENT", evaluateFieldNotPkSegment)
            fieldLoopExpressionEvaluators.Add("NOTKEYSEGMENT", evaluateFieldNotKeySegment)
            fieldLoopExpressionEvaluators.Add("NOTRADIOBUTTONS", evaluateFieldNotRadioButtons)
            fieldLoopExpressionEvaluators.Add("NOTSTRUCTFIELD", evaluateFieldNotStructField)
            fieldLoopExpressionEvaluators.Add("NOTTIME", evaluateFieldNotTime)
            fieldLoopExpressionEvaluators.Add("NOTUPPERCASE", evaluateFieldNotUppercase)
            fieldLoopExpressionEvaluators.Add("NOTUSER", evaluateFieldNotUser)
            fieldLoopExpressionEvaluators.Add("NOTUSERTIMESTAMP", evaluateFieldNotUserTimeStamp)
            fieldLoopExpressionEvaluators.Add("NOUSERTEXT", evaluateFieldNoUserText)
            fieldLoopExpressionEvaluators.Add("NOVIEW_LENGTH", evaluateFieldNoViewLength)
            fieldLoopExpressionEvaluators.Add("NOWEB", evaluateFieldNoWeb)
            fieldLoopExpressionEvaluators.Add("NUMERIC", evaluateFieldNumeric)
            fieldLoopExpressionEvaluators.Add("OCNATIVE", evaluateFieldOcNative)
            fieldLoopExpressionEvaluators.Add("OCOBJECT", evaluateFieldOcObject)
            fieldLoopExpressionEvaluators.Add("ONLY_PKSEGMENT", evaluateFieldOnlyPkSegment)
            fieldLoopExpressionEvaluators.Add("OPTIONAL", evaluateFieldOptional)
            fieldLoopExpressionEvaluators.Add("OVERLAY", evaluateFieldOverlay)
            fieldLoopExpressionEvaluators.Add("OVERLAY_OFFSET", evaluateFieldOverlayOffset)
            fieldLoopExpressionEvaluators.Add("PAINTCHAR", evaluateFieldPaintChar)
            fieldLoopExpressionEvaluators.Add("PAINTFIELD", evaluateFieldPaintField)
            fieldLoopExpressionEvaluators.Add("PII_SCRUB", evaluateFieldPiiScrub)
            fieldLoopExpressionEvaluators.Add("PKSEGMENT", evaluateFieldPkSegment)
            fieldLoopExpressionEvaluators.Add("PRECISION", evaluateFieldPrecision)
            fieldLoopExpressionEvaluators.Add("PROMPT", evaluateFieldPrompt)
            fieldLoopExpressionEvaluators.Add("PROMPT_POSITION", evaluateFieldPromptPosition)
            fieldLoopExpressionEvaluators.Add("RADIOBUTTONS", evaluateFieldRadioButtons)
            fieldLoopExpressionEvaluators.Add("RANGE", evaluateFieldRange)
            fieldLoopExpressionEvaluators.Add("READONLY", evaluateFieldReadOnly)
            fieldLoopExpressionEvaluators.Add("READWRITE", evaluateFieldReadWrite)
            fieldLoopExpressionEvaluators.Add("RELATION", evaluateFieldRelation)
            fieldLoopExpressionEvaluators.Add("REPORT", evaluateFieldReport)
            fieldLoopExpressionEvaluators.Add("REPORT_CENTER", evaluateFieldReportCenter)
            fieldLoopExpressionEvaluators.Add("REPORT_LEFT", evaluateFieldReportLeft)
            fieldLoopExpressionEvaluators.Add("REPORT_RIGHT", evaluateFieldReportRight)
            fieldLoopExpressionEvaluators.Add("REQUIRED", evaluateFieldRequired)
            fieldLoopExpressionEvaluators.Add("REVERSE", evaluateFieldReverse)
            fieldLoopExpressionEvaluators.Add("SELECTIONS", evaluateFieldSelections)
            fieldLoopExpressionEvaluators.Add("SELWND", evaluateFieldSelWnd)
            fieldLoopExpressionEvaluators.Add("STRUCTFIELD", evaluateFieldStructField)
            fieldLoopExpressionEvaluators.Add("TEXTBOX", evaluateFieldTextBox)
            fieldLoopExpressionEvaluators.Add("TIME", evaluateFieldTime)
            fieldLoopExpressionEvaluators.Add("TIME_HHMM", evaluateFieldTimeHHMM)
            fieldLoopExpressionEvaluators.Add("TIME_HHMMSS", evaluateFieldTimeHHMMSS)
            fieldLoopExpressionEvaluators.Add("TIMENOW", evaluateFieldTimeNow)
            fieldLoopExpressionEvaluators.Add("TIMEOUT", evaluateFieldTimeout)
            fieldLoopExpressionEvaluators.Add("TOOLKIT", evaluateFieldToolkit)
            fieldLoopExpressionEvaluators.Add("UNDERLINE", evaluateFieldUnderline)
            fieldLoopExpressionEvaluators.Add("UPPERCASE", evaluateFieldUppercase)
            fieldLoopExpressionEvaluators.Add("USED_IN_RELATION", evaluateFieldUsedInRelation)
            fieldLoopExpressionEvaluators.Add("USER", evaluateFieldUser)
            fieldLoopExpressionEvaluators.Add("USER_TYPE", evaluateFieldUserType)
            fieldLoopExpressionEvaluators.Add("USERTEXT", evaluateFieldUserText)
            fieldLoopExpressionEvaluators.Add("USERTIMESTAMP", evaluateFieldUserTimeStamp)
            fieldLoopExpressionEvaluators.Add("VIEW_LENGTH", evaluateFieldViewLength)
            fieldLoopExpressionEvaluators.Add("WEB", evaluateFieldWeb)

        endmethod

        ;; -------------------------------------------------------------------------------------------------------------------------------
        ;;; <summary>
        ;;; 
        ;;; </summary>
        ;;; <param name="tkn"></param>
        ;;; <param name="template"></param>
        ;;; <param name="loops"></param>
        ;;; <param name="specific"></param>
        ;;; <returns></returns>
        public static method EvaluateFieldLoopExpression, boolean
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            specific, @Func<RpsStructure, RpsField, int, boolean> 
            endparams
        proc

            lambda isFieldOrSegmentLoop(node) (node .is. FieldLoopNode || node .is. SegmentLoopNode)
            data loop, @LoopNode, loops.Last(isFieldOrSegmentLoop)

            data str, @RpsStructure, ^null
            data field, @RpsField, ^null
            data index, int

            ;;Field loop tokens are valid in several places, so we need to figure out what context we're in

            if (loop .is. FieldLoopNode) then
            begin
                ;;We're in a field loop
                str = template.Context.GetCurrentStructure()
                field = ((@FieldLoopNode)loop).GetCurrentField()
                index = ((@FieldLoopNode)loop).CurrentIndex
            end
            else if (loop .is. RelationSegmentLoopNode) then
            begin
                ;;We're in a relation key segment loop

                ;;First get a handle on the outer relation loop that must be above us in the tree
                lambda isRelationLoop(node) (node .is. RelationLoopNode)
                data relationLoop, @RelationLoopNode, ^as(loops.First(isRelationLoop), @RelationLoopNode)

                ;;Determine which structure we're dealing with, based on the TYPE of relation segment loop (FROM_KEY_SEGMENT_LOOP or TO_KEY_SEGMENT_LOOP)
                str = loop.OpenToken.Value.StartsWith("FROM_KEY_SEGMENT_LOOP") ? template.Context.GetCurrentStructure() : relationLoop.ToStructure

                ;;Now get a handle on the full definition of the key segment we're dealing with
                data segment, @RpsKeySegment, ((@RelationSegmentLoopNode)loop).CurrentSegment

                ;;And get a handle on the field associated with the current segment
                ;;Could return null if it a "literal" segment
                lambda isSegmentField(fld) (fld.OriginalName == segment.Field)
                field = str.Fields.FirstOrDefault(isSegmentField)

                index = ((@RelationSegmentLoopNode)loop).CurrentIndex
            end
            else if (loop .is. SegmentLoopNode)
            begin
                ;;We're in a regular key segment loop
                ;;Get handles on the current structure, field, and index
                str = template.Context.GetCurrentStructure()
                field = ((@SegmentLoopNode)loop).CurrentField
                index = ((@SegmentLoopNode)loop).CurrentIndex
            end

            mreturn specific(str, field, index)

        endmethod

        ;; -------------------------------------------------------------------------------------------------------------------------------

        private static method evaluateFieldAllowList, boolean
            tkn, @Token
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            lambda doEvaluate(str, field, index) (field.AllowList.Count > 0)
            mreturn EvaluateFieldLoopExpression(tkn, template, loops, doEvaluate)
        endmethod

        private static method evaluateFieldAlpha, boolean
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            lambda doEvaluate(str, field, index) (field.DataType == RpsFieldDataType.Alpha)
            mreturn EvaluateFieldLoopExpression(tkn, template, loops, doEvaluate)
        endmethod

        private static method evaluateFieldAlternateName, boolean
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            lambda doEvaluate(str, field, index) (field.AlternateName != field.OriginalName)
            mreturn EvaluateFieldLoopExpression(tkn, template, loops, doEvaluate)
        endmethod

        private static method evaluateFieldArray, boolean
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            lambda doEvaluate(str, field, index) field.WasArrayElement
            mreturn EvaluateFieldLoopExpression(tkn, template, loops, doEvaluate)
        endmethod

        private static method evaluateFieldArrayFirst, boolean
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            mreturn evaluateFieldArray1First(tkn,template,loops) || evaluateFieldArray2First(tkn,template,loops) || evaluateFieldArray3First(tkn,template,loops) || evaluateFieldArray4First(tkn,template,loops)
        endmethod

        private static method evaluateFieldArray1, boolean
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            lambda doEvaluate(str, field, index) (((field.WasArrayElement && (field.OriginalElement[1] == 0)) && (field.OriginalElement[2] == 0)) && (field.OriginalElement[3] == 0))
            mreturn EvaluateFieldLoopExpression(tkn, template, loops, doEvaluate)
        endmethod

        private static method evaluateFieldArray1First, boolean
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            lambda doEvaluate(str, field, index) (field.WasArrayElement && (field.OriginalElement[0] == 1) && (field.OriginalElement[1] == 0) && (field.OriginalElement[2] == 0) && (field.OriginalElement[3] == 0))
            mreturn EvaluateFieldLoopExpression(tkn, template, loops, doEvaluate)
        endmethod

        private static method evaluateFieldArray2, boolean
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            lambda doEvaluate(str, field, index) (((field.WasArrayElement && (field.OriginalElement[1] != 0)) && (field.OriginalElement[2] == 0)) && (field.OriginalElement[3] == 0))
            mreturn EvaluateFieldLoopExpression(tkn, template, loops, doEvaluate)
        endmethod

        private static method evaluateFieldArray2First, boolean
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            lambda doEvaluate(str, field, index) (field.WasArrayElement && (field.OriginalElement[0] == 1) && (field.OriginalElement[1] == 1) && (field.OriginalElement[2] == 0) && (field.OriginalElement[3] == 0))
            mreturn EvaluateFieldLoopExpression(tkn, template, loops, doEvaluate)
        endmethod

        private static method evaluateFieldArray3, boolean
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            lambda doEvaluate(str, field, index) (((field.WasArrayElement && (field.OriginalElement[1] != 0)) && (field.OriginalElement[2] != 0)) && (field.OriginalElement[3] == 0))
            mreturn EvaluateFieldLoopExpression(tkn, template, loops, doEvaluate)
        endmethod

        private static method evaluateFieldArray3First, boolean
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            lambda doEvaluate(str, field, index) (field.WasArrayElement && (field.OriginalElement[0] == 1) && (field.OriginalElement[1] == 1) && (field.OriginalElement[2] == 1) && (field.OriginalElement[3] == 0))
            mreturn EvaluateFieldLoopExpression(tkn, template, loops, doEvaluate)
        endmethod

        private static method evaluateFieldArray4, boolean
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            lambda doEvaluate(str, field, index) (((field.WasArrayElement && (field.OriginalElement[1] != 0)) && (field.OriginalElement[2] != 0)) && (field.OriginalElement[3] != 0))
            mreturn EvaluateFieldLoopExpression(tkn, template, loops, doEvaluate)
        endmethod

        private static method evaluateFieldArray4First, boolean
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            lambda doEvaluate(str, field, index) (field.WasArrayElement && (field.OriginalElement[0] == 1) && (field.OriginalElement[1] == 1) && (field.OriginalElement[2] == 1) && (field.OriginalElement[3] == 1))
            mreturn EvaluateFieldLoopExpression(tkn, template, loops, doEvaluate)
        endmethod

        private static method evaluateFieldArrive, boolean
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            lambda doEvaluate(str, field, index) (!String.IsNullOrWhiteSpace(field.ArriveMethod))
            mreturn EvaluateFieldLoopExpression(tkn, template, loops, doEvaluate)
        endmethod

        private static method evaluateFieldAutoSequence, boolean
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            lambda doEvaluate(str, field, index) (field.DataType == RpsFieldDataType.AutoSequence)
            mreturn EvaluateFieldLoopExpression(tkn, template, loops, doEvaluate)
        endmethod

        private static method evaluateFieldAutoTime, boolean
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            lambda doEvaluate(str, field, index) (field.DataType == RpsFieldDataType.AutoTime)
            mreturn EvaluateFieldLoopExpression(tkn, template, loops, doEvaluate)
        endmethod

        private static method evaluateFieldAutoTimeCreated, boolean
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            lambda doEvaluate(str, field, index)
            begin
                data result, boolean, false
                if (field.DataType == RpsFieldDataType.AutoTime)
                begin
                    data k, @RpsKey
                    foreach k in str.Keys
                    begin
                        data s, @RpsKeySegment
                        foreach s in k.Segments
                        begin
                            if (result = ((s.Field == field.OriginalName) && (s.DataType == RpsKeySegmentDataType.AutoTimestampCreated)))
                                exitloop
                        end
                        if (result)
                            exitloop
                    end
                end
                mreturn result
            end
            mreturn EvaluateFieldLoopExpression(tkn, template, loops, doEvaluate)
        endmethod

        private static method evaluateFieldAutoTimeUpdated, boolean
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            lambda doEvaluate(str, field, index)
            begin
                data result, boolean, false
                if (field.DataType == RpsFieldDataType.AutoTime)
                begin
                    data k, @RpsKey
                    foreach k in str.Keys
                    begin
                        data s, @RpsKeySegment
                        foreach s in k.Segments
                        begin
                            if (result = ((s.Field == field.OriginalName) && (s.DataType == RpsKeySegmentDataType.AutoTimestampUpdated)))
                                exitloop
                        end
                        if (result)
                            exitloop
                    end
                end
                mreturn result
            end
            mreturn EvaluateFieldLoopExpression(tkn, template, loops, doEvaluate)
        endmethod

        private static method evaluateFieldBinary, boolean
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            lambda doEvaluate(str, field, index) (field.DataType == RpsFieldDataType.Binary)
            mreturn EvaluateFieldLoopExpression(tkn, template, loops, doEvaluate)
        endmethod

        private static method evaluateFieldBold, boolean
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            lambda doEvaluate(str, field, index) (field.RenditionHighlight)
            mreturn EvaluateFieldLoopExpression(tkn, template, loops, doEvaluate)
        endmethod

        private static method evaluateFieldBoolean, boolean
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            lambda doEvaluate(str, field, index) (field.DataType == RpsFieldDataType.Boolean)
            mreturn EvaluateFieldLoopExpression(tkn, template, loops, doEvaluate)
        endmethod

        private static method evaluateFieldBreak, boolean
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            lambda doEvaluate(str, field, index) (field.BreakMode != RpsFieldBreak.None)
            mreturn EvaluateFieldLoopExpression(tkn, template, loops, doEvaluate)
        endmethod

        private static method evaluateFieldBreakAlways, boolean
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            lambda doEvaluate(str, field, index) (field.BreakMode == RpsFieldBreak.Always)
            mreturn EvaluateFieldLoopExpression(tkn, template, loops, doEvaluate)
        endmethod

        private static method evaluateFieldBreakChange, boolean
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            lambda doEvaluate(str, field, index) (field.BreakMode == RpsFieldBreak.Change)
            mreturn EvaluateFieldLoopExpression(tkn, template, loops, doEvaluate)
        endmethod

        private static method evaluateFieldBreakReturn, boolean
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            lambda doEvaluate(str, field, index) (field.BreakMode == RpsFieldBreak.OnReturn)
            mreturn EvaluateFieldLoopExpression(tkn, template, loops, doEvaluate)
        endmethod

        private static method evaluateFieldBzero, boolean
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            lambda doEvaluate(str, field, index) (field.BlankIfZero)
            mreturn EvaluateFieldLoopExpression(tkn, template, loops, doEvaluate)
        endmethod

        private static method evaluateFieldChange, boolean
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            lambda doEvaluate(str, field, index) (!String.IsNullOrWhiteSpace(field.ChangeMethod))
            mreturn EvaluateFieldLoopExpression(tkn, template, loops, doEvaluate)
        endmethod

        private static method evaluateFieldCheckBox, boolean
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            lambda doEvaluate(str, field, index) (field.ViewAs == RpsFieldViewAs.CheckBox)
            mreturn EvaluateFieldLoopExpression(tkn, template, loops, doEvaluate)
        endmethod

        private static method evaluateFieldCoerceBoolean, boolean
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            lambda doEvaluate(str, field, index) (field.CoercedType == RpsFieldCoercedType.CtBoolean)
            mreturn EvaluateFieldLoopExpression(tkn, template, loops, doEvaluate)
        endmethod

        private static method evaluateFieldComboBox, boolean
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            lambda doEvaluate(str, field, index) ((field.ViewAs == RpsFieldViewAs.Field) && (field.SelectionList.Count > 0))
            mreturn EvaluateFieldLoopExpression(tkn, template, loops, doEvaluate)
        endmethod

        private static method evaluateFieldCustomDblType, boolean
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            lambda doEvaluate(str, field, index)
            begin
                data stringToTest, string
                if (field.LongDescription.Contains("CUSTOM_DBL_TYPE=")) then
                    stringToTest = field.LongDescription
                else if (field.UserText.Contains("CUSTOM_DBL_TYPE="))
                    stringToTest = field.UserText
                if (!String.IsNullOrWhiteSpace(stringToTest))
                begin
                    data startPos = stringToTest.IndexOf("CUSTOM_DBL_TYPE=")
                    data semiPos, int, -1
                    if (startPos!=-1)
                        semiPos = stringToTest.IndexOf(";",startPos)
                    if ((startPos!=-1) && (semiPos!=-1) && (semiPos>(startPos+16)))
                        mreturn true
                end
                mreturn false
            end
            mreturn EvaluateFieldLoopExpression(tkn, template, loops, doEvaluate)
        endmethod

        private static method evaluateFieldCustomSqlType, boolean
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            lambda doEvaluate(str, field, index)
            begin
                data stringToTest, string
                if (field.LongDescription.Contains("CUSTOM_SQL_TYPE=")) then
                    stringToTest = field.LongDescription
                else if (field.UserText.Contains("CUSTOM_SQL_TYPE="))
                    stringToTest = field.UserText
                if (!String.IsNullOrWhiteSpace(stringToTest))
                begin
                    data startPos = stringToTest.IndexOf("CUSTOM_SQL_TYPE=")
                    data semiPos, int, -1
                    if (startPos!=-1)
                        semiPos = stringToTest.IndexOf(";",startPos)
                    if ((startPos!=-1) && (semiPos!=-1) && (semiPos>(startPos+16)))
                        mreturn true
                end
                mreturn false
            end
            mreturn EvaluateFieldLoopExpression(tkn, template, loops, doEvaluate)
        endmethod

        private static method evaluateFieldCustomConvertFunction, boolean
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            lambda doEvaluate(str, field, index)
            begin
                data stringToTest, string
                if (field.LongDescription.Contains("CUSTOM_CONVERT_FUNCTION=")) then
                    stringToTest = field.LongDescription
                else if (field.UserText.Contains("CUSTOM_CONVERT_FUNCTION="))
                    stringToTest = field.UserText
                if (!String.IsNullOrWhiteSpace(stringToTest))
                begin
                    data startPos = stringToTest.IndexOf("CUSTOM_CONVERT_FUNCTION=")
                    data semiPos, int, -1
                    if (startPos!=-1)
                        semiPos = stringToTest.IndexOf(";",startPos)
                    if ((startPos!=-1) && (semiPos!=-1) && (semiPos>(startPos+24)))
                        mreturn true
                end
                mreturn false
            end
            mreturn EvaluateFieldLoopExpression(tkn, template, loops, doEvaluate)
        endmethod

        private static method evaluateFieldCustomStringFunction, boolean
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            lambda doEvaluate(str, field, index)
            begin
                data stringToTest, string
                if (field.LongDescription.Contains("CUSTOM_STRING_FUNCTION=")) then
                    stringToTest = field.LongDescription
                else if (field.UserText.Contains("CUSTOM_STRING_FUNCTION="))
                    stringToTest = field.UserText
                if (!String.IsNullOrWhiteSpace(stringToTest))
                begin
                    data startPos = stringToTest.IndexOf("CUSTOM_STRING_FUNCTION=")
                    data semiPos, int, -1
                    if (startPos!=-1)
                        semiPos = stringToTest.IndexOf(";",startPos)
                    if ((startPos!=-1) && (semiPos!=-1) && (semiPos>(startPos+23)))
                        mreturn true
                end
                mreturn false
            end
            mreturn EvaluateFieldLoopExpression(tkn, template, loops, doEvaluate)
        endmethod

        private static method evaluateFieldDate, boolean
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            lambda doEvaluate(str, field, index)
            begin
                using field.DataTypeSubclass select
                (RpsFieldSubclass.UserDate, RpsFieldSubclass.DateYYYYJJJ, RpsFieldSubclass.DateYYYYPP, RpsFieldSubclass.DateYYYYMMDD, RpsFieldSubclass.DateYYJJJ, RpsFieldSubclass.DateYYPP, RpsFieldSubclass.DateYYMMDD),
                    mreturn true
                (),
                    mreturn false
                endusing
            end
            mreturn EvaluateFieldLoopExpression(tkn, template, loops, doEvaluate)
        endmethod

        private static method evaluateFieldDateJulian, boolean
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            lambda doEvaluate(str, field, index) ((field.TypeName == "DATE") && ((field.DataTypeSubclass == RpsFieldSubclass.DateYYJJJ) || (field.DataTypeSubclass == RpsFieldSubclass.DateYYYYJJJ)))
            mreturn EvaluateFieldLoopExpression(tkn, template, loops, doEvaluate)
        endmethod

        private static method evaluateFieldDateNotJulian, boolean
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            lambda doEvaluate(str, field, index) ((field.TypeName == "DATE") && ((field.DataTypeSubclass != RpsFieldSubclass.DateYYJJJ) && (field.DataTypeSubclass != RpsFieldSubclass.DateYYYYJJJ)))
            mreturn EvaluateFieldLoopExpression(tkn, template, loops, doEvaluate)
        endmethod

        private static method evaluateFieldDateNotNullable, boolean
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            lambda doEvaluate(str, field, index) (field.TypeName == "DATE")
            mreturn EvaluateFieldLoopExpression(tkn, template, loops, doEvaluate)
        endmethod

        private static method evaluateFieldDateNotPeriod, boolean
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            lambda doEvaluate(str, field, index) ((field.TypeName == "DATE") && ((field.DataTypeSubclass != RpsFieldSubclass.DateYYPP) && (field.DataTypeSubclass != RpsFieldSubclass.DateYYYYPP)))
            mreturn EvaluateFieldLoopExpression(tkn, template, loops, doEvaluate)
        endmethod

        private static method evaluateFieldDateNotYMD, boolean
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            lambda doEvaluate(str, field, index) (((field.TypeName == "DATE") && (field.DataTypeSubclass != RpsFieldSubclass.DateYYMMDD)) && (field.DataTypeSubclass != RpsFieldSubclass.DateYYYYMMDD))
            mreturn EvaluateFieldLoopExpression(tkn, template, loops, doEvaluate)
        endmethod

        private static method evaluateFieldDateNotYYYYMMDD, boolean
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            lambda doEvaluate(str, field, index) ((field.TypeName == "DATE") && (field.DataTypeSubclass != RpsFieldSubclass.DateYYYYMMDD))
            mreturn EvaluateFieldLoopExpression(tkn, template, loops, doEvaluate)
        endmethod

        private static method evaluateFieldDateNullable, boolean
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            lambda doEvaluate(str, field, index) (field.TypeName == "NULLABLEDATETIME" && field.DataTypeSubclass != RpsFieldSubclass.TimeHHMM && field.DataTypeSubclass != RpsFieldSubclass.TimeHHMMSS)
            mreturn EvaluateFieldLoopExpression(tkn, template, loops, doEvaluate)
        endmethod

        private static method evaluateFieldDatePeriod, boolean
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            lambda doEvaluate(str, field, index) ((field.TypeName == "DATE") && ((field.DataTypeSubclass == RpsFieldSubclass.DateYYPP) || (field.DataTypeSubclass == RpsFieldSubclass.DateYYYYPP)))
            mreturn EvaluateFieldLoopExpression(tkn, template, loops, doEvaluate)
        endmethod

        private static method evaluateFieldDateYMD, boolean
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            lambda doEvaluate(str, field, index) ((field.TypeName == "DATE" || field.TypeName == "NULLABLEDATETIME") && ((field.DataTypeSubclass == RpsFieldSubclass.DateYYYYMMDD) || (field.DataTypeSubclass == RpsFieldSubclass.DateYYMMDD)))
            mreturn EvaluateFieldLoopExpression(tkn, template, loops, doEvaluate)
        endmethod

        private static method evaluateFieldDayeYYJJJ, boolean
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            lambda doEvaluate(str, field, index) ((field.TypeName == "DATE") && (field.DataTypeSubclass == RpsFieldSubclass.DateYYJJJ))
            mreturn EvaluateFieldLoopExpression(tkn, template, loops, doEvaluate)
        endmethod

        private static method evaluateFieldDateYYMMDD, boolean
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            lambda doEvaluate(str, field, index) ((field.TypeName == "DATE" || field.TypeName == "NULLABLEDATETIME") && field.DataTypeSubclass == RpsFieldSubclass.DateYYMMDD)
            mreturn EvaluateFieldLoopExpression(tkn, template, loops, doEvaluate)
        endmethod

        private static method evaluateFieldDateYYPP, boolean
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            lambda doEvaluate(str, field, index) ((field.TypeName == "DATE") && (field.DataTypeSubclass == RpsFieldSubclass.DateYYPP))
            mreturn EvaluateFieldLoopExpression(tkn, template, loops, doEvaluate)
        endmethod

        private static method evaluateFieldDateYYYYJJJ, boolean
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            lambda doEvaluate(str, field, index) ((field.TypeName == "DATE") && (field.DataTypeSubclass == RpsFieldSubclass.DateYYYYJJJ))
            mreturn EvaluateFieldLoopExpression(tkn, template, loops, doEvaluate)
        endmethod

        private static method evaluateFieldDateYYYYMMDD, boolean
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            lambda doEvaluate(str, field, index) ((field.TypeName == "DATE" || field.TypeName == "NULLABLEDATETIME") && field.DataTypeSubclass == RpsFieldSubclass.DateYYYYMMDD)
            mreturn EvaluateFieldLoopExpression(tkn, template, loops, doEvaluate)
        endmethod

        private static method evaluateFieldYYYYPP, boolean
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            lambda doEvaluate(str, field, index) ((field.TypeName == "DATE") && (field.DataTypeSubclass == RpsFieldSubclass.DateYYYYPP))
            mreturn EvaluateFieldLoopExpression(tkn, template, loops, doEvaluate)
        endmethod

        private static method evaluateFieldDateOrTime, boolean
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            lambda doEvaluate(str, field, index) (((field.TypeName == "DATE") || (field.TypeName == "NULLABLEDATETIME")) || (field.TypeName == "TIME"))
            mreturn EvaluateFieldLoopExpression(tkn, template, loops, doEvaluate)
        endmethod

        private static method evaluateFieldDateToday, boolean
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            lambda doEvaluate(str, field, index) (field.DateDefaultToday)
            mreturn EvaluateFieldLoopExpression(tkn, template, loops, doEvaluate)
        endmethod

        private static method evaluateFieldDecimal, boolean
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            lambda doEvaluate(str, field, index) ((((field.DataType == RpsFieldDataType.Decimal) && (field.TypeName != "DATE")) && (field.TypeName != "NULLABLEDATETIME")) && (field.TypeName != "TIME"))
            mreturn EvaluateFieldLoopExpression(tkn, template, loops, doEvaluate)
        endmethod

        private static method evaluateFieldDefault, boolean
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            lambda doEvaluate(str, field, index) (!String.IsNullOrWhiteSpace(field.DefaultValue))
            mreturn EvaluateFieldLoopExpression(tkn, template, loops, doEvaluate)
        endmethod

        private static method evaluateFieldDescription, boolean
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            lambda doEvaluate(str, field, index) (!String.IsNullOrWhiteSpace(field.Description))
            mreturn EvaluateFieldLoopExpression(tkn, template, loops, doEvaluate)
        endmethod

        private static method evaluateFieldDisabled, boolean
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            lambda doEvaluate(str, field, index) (field.Disabled)
            mreturn EvaluateFieldLoopExpression(tkn, template, loops, doEvaluate)
        endmethod

        private static method evaluateFieldDisplay, boolean
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            lambda doEvaluate(str, field, index) (!String.IsNullOrWhiteSpace(field.DisplayMethod))
            mreturn EvaluateFieldLoopExpression(tkn, template, loops, doEvaluate)
        endmethod

        private static method evaluateFieldDisplayLength, boolean
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            lambda doEvaluate(str, field, index) (field.DisplayLength > 0)
            mreturn EvaluateFieldLoopExpression(tkn, template, loops, doEvaluate)
        endmethod

        private static method evaluateFieldDrill, boolean
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            lambda doEvaluate(str, field, index) (!String.IsNullOrWhiteSpace(field.DrillMethod))
            mreturn EvaluateFieldLoopExpression(tkn, template, loops, doEvaluate)
        endmethod

        private static method evaluateFieldEcho, boolean
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            lambda doEvaluate(str, field, index) (!field.NoEcho)
            mreturn EvaluateFieldLoopExpression(tkn, template, loops, doEvaluate)
        endmethod

        private static method evaluateFieldEditFormat, boolean
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            lambda doEvaluate(str, field, index) (!String.IsNullOrWhiteSpace(field.EditFormatMethod))
            mreturn EvaluateFieldLoopExpression(tkn, template, loops, doEvaluate)
        endmethod

        private static method evaluateFieldEnabled, boolean
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            lambda doEvaluate(str, field, index) (!field.Disabled)
            mreturn EvaluateFieldLoopExpression(tkn, template, loops, doEvaluate)
        endmethod

        private static method evaluateFieldEnum, boolean
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            lambda doEvaluate(str, field, index) (field.DataType == RpsFieldDataType.Enum)
            mreturn EvaluateFieldLoopExpression(tkn, template, loops, doEvaluate)
        endmethod

        private static method evaluateFieldEnumerated, boolean
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            lambda doEvaluate(str, field, index) (field.Enumerated)
            mreturn EvaluateFieldLoopExpression(tkn, template, loops, doEvaluate)
        endmethod

        private static method evaluateFieldExplicitGroup, boolean
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            lambda doEvaluate(str, field, index) (field.GroupType != RpsFieldGroup.No && String.IsNullOrWhiteSpace(field.GroupStructure))
            mreturn EvaluateFieldLoopExpression(tkn, template, loops, doEvaluate)
        endmethod

        private static method evaluateFieldPosition, boolean
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            lambda doEvaluate(str, field, index) (((field.FieldPositionMode != RpsPositionMode.None) && (field.FieldRow > 0)) && (field.FieldColumn > 0))
            mreturn EvaluateFieldLoopExpression(tkn, template, loops, doEvaluate)
        endmethod

        private static method evaluateFieldFormat, boolean
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            lambda doEvaluate(str, field, index) (!String.IsNullOrWhiteSpace(field.FormatName))
            mreturn EvaluateFieldLoopExpression(tkn, template, loops, doEvaluate)
        endmethod

        private static method evaluateFieldGroup, boolean
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            lambda doEvaluate(str, field, index) (field.GroupType != RpsFieldGroup.No)
            mreturn EvaluateFieldLoopExpression(tkn, template, loops, doEvaluate)
        endmethod

        private static method evaluateFieldGroupOverlay, boolean
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            lambda doEvaluate(str, field, index) (field.GroupType == RpsFieldGroup.Overlay)
            mreturn EvaluateFieldLoopExpression(tkn, template, loops, doEvaluate)
        endmethod

        private static method evaluateFieldGroupMemberPrefix, boolean
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            lambda doEvaluate(str, field, index) (field.IsGroup && !String.IsNullOrWhiteSpace(field.GroupMemberPrefix))
            mreturn EvaluateFieldLoopExpression(tkn, template, loops, doEvaluate)
        endmethod

        private static method evaluateFieldGroupMemberPrefixCompiler, boolean
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            lambda doEvaluate(str, field, index) (field.CompilerUsesGroupMemberPrefix)
            mreturn EvaluateFieldLoopExpression(tkn, template, loops, doEvaluate)
        endmethod

        private static method evaluateFieldExplicitGroupNoExpand, boolean
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            lambda doEvaluate(str, field, index) (template.Context.CurrentTask.ExplicitGroupNoExpand)
            mreturn EvaluateFieldLoopExpression(tkn, template, loops, doEvaluate)
        endmethod

        private static method evaluateFieldImplicitGroup, boolean
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            lambda doEvaluate(str, field, index) (field.GroupType != RpsFieldGroup.No && !String.IsNullOrWhiteSpace(field.GroupStructure))
            mreturn EvaluateFieldLoopExpression(tkn, template, loops, doEvaluate)
        endmethod

        private static method evaluateFieldImplicitGroupNoExpand, boolean
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            lambda doEvaluate(str, field, index) (template.Context.CurrentTask.ImplicitGroupNoExpand)
            mreturn EvaluateFieldLoopExpression(tkn, template, loops, doEvaluate)
        endmethod

        private static method evaluateFieldHeading, boolean
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            lambda doEvaluate(str, field, index) (!String.IsNullOrWhiteSpace(field.ReportHeading))
            mreturn EvaluateFieldLoopExpression(tkn, template, loops, doEvaluate)
        endmethod

        private static method evaluateFieldHelpID, boolean
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            lambda doEvaluate(str, field, index) (!String.IsNullOrWhiteSpace(field.HelpIdentifier))
            mreturn EvaluateFieldLoopExpression(tkn, template, loops, doEvaluate)
        endmethod

        private static method evaluateFieldHyperlink, boolean
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            lambda doEvaluate(str, field, index) (!String.IsNullOrWhiteSpace(field.HyperlinkMethod))
            mreturn EvaluateFieldLoopExpression(tkn, template, loops, doEvaluate)
        endmethod

        private static method evaluateFieldI1, boolean
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            lambda doEvaluate(str, field, index) ((field.DataType == RpsFieldDataType.Integer) && (field.Size == 1))
            mreturn EvaluateFieldLoopExpression(tkn, template, loops, doEvaluate)
        endmethod

        private static method evaluateFieldI123, boolean
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            lambda doEvaluate(str, field, index) ((field.DataType == RpsFieldDataType.Integer) && (field.Size <= 4))
            mreturn EvaluateFieldLoopExpression(tkn, template, loops, doEvaluate)
        endmethod

        private static method evaluateFieldI2, boolean
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            lambda doEvaluate(str, field, index) ((field.DataType == RpsFieldDataType.Integer) && (field.Size == 2))
            mreturn EvaluateFieldLoopExpression(tkn, template, loops, doEvaluate)
        endmethod

        private static method evaluateFieldI4, boolean
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            lambda doEvaluate(str, field, index) ((field.DataType == RpsFieldDataType.Integer) && (field.Size == 4))
            mreturn EvaluateFieldLoopExpression(tkn, template, loops, doEvaluate)
        endmethod

        private static method evaluateFieldI8, boolean
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            lambda doEvaluate(str, field, index) ((field.DataType == RpsFieldDataType.Integer) && (field.Size == 8))
            mreturn EvaluateFieldLoopExpression(tkn, template, loops, doEvaluate)
        endmethod

        private static method evaluateFieldInfoLine, boolean
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            lambda doEvaluate(str, field, index) (!String.IsNullOrWhiteSpace(field.InfoLineText))
            mreturn EvaluateFieldLoopExpression(tkn, template, loops, doEvaluate)
        endmethod

        private static method evaluateFieldInputCenter, boolean
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            lambda doEvaluate(str, field, index) (field.InputJustification == RpsJustification.Center)
            mreturn EvaluateFieldLoopExpression(tkn, template, loops, doEvaluate)
        endmethod

        private static method evaluateFieldInputLeft, boolean
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            lambda doEvaluate(str, field, index) (field.InputJustification == RpsJustification.Left)
            mreturn EvaluateFieldLoopExpression(tkn, template, loops, doEvaluate)
        endmethod

        private static method evaluateFieldInputRight, boolean
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            lambda doEvaluate(str, field, index) (field.InputJustification == RpsJustification.Right)
            mreturn EvaluateFieldLoopExpression(tkn, template, loops, doEvaluate)
        endmethod

        private static method evaluateFieldInteger, boolean
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            lambda doEvaluate(str, field, index) (field.DataType == RpsFieldDataType.Integer)
            mreturn EvaluateFieldLoopExpression(tkn, template, loops, doEvaluate)
        endmethod

        private static method evaluateFieldLanguage, boolean
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            lambda doEvaluate(str, field, index) (!field.ExcludedByLanguage)
            mreturn EvaluateFieldLoopExpression(tkn, template, loops, doEvaluate)
        endmethod

        private static method evaluateFieldLeave, boolean
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            lambda doEvaluate(str, field, index) (!String.IsNullOrWhiteSpace(field.LeaveMethod))
            mreturn EvaluateFieldLoopExpression(tkn, template, loops, doEvaluate)
        endmethod

        private static method evaluateFieldLengthOver8, boolean
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            lambda doEvaluate(str, field, index) (field.Size>8)
            mreturn EvaluateFieldLoopExpression(tkn, template, loops, doEvaluate)
        endmethod

        private static method evaluateFieldLongDescription, boolean
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            lambda doEvaluate(str, field, index) (!String.IsNullOrWhiteSpace(field.LongDescription))
            mreturn EvaluateFieldLoopExpression(tkn, template, loops, doEvaluate)
        endmethod

        private static method evaluateFieldMapped, boolean
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            lambda doEvaluate(str, field, index) (!String.IsNullOrWhiteSpace(field.MappedField))
            mreturn EvaluateFieldLoopExpression(tkn, template, loops, doEvaluate)
        endmethod

        private static method evaluateFieldMappedStr, boolean
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            lambda doEvaluate(str, field, index) (!String.IsNullOrWhiteSpace(str.MappedStructure))
            mreturn EvaluateFieldLoopExpression(tkn, template, loops, doEvaluate)
        endmethod

        private static method evaluateFieldNameLink, boolean
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            lambda doEvaluate(str, field, index) (!field.NoNameLink)
            mreturn EvaluateFieldLoopExpression(tkn, template, loops, doEvaluate)
        endmethod

        private static method evaluateFieldNegativeAllowed, boolean
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            lambda doEvaluate(str, field, index) (field.NegativeAllowed != RpsFieldNegatives.None)
            mreturn EvaluateFieldLoopExpression(tkn, template, loops, doEvaluate)
        endmethod

        private static method evaluateFieldNegativeOrZero, boolean
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            lambda doEvaluate(str, field, index) (field.NegativeAllowed == RpsFieldNegatives.OrZero)
            mreturn EvaluateFieldLoopExpression(tkn, template, loops, doEvaluate)
        endmethod

        private static method evaluateFieldNegativeRequired, boolean
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            lambda doEvaluate(str, field, index) (field.NegativeAllowed == RpsFieldNegatives.Only)
            mreturn EvaluateFieldLoopExpression(tkn, template, loops, doEvaluate)
        endmethod

        private static method evaluateFieldNoAllowList, boolean
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            lambda doEvaluate(str, field, index) (field.AllowList.Count == 0)
            mreturn EvaluateFieldLoopExpression(tkn, template, loops, doEvaluate)
        endmethod

        private static method evaluateFieldNoAlternateName, boolean
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            lambda doEvaluate(str, field, index) (field.AlternateName == field.OriginalName)
            mreturn EvaluateFieldLoopExpression(tkn, template, loops, doEvaluate)
        endmethod

        private static method evaluateFieldNoArrive, boolean
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            lambda doEvaluate(str, field, index) (String.IsNullOrWhiteSpace(field.ArriveMethod))
            mreturn EvaluateFieldLoopExpression(tkn, template, loops, doEvaluate)
        endmethod

        private static method evaluateFieldNoBreak, boolean
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            lambda doEvaluate(str, field, index) (field.BreakMode == RpsFieldBreak.None)
            mreturn EvaluateFieldLoopExpression(tkn, template, loops, doEvaluate)
        endmethod

        private static method evaluateFieldNoChange, boolean
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            lambda doEvaluate(str, field, index) (String.IsNullOrWhiteSpace(field.ChangeMethod))
            mreturn EvaluateFieldLoopExpression(tkn, template, loops, doEvaluate)
        endmethod

        private static method evaluateFieldNoCheckBox, boolean
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            lambda doEvaluate(str, field, index) (field.ViewAs != RpsFieldViewAs.CheckBox)
            mreturn EvaluateFieldLoopExpression(tkn, template, loops, doEvaluate)
        endmethod

        private static method evaluateFieldNoCoerceBoolean, boolean
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            lambda doEvaluate(str, field, index) (field.CoercedType != RpsFieldCoercedType.CtBoolean)
            mreturn EvaluateFieldLoopExpression(tkn, template, loops, doEvaluate)
        endmethod

        private static method evaluateFieldNoDefault, boolean
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            lambda doEvaluate(str, field, index) (String.IsNullOrWhiteSpace(field.DefaultValue))
            mreturn EvaluateFieldLoopExpression(tkn, template, loops, doEvaluate)
        endmethod

        private static method evaluateFieldNoDescription, boolean
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            lambda doEvaluate(str, field, index) (String.IsNullOrWhiteSpace(field.Description))
            mreturn EvaluateFieldLoopExpression(tkn, template, loops, doEvaluate)
        endmethod

        private static method evaluateFieldNoDisplay, boolean
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            lambda doEvaluate(str, field, index) (String.IsNullOrWhiteSpace(field.DisplayMethod))
            mreturn EvaluateFieldLoopExpression(tkn, template, loops, doEvaluate)
        endmethod

        private static method evaluateFieldNoDisplayLength, boolean
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            lambda doEvaluate(str, field, index) (field.DisplayLength == 0)
            mreturn EvaluateFieldLoopExpression(tkn, template, loops, doEvaluate)
        endmethod

        private static method evaluateFieldNoDrill, boolean
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            lambda doEvaluate(str, field, index) (String.IsNullOrWhiteSpace(field.DrillMethod))
            mreturn EvaluateFieldLoopExpression(tkn, template, loops, doEvaluate)
        endmethod

        private static method evaluateFieldNoEcho, boolean
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            lambda doEvaluate(str, field, index) (field.NoEcho)
            mreturn EvaluateFieldLoopExpression(tkn, template, loops, doEvaluate)
        endmethod

        private static method evaluateFieldNoEditFormat, boolean
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            lambda doEvaluate(str, field, index) (String.IsNullOrWhiteSpace(field.EditFormatMethod))
            mreturn EvaluateFieldLoopExpression(tkn, template, loops, doEvaluate)
        endmethod

        private static method evaluateFieldNoFormat, boolean
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            lambda doEvaluate(str, field, index) (String.IsNullOrWhiteSpace(field.FormatName))
            mreturn EvaluateFieldLoopExpression(tkn, template, loops, doEvaluate)
        endmethod

        private static method evaluateFieldNoHelpID, boolean
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            lambda doEvaluate(str, field, index) (String.IsNullOrWhiteSpace(field.HelpIdentifier))
            mreturn EvaluateFieldLoopExpression(tkn, template, loops, doEvaluate)
        endmethod

        private static method evaluateFieldNoHyperlink, boolean
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            lambda doEvaluate(str, field, index) (String.IsNullOrWhiteSpace(field.HyperlinkMethod))
            mreturn EvaluateFieldLoopExpression(tkn, template, loops, doEvaluate)
        endmethod

        private static method evaluateFieldNoInfoLine, boolean
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            lambda doEvaluate(str, field, index) (String.IsNullOrWhiteSpace(field.InfoLineText))
            mreturn EvaluateFieldLoopExpression(tkn, template, loops, doEvaluate)
        endmethod

        private static method evaluateFieldNoLanguage, boolean
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            lambda doEvaluate(str, field, index) (field.ExcludedByLanguage)
            mreturn EvaluateFieldLoopExpression(tkn, template, loops, doEvaluate)
        endmethod

        private static method evaluateFieldNoLeave, boolean
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            lambda doEvaluate(str, field, index) (String.IsNullOrWhiteSpace(field.LeaveMethod))
            mreturn EvaluateFieldLoopExpression(tkn, template, loops, doEvaluate)
        endmethod

        private static method evaluateFieldNoLongDescription, boolean
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            lambda doEvaluate(str, field, index) (String.IsNullOrWhiteSpace(field.LongDescription))
            mreturn EvaluateFieldLoopExpression(tkn, template, loops, doEvaluate)
        endmethod

        private static method evaluateFieldNoNegative, boolean
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            lambda doEvaluate(str, field, index) (field.NegativeAllowed == RpsFieldNegatives.None)
            mreturn EvaluateFieldLoopExpression(tkn, template, loops, doEvaluate)
        endmethod

        private static method evaluateFieldNoPaintChar, boolean
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            lambda doEvaluate(str, field, index) (!field.PaintCharacterSpecified)
            mreturn EvaluateFieldLoopExpression(tkn, template, loops, doEvaluate)
        endmethod

        private static method evaluateFieldNoPrecision, boolean
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            lambda doEvaluate(str, field, index) (field.Precision == 0)
            mreturn EvaluateFieldLoopExpression(tkn, template, loops, doEvaluate)
        endmethod

        private static method evaluateFieldNoPrompt, boolean
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            lambda doEvaluate(str, field, index) (String.IsNullOrWhiteSpace(field.Prompt))
            mreturn EvaluateFieldLoopExpression(tkn, template, loops, doEvaluate)
        endmethod

        private static method evaluateFieldNoRange, boolean
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            lambda doEvaluate(str, field, index) (!field.NumericRangeExists)
            mreturn EvaluateFieldLoopExpression(tkn, template, loops, doEvaluate)
        endmethod

        private static method evaluateFieldNoReport, boolean
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            lambda doEvaluate(str, field, index) (field.ExcludedByReportWriter)
            mreturn EvaluateFieldLoopExpression(tkn, template, loops, doEvaluate)
        endmethod

        private static method evaluateFieldNoSelections, boolean
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            lambda doEvaluate(str, field, index) (field.SelectionList.Count == 0)
            mreturn EvaluateFieldLoopExpression(tkn, template, loops, doEvaluate)
        endmethod

        private static method evaluateFieldNoSelWnd, boolean
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            lambda doEvaluate(str, field, index) (String.IsNullOrWhiteSpace(field.SelectionWindowName))
            mreturn EvaluateFieldLoopExpression(tkn, template, loops, doEvaluate)
        endmethod

        private static method evaluateFieldNotAlpha, boolean
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            lambda doEvaluate(str, field, index) (field.DataType != RpsFieldDataType.Alpha)
            mreturn EvaluateFieldLoopExpression(tkn, template, loops, doEvaluate)
        endmethod

        private static method evaluateFieldNotArray, boolean
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            lambda doEvaluate(str, field, index) (!field.WasArrayElement)
            mreturn EvaluateFieldLoopExpression(tkn, template, loops, doEvaluate)
        endmethod

        private static method evaluateFieldNotBinary, boolean
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            lambda doEvaluate(str, field, index) (field.DataType != RpsFieldDataType.Binary)
            mreturn EvaluateFieldLoopExpression(tkn, template, loops, doEvaluate)
        endmethod

        private static method evaluateFieldNotBoolean, boolean
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            lambda doEvaluate(str, field, index) (field.DataType != RpsFieldDataType.Boolean)
            mreturn EvaluateFieldLoopExpression(tkn, template, loops, doEvaluate)
        endmethod

        private static method evaluateFieldNotBzero, boolean
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            lambda doEvaluate(str, field, index) (!field.BlankIfZero)
            mreturn EvaluateFieldLoopExpression(tkn, template, loops, doEvaluate)
        endmethod

        private static method evaluateFieldNotDate, boolean
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            lambda doEvaluate(str, field, index) ((field.TypeName != "DATE") && (field.TypeName != "NULLABLEDATETIME"))
            mreturn EvaluateFieldLoopExpression(tkn, template, loops, doEvaluate)
        endmethod

        private static method evaluateFieldNotDateOrTime, boolean
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            lambda doEvaluate(str, field, index) (((field.TypeName != "DATE") && (field.TypeName != "NULLABLEDATETIME")) && (field.TypeName != "TIME"))
            mreturn EvaluateFieldLoopExpression(tkn, template, loops, doEvaluate)
        endmethod

        private static method evaluateFieldNotDateToday, boolean
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            lambda doEvaluate(str, field, index) (!field.DateDefaultToday)
            mreturn EvaluateFieldLoopExpression(tkn, template, loops, doEvaluate)
        endmethod

        private static method evaluateFieldNotDecimal, boolean
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            lambda doEvaluate(str, field, index) (field.DataType != RpsFieldDataType.Decimal) || ((field.DataType == RpsFieldDataType.Decimal) && (((field.TypeName == "DATE") || (field.TypeName == "NULLABLEDATETIME")) || (field.TypeName == "TIME")))
            mreturn EvaluateFieldLoopExpression(tkn, template, loops, doEvaluate)
        endmethod

        private static method evaluateFieldNotEnum, boolean
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            lambda doEvaluate(str, field, index) (field.DataType != RpsFieldDataType.Enum)
            mreturn EvaluateFieldLoopExpression(tkn, template, loops, doEvaluate)
        endmethod

        private static method evaluateFieldNotEnumerated, boolean
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            lambda doEvaluate(str, field, index) (!field.Enumerated)
            mreturn EvaluateFieldLoopExpression(tkn, template, loops, doEvaluate)
        endmethod

        private static method evaluateFieldNoTimeout, boolean
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            lambda doEvaluate(str, field, index) (field.InputTimeoutMode == RpsFieldTimeout.None)
            mreturn EvaluateFieldLoopExpression(tkn, template, loops, doEvaluate)
        endmethod

        private static method evaluateFieldNotInteger, boolean
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            lambda doEvaluate(str, field, index) (field.DataType != RpsFieldDataType.Integer)
            mreturn EvaluateFieldLoopExpression(tkn, template, loops, doEvaluate)
        endmethod

        private static method evaluateFieldNotNumeric, boolean
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            lambda doEvaluate(str, field, index) ((field.DataType != RpsFieldDataType.Decimal) && (field.DataType != RpsFieldDataType.Integer))
            mreturn EvaluateFieldLoopExpression(tkn, template, loops, doEvaluate)
        endmethod

        private static method evaluateFieldNoToolkit, boolean
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            lambda doEvaluate(str, field, index) (field.ExcludedByToolkit)
            mreturn EvaluateFieldLoopExpression(tkn, template, loops, doEvaluate)
        endmethod

        private static method evaluateFieldNotOverlay, boolean
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            lambda doEvaluate(str, field, index) ((!field.IsGroup && String.IsNullOrWhiteSpace(field.OverlaysField)) || (field.IsGroup && (field.GroupType != RpsFieldGroup.Overlay)))
            mreturn EvaluateFieldLoopExpression(tkn, template, loops, doEvaluate)
        endmethod

        private static method evaluateFieldNotPkSegment, boolean
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            lambda doEvaluate(str, field, index)
            begin
                data isPkSegment, boolean, false
                if (str.Keys.Count > 0)
                begin
                    data segment, @RpsKeySegment
                    foreach segment in str.Keys[0].Segments
                    begin
                        if (segment.Field == field.OriginalName)
                        begin
                            isPkSegment = true
                            exitloop
                        end
                    end
                end
                mreturn !isPkSegment
            end
            mreturn EvaluateFieldLoopExpression(tkn, template, loops, doEvaluate)
        endmethod

        private static method evaluateFieldKeySegment, boolean
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            lambda doEvaluate(str, field, index)
            begin
                if (str.Keys.Count == 0)
                    mreturn false

                ;;Iterate through all keys looking for the current field being used as a key segment
                data key, @RpsKey
                foreach key in str.Keys
                begin
                    ;;Make sure it's an access key
                    if (key.KeyType == RpsKeyType.Foreign)
                        nextloop

                    ;;Check each segment for the field
                    data segment, @RpsKeySegment
                    foreach segment in key.Segments
                    begin
                        if (segment.SegmentType == RpsKeySegmentType.Field && segment.Field == field.OriginalName)
                            mreturn true
                    end
                end

                mreturn false
            end
            mreturn EvaluateFieldLoopExpression(tkn, template, loops, doEvaluate)
        endmethod

        private static method evaluateFirstUniqueKeySegment, boolean
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            lambda doEvaluate(str, field, index)
            begin
                if (str.Keys.Count == 0)
                    mreturn false

                ;;Iterate through all keys looking for the current field being used as a key segment in the first unique key
                data key, @RpsKey
                foreach key in str.Keys
                begin
                    ;;Make sure it's an access key and is a unique key
                    if ((key.KeyType == RpsKeyType.Foreign) || (key.Duplicates == RpsKeyDuplicates.Duplicates))
                        nextloop

                    ;;Check each segment for the field
                    data segment, @RpsKeySegment
                    foreach segment in key.Segments
                    begin
                        if (segment.SegmentType == RpsKeySegmentType.Field && segment.Field == field.OriginalName)
                            mreturn true
                    end
                    exitloop
                end
                mreturn false
            end
            mreturn EvaluateFieldLoopExpression(tkn, template, loops, doEvaluate)
        endmethod

        private static method evaluateFieldNotKeySegment, boolean
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            lambda doEvaluate(str, field, index)
            begin
                if (str.Keys.Count == 0)
                    mreturn true

                ;;Iterate through all keys looking for the current field being used as a key segment
                data key, @RpsKey
                foreach key in str.Keys
                begin
                    ;;Make sure it's an access key
                    if (key.KeyType == RpsKeyType.Foreign)
                        nextloop

                    ;;Check each segment for the field
                    data segment, @RpsKeySegment
                    foreach segment in key.Segments
                    begin
                        if (segment.SegmentType == RpsKeySegmentType.Field && segment.Field == field.OriginalName)
                            mreturn false
                    end
                end

                mreturn true
            end
            mreturn EvaluateFieldLoopExpression(tkn, template, loops, doEvaluate)
        endmethod

        private static method evaluateFieldNotRadioButtons, boolean
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            lambda doEvaluate(str, field, index) (field.ViewAs != RpsFieldViewAs.RadioButtons)
            mreturn EvaluateFieldLoopExpression(tkn, template, loops, doEvaluate)
        endmethod

        private static method evaluateFieldNotStructField, boolean
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            lambda doEvaluate(str, field, index) (field.DataType != RpsFieldDataType.StructField)
            mreturn EvaluateFieldLoopExpression(tkn, template, loops, doEvaluate)
        endmethod

        private static method evaluateFieldNotTime, boolean
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            lambda doEvaluate(str, field, index) (field.TypeName != "TIME")
            mreturn EvaluateFieldLoopExpression(tkn, template, loops, doEvaluate)
        endmethod

        private static method evaluateFieldNotUppercase, boolean
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            lambda doEvaluate(str, field, index) (!field.Uppercase)
            mreturn EvaluateFieldLoopExpression(tkn, template, loops, doEvaluate)
        endmethod

        private static method evaluateFieldNotUser, boolean
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            lambda doEvaluate(str, field, index) (field.DataType != RpsFieldDataType.User)
            mreturn EvaluateFieldLoopExpression(tkn, template, loops, doEvaluate)
        endmethod

        private static method evaluateFieldNotUserTimeStamp, boolean
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            lambda doEvaluate(str, field, index) (!(((field.DataType == RpsFieldDataType.User) && (field.DataTypeSubclass == RpsFieldSubclass.UserDate)) && (field.UserFieldType == "^CLASS^=YYYYMMDDHHMISSUUUUUU")))
            mreturn EvaluateFieldLoopExpression(tkn, template, loops, doEvaluate)
        endmethod

        private static method evaluateFieldNoUserText, boolean
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            lambda doEvaluate(str, field, index) (String.IsNullOrWhiteSpace(field.UserText))
            mreturn EvaluateFieldLoopExpression(tkn, template, loops, doEvaluate)
        endmethod

        private static method evaluateFieldNoViewLength, boolean
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            lambda doEvaluate(str, field, index) (field.ViewLength == 0)
            mreturn EvaluateFieldLoopExpression(tkn, template, loops, doEvaluate)
        endmethod

        private static method evaluateFieldNoWeb, boolean
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            lambda doEvaluate(str, field, index) (field.ExcludedByWeb)
            mreturn EvaluateFieldLoopExpression(tkn, template, loops, doEvaluate)
        endmethod

        private static method evaluateFieldNumeric, boolean
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            lambda doEvaluate(str, field, index) ((field.DataType == RpsFieldDataType.Decimal) || (field.DataType == RpsFieldDataType.Integer))
            mreturn EvaluateFieldLoopExpression(tkn, template, loops, doEvaluate)
        endmethod

        private static method evaluateFieldOcNative, boolean
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            lambda doEvaluate(str, field, index) (!field.OcObject)
            mreturn EvaluateFieldLoopExpression(tkn, template, loops, doEvaluate)
        endmethod

        private static method evaluateFieldOcObject, boolean
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            lambda doEvaluate(str, field, index) (field.OcObject)
            mreturn EvaluateFieldLoopExpression(tkn, template, loops, doEvaluate)
        endmethod

        private static method evaluateFieldOptional, boolean
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            lambda doEvaluate(str, field, index) (!field.Required)
            mreturn EvaluateFieldLoopExpression(tkn, template, loops, doEvaluate)
        endmethod

        private static method evaluateFieldOverlay, boolean
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            lambda doEvaluate(str, field, index) ((!String.IsNullOrWhiteSpace(field.OverlaysField)) || (field.IsGroup && (field.GroupType == RpsFieldGroup.Overlay)))
            mreturn EvaluateFieldLoopExpression(tkn, template, loops, doEvaluate)
        endmethod

        private static method evaluateFieldOverlayOffset, boolean
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            lambda doEvaluate(str, field, index) (field.OverlayOffset!=0)
            mreturn EvaluateFieldLoopExpression(tkn, template, loops, doEvaluate)
        endmethod

        private static method evaluateFieldPaintChar, boolean
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            lambda doEvaluate(str, field, index) (field.PaintCharacterSpecified)
            mreturn EvaluateFieldLoopExpression(tkn, template, loops, doEvaluate)
        endmethod

        private static method evaluateFieldPaintField, boolean
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            lambda doEvaluate(str, field, index) (field.PaintField)
            mreturn EvaluateFieldLoopExpression(tkn, template, loops, doEvaluate)
        endmethod

        private static method evaluateFieldPiiScrub, boolean
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            lambda doEvaluate(str, field, index)
            begin
                data textToSearch = field.LongDescription + field.UserText
                if (textToSearch.Contains("PII_TYPE="))
                begin
                    data startPos = textToSearch.IndexOf("PII_TYPE=")
                    data semiPos = -1
                    if (startPos!=-1)
                        semiPos = textToSearch.IndexOf(";",startPos)
                    mreturn (startPos!=-1) && (semiPos!=-1) && (semiPos>(startPos+9))
                end
                mreturn false
            end
            mreturn EvaluateFieldLoopExpression(tkn, template, loops, doEvaluate)
        endmethod

        private static method evaluateFieldPkSegment, boolean
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            lambda doEvaluate(str, field, index)
            begin
                data isPkSegment, boolean, false
                if (str.Keys.Count > 0)
                begin
                    data segment, @RpsKeySegment
                    foreach segment in str.Keys[0].Segments
                    begin
                        if (segment.Field == field.OriginalName)
                        begin
                            isPkSegment = true
                            exitloop
                        end
                    end
                end
                mreturn isPkSegment
            end
            mreturn EvaluateFieldLoopExpression(tkn, template, loops, doEvaluate)
        endmethod

        private static method evaluateFieldOnlyPkSegment, boolean
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            lambda doEvaluate(str, field, index)
            begin
                data isPkSegment, boolean, false

                if (str.Keys.Count > 0)
                begin
                    if (str.Keys[0].Segments.Count != 1)
                        mreturn false

                    data segment, @RpsKeySegment
                    foreach segment in str.Keys[0].Segments
                    begin
                        if (segment.Field == field.OriginalName)
                        begin
                            isPkSegment = true
                            exitloop
                        end
                    end
                end
                mreturn isPkSegment
            end
            mreturn EvaluateFieldLoopExpression(tkn, template, loops, doEvaluate)
        endmethod

        private static method evaluateFieldPrecision, boolean
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            lambda doEvaluate(str, field, index) (field.Precision > 0)
            mreturn EvaluateFieldLoopExpression(tkn, template, loops, doEvaluate)
        endmethod

        private static method evaluateFieldPrompt, boolean
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            lambda doEvaluate(str, field, index) (!String.IsNullOrWhiteSpace(field.Prompt))
            mreturn EvaluateFieldLoopExpression(tkn, template, loops, doEvaluate)
        endmethod

        private static method evaluateFieldPromptPosition, boolean
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            lambda doEvaluate(str, field, index) (((field.PromptPositionMode != RpsPositionMode.None) && (field.PromptRow > 0)) && (field.PromptColumn > 0))
            mreturn EvaluateFieldLoopExpression(tkn, template, loops, doEvaluate)
        endmethod

        private static method evaluateFieldRadioButtons, boolean
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            lambda doEvaluate(str, field, index) (field.ViewAs == RpsFieldViewAs.RadioButtons)
            mreturn EvaluateFieldLoopExpression(tkn, template, loops, doEvaluate)
        endmethod

        private static method evaluateFieldRange, boolean
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            lambda doEvaluate(str, field, index) (field.NumericRangeExists)
            mreturn EvaluateFieldLoopExpression(tkn, template, loops, doEvaluate)
        endmethod

        private static method evaluateFieldReadOnly, boolean
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            lambda doEvaluate(str, field, index) (field.ReadOnly)
            mreturn EvaluateFieldLoopExpression(tkn, template, loops, doEvaluate)
        endmethod

        private static method evaluateFieldReadWrite, boolean
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            lambda doEvaluate(str, field, index) (!field.ReadOnly)
            mreturn EvaluateFieldLoopExpression(tkn, template, loops, doEvaluate)
        endmethod

        private static method evaluateFieldRelation, boolean
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            lambda doEvaluate(str, field, index)
            begin
                ;;Return true if the field is associated with the only segment of a relations FROM key
                data rel, @RpsRelation
                foreach rel in str.Relations
                begin
                    ;;Is this relations FROM KEY based on the current field?
                    data fromKey, @RpsKey, str.Keys.FirstOrDefault(lambda(k) { k.Segments.Count==1 && k.Segments[0].SegmentType==RpsKeySegmentType.Field && k.Segments[0].field==field.Name })
                    if (fromKey != ^null)
                    begin
                        mreturn true
                    end
                end
                mreturn false
            end
            mreturn EvaluateFieldLoopExpression(tkn, template, loops, doEvaluate)
        endmethod

        private static method evaluateFieldReport, boolean
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            lambda doEvaluate(str, field, index) (!field.ExcludedByReportWriter)
            mreturn EvaluateFieldLoopExpression(tkn, template, loops, doEvaluate)
        endmethod

        private static method evaluateFieldReportCenter, boolean
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            lambda doEvaluate(str, field, index) (field.ReportJustification == RpsJustification.Center)
            mreturn EvaluateFieldLoopExpression(tkn, template, loops, doEvaluate)
        endmethod

        private static method evaluateFieldReportLeft, boolean
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            lambda doEvaluate(str, field, index) (field.ReportJustification == RpsJustification.Left)
            mreturn EvaluateFieldLoopExpression(tkn, template, loops, doEvaluate)
        endmethod

        private static method evaluateFieldReportRight, boolean
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            lambda doEvaluate(str, field, index) (field.ReportJustification == RpsJustification.Right)
            mreturn EvaluateFieldLoopExpression(tkn, template, loops, doEvaluate)
        endmethod

        private static method evaluateFieldRequired, boolean
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            lambda doEvaluate(str, field, index) (field.Required)
            mreturn EvaluateFieldLoopExpression(tkn, template, loops, doEvaluate)
        endmethod

        private static method evaluateFieldReverse, boolean
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            lambda doEvaluate(str, field, index) (field.RenditionReverse)
            mreturn EvaluateFieldLoopExpression(tkn, template, loops, doEvaluate)
        endmethod

        private static method evaluateFieldSelections, boolean
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            lambda doEvaluate(str, field, index) (field.SelectionList.Count > 0)
            mreturn EvaluateFieldLoopExpression(tkn, template, loops, doEvaluate)
        endmethod

        private static method evaluateFieldSelWnd, boolean
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            lambda doEvaluate(str, field, index) (!String.IsNullOrWhiteSpace(field.SelectionWindowName))
            mreturn EvaluateFieldLoopExpression(tkn, template, loops, doEvaluate)
        endmethod

        private static method evaluateFieldStructField, boolean
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            lambda doEvaluate(str, field, index) (field.DataType == RpsFieldDataType.StructField)
            mreturn EvaluateFieldLoopExpression(tkn, template, loops, doEvaluate)
        endmethod

        private static method evaluateFieldTextBox, boolean
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            lambda doEvaluate(str, field, index) ((field.ViewAs == RpsFieldViewAs.Field) && (field.SelectionList.Count == 0))
            mreturn EvaluateFieldLoopExpression(tkn, template, loops, doEvaluate)
        endmethod

        private static method evaluateFieldTime, boolean
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            lambda doEvaluate(str, field, index)
            begin
                using field.DataTypeSubclass select
                (RpsFieldSubclass.TimeHHMM,RpsFieldSubclass.TimeHHMMSS),
                    mreturn true
                (),
                    mreturn false
                endusing
            end
            mreturn EvaluateFieldLoopExpression(tkn, template, loops, doEvaluate)
        endmethod

        private static method evaluateFieldTimeHHMM, boolean
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            lambda doEvaluate(str, field, index) ((field.TypeName == "TIME" || field.TypeName == "NULLABLEDATETIME") && field.DataTypeSubclass == RpsFieldSubclass.TimeHHMM)
            mreturn EvaluateFieldLoopExpression(tkn, template, loops, doEvaluate)
        endmethod

        private static method evaluateFieldTimeHHMMSS, boolean
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            lambda doEvaluate(str, field, index) ((field.TypeName == "TIME" || field.TypeName == "NULLABLEDATETIME") && field.DataTypeSubclass == RpsFieldSubclass.TimeHHMMSS)
            mreturn EvaluateFieldLoopExpression(tkn, template, loops, doEvaluate)
        endmethod

        private static method evaluateFieldTimeNow, boolean
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            lambda doEvaluate(str, field, index) (field.TimeDefaultNow)
            mreturn EvaluateFieldLoopExpression(tkn, template, loops, doEvaluate)
        endmethod

        private static method evaluateFieldTimeout, boolean
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            lambda doEvaluate(str, field, index) (field.InputTimeoutMode != RpsFieldTimeout.None)
            mreturn EvaluateFieldLoopExpression(tkn, template, loops, doEvaluate)
        endmethod

        private static method evaluateFieldToolkit, boolean
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            lambda doEvaluate(str, field, index) (!field.ExcludedByToolkit)
            mreturn EvaluateFieldLoopExpression(tkn, template, loops, doEvaluate)
        endmethod

        private static method evaluateFieldUnderline, boolean
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            lambda doEvaluate(str, field, index) (field.RenditionUnderline)
            mreturn EvaluateFieldLoopExpression(tkn, template, loops, doEvaluate)
        endmethod

        private static method evaluateFieldUppercase, boolean
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            lambda doEvaluate(str, field, index) (field.Uppercase)
            mreturn EvaluateFieldLoopExpression(tkn, template, loops, doEvaluate)
        endmethod

        ;;; <summary>
        ;;; Determine if the field is a key segment in any relation.
        ;;; </summary>
        ;;; <param name="tkn"></param>
        ;;; <param name="template"></param>
        ;;; <param name="loops"></param>
        ;;; <returns>True if the field is involved in a relation.</returns>
        private static method evaluateFieldUsedInRelation, boolean
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            lambda doEvaluate(str, field, index)
            begin
                data fld, @RpsField, field
                data st, @RpsStructure, str
                data rl, @RpsRelation
                foreach rl in st.Relations
                begin
                    data ky, @RpsKey
                    foreach ky in st.Keys
                    begin
                        data sg, @RpsKeySegment
                        foreach sg in ky.Segments
                        begin
                            if (sg.SegmentType == RpsKeySegmentType.Field && sg.Field.Equals(fld.Name))
                            begin
                                mreturn true
                            end
                        end
                    end
                end
                mreturn false
            end
            mreturn EvaluateFieldLoopExpression(tkn, template, loops, doEvaluate)
        endmethod

        private static method evaluateFieldUser, boolean
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            lambda doEvaluate(str, field, index) (field.DataType == RpsFieldDataType.User)
            mreturn EvaluateFieldLoopExpression(tkn, template, loops, doEvaluate)
        endmethod

        private static method evaluateFieldUserType, boolean
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            lambda doEvaluate(str, field, index) (!String.IsNullOrWhiteSpace(field.UserFieldType))
            mreturn EvaluateFieldLoopExpression(tkn, template, loops, doEvaluate)
        endmethod

        private static method evaluateFieldUserText, boolean
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            lambda doEvaluate(str, field, index) (!String.IsNullOrWhiteSpace(field.UserText))
            mreturn EvaluateFieldLoopExpression(tkn, template, loops, doEvaluate)
        endmethod

        private static method evaluateFieldUserTimeStamp, boolean
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            lambda doEvaluate(str, field, index) (((field.DataType == RpsFieldDataType.User) && (field.DataTypeSubclass == RpsFieldSubclass.UserDate)) && (field.UserFieldType == "^CLASS^=YYYYMMDDHHMISSUUUUUU"))
            mreturn EvaluateFieldLoopExpression(tkn, template, loops, doEvaluate)
        endmethod

        private static method evaluateFieldViewLength, boolean
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            lambda doEvaluate(str, field, index) (field.ViewLength > 0)
            mreturn EvaluateFieldLoopExpression(tkn, template, loops, doEvaluate)
        endmethod

        private static method evaluateFieldWeb, boolean
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            lambda doEvaluate(str, field, index) (!field.ExcludedByWeb)
            mreturn EvaluateFieldLoopExpression(tkn, template, loops, doEvaluate)
        endmethod

        ;; -------------------------------------------------------------------------------------------------------------------------------
        ;; Custom field loop expressions

        private static method evaluateFieldCustom, boolean
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc

            lambda doEvaluate(str, field, index)
            begin
                ;; Extract the search text from the token
                data searchText, string, tkn.Value.ToUpper().Replace("CUSTOM_NOT_", "").Replace("CUSTOM_", "")

                ;; Make sure we have search text
                if (String.IsNullOrWhiteSpace(searchText))
                    throw new ApplicationException(String.Format("Invalid custom field expression token {0} at line {1} in template {2}", tkn.Value, tkn.StartLineNumber, template.Context.CurrentTemplateBaseName))

                ;; Is it there?
                data found, boolean, ((field.UserText.ToUpper().Contains(searchText)) || (field.LongDescription.ToUpper().Contains(searchText)))

                ;; Return the result
                mreturn tkn.Value.StartsWith("CUSTOM_NOT_") ? !found : found
            end

            ;; We get here for any field loop expression <IF CUSTOM_xxx> or <IF_CUSTOM_NOT_xxx> and we are
            ;; looking for text to be or not to be present in the current fields user text or long description.
            mreturn EvaluateFieldLoopExpression(tkn, template, loops, doEvaluate)

        endmethod

    endclass

endnamespace
