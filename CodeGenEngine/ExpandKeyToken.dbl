;;*****************************************************************************
;;
;; Title:       ExpandKeyToken.dbl
;;
;; Type:        Function
;;
;; Description: Expands key loop tokens
;;
;; Date:        5th November 2009
;;
;; Author:      Steve Ives, Synergex Professional Services Group
;;              http://www.synergex.com
;;
;;*****************************************************************************
;;
;; Copyright (c) 2012, Synergex International, Inc.
;; All rights reserved.
;;
;; Redistribution and use in source and binary forms, with or without
;; modification, are permitted provided that the following conditions are met:
;;
;; * Redistributions of source code must retain the above copyright notice,
;;   this list of conditions and the following disclaimer.
;;
;; * Redistributions in binary form must reproduce the above copyright notice,
;;   this list of conditions and the following disclaimer in the documentation
;;   and/or other materials provided with the distribution.
;;
;; THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
;; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
;; IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
;; ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
;; LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
;; CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
;; SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
;; INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
;; CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
;; ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
;; POSSIBILITY OF SUCH DAMAGE.
;;
;;*****************************************************************************

import CodeGen.Engine
import CodeGen.RepositoryAPI

namespace CodeGen.Engine

    function ExpandKeyToken         ,boolean

        required in Str                 ,@RpsStructure
        required in Key                 ,@RpsKey
        required in KeyNbr              ,int
        required in TokenStart          ,int
        required in TokenEnd            ,int
        required in PrimaryKeyOnly      ,boolean
        required inout buffer           ,a
        endparams

        stack record local_data
            ReplacedToken   ,boolean
        endrecord

    proc

        init local_data

        using buffer(TokenStart,TokenEnd) select

        ("<,>"),
        begin
            data tmpTxt, a1, " "
            if (!PrimaryKeyOnly&&(KeyNbr<Str.Keys.Count-1))
                tmpTxt=","
            ReplacedToken = ReplaceToken(buffer,"<,>",tmpTxt)
        end

        ("<+>"),
        begin
            data tmpTxt, a1, " "
            if (!PrimaryKeyOnly&&(KeyNbr<Str.Keys.Count-1))
                tmpTxt="+"
            ReplacedToken = ReplaceToken(buffer,"<+>",tmpTxt)
        end

        ("<:>"),
        begin
            data tmpTxt, a1, " "
            if (!PrimaryKeyOnly&&(KeyNbr<Str.Keys.Count-1))
                tmpTxt=":"
            ReplacedToken = ReplaceToken(buffer,"<:>",tmpTxt)
        end

        ("<&&>"),
        begin
            data tmpTxt, a2, "  "
            if (!PrimaryKeyOnly&&(KeyNbr<Str.Keys.Count-1))
                tmpTxt="&&"
            ReplacedToken = ReplaceToken(buffer,"<&&>",tmpTxt)
        end

        ("<.AND.>"),
        begin
            data tmpTxt, a5, "     "
            if (!PrimaryKeyOnly&&(KeyNbr<Str.Keys.Count-1))
                tmpTxt=".AND."
            ReplacedToken = ReplaceToken(buffer,"<.AND.>",tmpTxt)
        end

        ("<AND>"),
        begin
            data tmpTxt, a3, "   "
            if (!PrimaryKeyOnly&&(KeyNbr<Str.Keys.Count-1))
                tmpTxt="AND"
            ReplacedToken = ReplaceToken(buffer,"<AND>",tmpTxt)
        end

        ("<||>"),
        begin
            data tmpTxt, a2, "  "
            if (!PrimaryKeyOnly&&(KeyNbr<Str.Keys.Count-1))
                tmpTxt="||"
            ReplacedToken = ReplaceToken(buffer,"<||>",tmpTxt)
        end

        ("<.OR.>"),
        begin
            data tmpTxt, a4, "    "
            if (!PrimaryKeyOnly&&(KeyNbr<Str.Keys.Count-1))
                tmpTxt=".OR."
            ReplacedToken = ReplaceToken(buffer,"<.OR.>",tmpTxt)
        end

        ("<OR>"),
        begin
            data tmpTxt, a2, "  "
            if (!PrimaryKeyOnly&&(KeyNbr<Str.Keys.Count-1))
                tmpTxt="OR"
            ReplacedToken = ReplaceToken(buffer,"<OR>",tmpTxt)
        end

        ("<KEY_NUMBER>"),
            ReplacedToken = ReplaceToken(buffer,"<KEY_NUMBER>",string(KeyNbr))

        ("<KEY_NAME>","<KeyName>"),
        begin
            data KeyNameToken, a10
            data tmpname, a30
            KeyNameToken=buffer(TokenStart,TokenEnd)
            using KeyNameToken select
            ("<KEY_NAME>"),
                tmpname=Key.Name
            ("<KeyName>"),
                tmpname=PascalCase(Key.Name)
            endusing
            ReplacedToken = ReplaceToken(buffer,KeyNameToken,tmpname)
        end

        ("<KEY_NULLTYPE>","<key_nulltype>"),
        begin
            data tmpToken   ,a14
            data tmpValue   ,a11
            tmpToken = buffer(TokenStart,TokenEnd)
            using Key.NullKey select
            (RpsKeyNullType.None),
                tmpValue = "NONE"
            (RpsKeyNullType.Replicating),
                tmpValue = "REPLICATE"
            (RpsKeyNullType.NonReplicating),
                tmpValue = "NOREPLICATE"
            (RpsKeyNullType.Short),
                tmpValue = "SHORT"
            endusing
            if (tmpToken=="<key_nulltype>")
                locase tmpValue
            ReplacedToken = ReplaceToken(buffer,tmpToken,tmpValue)
        end

        ("<KEY_NULLVALUE>"),
            ReplacedToken = ReplaceToken(buffer,"<KEY_NULLVALUE>",Key.NullKeyValue)

        ("<KEY_DENSITY>"),
            ReplacedToken = ReplaceToken(buffer,"<KEY_DENSITY>",string(Key.Density))

        ("<KEY_DESCRIPTION>"),
            ReplacedToken = ReplaceToken(buffer,"<KEY_DESCRIPTION>",Key.Description)

        ("<KEY_LENGTH>"),
            ReplacedToken = ReplaceToken(buffer,"<KEY_LENGTH>",string(Key.Size))

        ("<KEY_ORDER>"),
            begin
                using Key.SortOrder select
                (RpsKeyOrder.Ascending),
                    ReplacedToken = ReplaceToken(buffer,"<KEY_ORDER>","ASC")
                (RpsKeyOrder.Descending),
                    ReplacedToken = ReplaceToken(buffer,"<KEY_ORDER>","DESC")
                endusing
            end

        ("<KEY_DUPLICATES>"),
            begin
                using Key.Duplicates select
                (RpsKeyDuplicates.Duplicates),
                    ReplacedToken = ReplaceToken(buffer,"<KEY_DUPLICATES>","DUPLICATES")
                (RpsKeyDuplicates.NoDuplicates),
                    ReplacedToken = ReplaceToken(buffer,"<KEY_DUPLICATES>","UNIQUE")
                endusing
            end

        ("<KEY_UNIQUE>"),
            begin
                using Key.Duplicates select
                (RpsKeyDuplicates.NoDuplicates),
                    ReplacedToken = ReplaceToken(buffer,"<KEY_UNIQUE>","UNIQUE")
                (RpsKeyDuplicates.Duplicates),
                    ReplacedToken = ReplaceToken(buffer,"<KEY_UNIQUE>","")
                endusing
            end
        ("<KEY_DUPLICATES_AT>"),
            begin
                using Key.InsertDuplicates select
                (RpsKeyInsertDups.AtFront),
                    ReplacedToken = ReplaceToken(buffer,"<KEY_DUPLICATES_AT>","FRONT")
                (RpsKeyInsertDups.AtEnd),
                    ReplacedToken = ReplaceToken(buffer,"<KEY_DUPLICATES_AT>","END")
                endusing
            end

        ("<KEY_CHANGES>"),
            begin
                if (Key.Modifiable) then
                    ReplacedToken = ReplaceToken(buffer,"<KEY_CHANGES>","CHANGES")
                else
                    ReplacedToken = ReplaceToken(buffer,"<KEY_CHANGES>","NOCHANGES")
            end

        ("<KEY_SEGMENTS>"),
            ReplacedToken = ReplaceToken(buffer,"<KEY_SEGMENTS>",string(Key.Segments.Count))

		(),
		begin
			;;If we didn't match anything so far then lets see if we have any custom key loop token processors
			if (Env.CustomKeyTokens.Count>0)
			begin
				;;We do have custom processors, look for a match
				data customToken, @CustomKeyTokenProcessor
				foreach customToken in Env.CustomKeyTokens
				begin
					if (customToken.Token==buffer(TokenStart,TokenEnd))
					begin
						;;Found a match, expand the custom token
						ReplacedToken = customToken.Replace(Str,Key,KeyNbr,TokenStart,TokenEnd,PrimaryKeyOnly,buffer)
						exitloop
					end
				end
			end
		end
		
		endusing

        freturn ReplacedToken

    endfunction

endnamespace
