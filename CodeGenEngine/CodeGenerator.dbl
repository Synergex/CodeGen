;;*****************************************************************************
;;
;; Title:       CodeGenerator.dbl
;;
;; Type:        Class
;;
;; Description: In-process callable interface to CodeGen
;;
;; Date:        
;;
;; Author:      Steve Ives, Synergex Professional Services Group
;;              http://www.synergex.com
;;
;;*****************************************************************************
;;
;; Copyright (c) 2012, Synergex International, Inc.
;; All rights reserved.
;;
;; Redistribution and use in source and binary forms, with or without
;; modification, are permitted provided that the following conditions are met:
;;
;; * Redistributions of source code must retain the above copyright notice,
;;   this list of conditions and the following disclaimer.
;;
;; * Redistributions in binary form must reproduce the above copyright notice,
;;   this list of conditions and the following disclaimer in the documentation
;;   and/or other materials provided with the distribution.
;;
;; THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
;; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
;; IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
;; ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
;; LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
;; CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
;; SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
;; INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
;; CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
;; ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
;; POSSIBILITY OF SUCH DAMAGE.
;;
;;*****************************************************************************

import CodeGen.Engine
import CodeGen.MethodCatalogAPI
import CodeGen.RepositoryAPI
import Microsoft.Win32
import Newtonsoft.Json
import Newtonsoft.Json.Serialization
import System
import System.Collections
import System.Collections.Generic
import System.Collections.ObjectModel
import System.IO
import System.Linq
import System.Reflection
import System.Text

.array 0

namespace CodeGen.Engine

    .include "CODEGEN_SRC:codegen.def"

    public sealed class CodeGenerator

        private context,                    @CodeGenContext
        private readonly originalRpsmain,   String
        private readonly originalRpstext,   String

        public method CodeGenerator
            required in taskset,            @CodeGenTaskSet
            default in aContext,            @CodeGenContext, ^null
        proc

            context = aContext ?? new CodeGenContext(taskset)

            ;;If we're in developer debug or verbose modes then display the heading
            if (context.DeveloperDebugLoggingEnabled || (context.VerboseLoggingEnabled))
                taskset.VerboseLog(String.Format("CodeGen {0}",CODEGEN_VERSION), true, false)

            ;;Remember the original repository that was set before we changed anything
            originalRpsmain = Environment.GetEnvironmentVariable("RPSMFIL")
            originalRpstext = Environment.GetEnvironmentVariable("RPSTFIL")

            ;;Set the main environment variables (CODEGEN_EXE, CODEGEN_TPLDIR, CODEGEN_OUTDIR, CODEGEN_AUTHOR and CODEGEN_COMPANY)
            configureEnvironment()

            ;;Load Harmony Core extensions
            loadHarmonyCoreExtensions(context)

            ;;Load other extensions
            loadExtensions(context)

            ;;Report loaded extensions
            if (context.DeveloperDebugLoggingEnabled)
                reportLoadedExtensions()

        endmethod

        private method configureEnvironment, void
            .include "CODEGEN_SRC:codegen.def"
        proc
            ;;Explicitly set CODEGEN_EXE to the path containing this code (CodeGenEngine.dll).
.ifdef D_NETSTANDARD
            ;TODO: BUG: 4/12/2018 Using SetEnvironmentVariable seems to cause some issues in .NET Core
            data sts, i4
            xcall setlog("CODEGEN_EXE",Path.GetDirectoryName(System.Reflection.Assembly.GetAssembly(^typeof(CodeGenerator)).Location),sts)
.else
            Environment.SetEnvironmentVariable("CODEGEN_EXE",Path.GetDirectoryName(System.Reflection.Assembly.GetAssembly(^typeof(CodeGenerator)).Location))
.endc

            ;;Make the current version number available in the expander
            context.Version = CODEGEN_VERSION

.ifndef D_NETSTANDARD
            ;;Is CODEGEN_TPLDIR already set in the environment?
            data templateFolder = Environment.GetEnvironmentVariable("CODEGEN_TPLDIR")
            if (String.IsNullOrWhiteSpace(templateFolder))
            begin
                ;;No, look in the registry for the value set by InstallShield
                templateFolder = (String)Registry.GetValue("HKEY_LOCAL_MACHINE\SOFTWARE\Synergex\CodeGen","TemplatePath","")
                if (!String.IsNullOrWhiteSpace(templateFolder)) then
                begin
                    ;;Found it
.ifdef D_NETSTANDARD
                    ;TODO: BUG: 4/12/2018 Using SetEnvironmentVariable seems to cause some issues in .NET Core
                    data sts, i4
                    xcall setlog("CODEGEN_TPLDIR",templateFolder.Trim(),sts)
.else
                    Environment.SetEnvironmentVariable("CODEGEN_TPLDIR",templateFolder.Trim())
.endc
                end
                else if (Environment.Is64BitProcess)
                begin
                    ;;Not found. If we're a 64-bit process then try looking in the 32-bit registry
                    templateFolder = (String)Registry.GetValue("HKEY_LOCAL_MACHINE\SOFTWARE\Wow6432Node\Synergex\CodeGen","TemplatePath","")
                    if (!String.IsNullOrWhiteSpace(templateFolder))
                    begin
                        ;;Found it
.ifdef D_NETSTANDARD
                        ;TODO: BUG: 4/12/2018 Using SetEnvironmentVariable seems to cause some issues in .NET Core
                        data sts, i4
                        xcall setlog("CODEGEN_TPLDIR",templateFolder.Trim(),sts)
.else
                        Environment.SetEnvironmentVariable("CODEGEN_TPLDIR",templateFolder.Trim())
.endc
                    end
                end
            end
.endc
            ;;Is CODEGEN_AUTHOR already set in the environment?
            data authorName = Environment.GetEnvironmentVariable("CODEGEN_AUTHOR")
            if (!String.IsNullOrWhiteSpace(authorName)) then
                context.Author = authorName
            else
            begin
.ifndef D_NETSTANDARD
                ;;No, look in the registry for the value set by InstallShield
                authorName = (String)Registry.GetValue("HKEY_LOCAL_MACHINE\SOFTWARE\Synergex\CodeGen","DefaultAuthor","")
                if (!String.IsNullOrWhiteSpace(authorName)) then
                    context.Author = authorName
                else if (Environment.Is64BitProcess)
                begin
                    ;;Not found. If we're a 64-bit process then try looking in the 32-bit registry
                    authorName = (String)Registry.GetValue("HKEY_LOCAL_MACHINE\SOFTWARE\Wow6432Node\Synergex\CodeGen","DefaultAuthor","")
                    if (!String.IsNullOrWhiteSpace(authorName))
                        context.Author = authorName
                end
.endc
            end

            ;;Is CODEGEN_COMPANY already set in the environment?
            data companyName = Environment.GetEnvironmentVariable("CODEGEN_COMPANY")
            if (!String.IsNullOrWhiteSpace(companyName)) then
                context.Company = companyName
            else
            begin
.ifndef D_NETSTANDARD
                ;;No, look in the registry for the value set by InstallShield
                companyName = (String)Registry.GetValue("HKEY_LOCAL_MACHINE\SOFTWARE\Synergex\CodeGen","DefaultCompany","")
                if (!String.IsNullOrWhiteSpace(companyName)) then
                    context.Company = companyName
                else if (Environment.Is64BitProcess)
                begin
                    ;;Not found. If we're a 64-bit process then try looking in the 32-bit registry
                    companyName = (String)Registry.GetValue("HKEY_LOCAL_MACHINE\SOFTWARE\Wow6432Node\Synergex\CodeGen","DefaultCompany","")
                    if (!String.IsNullOrWhiteSpace(companyName))
                        context.Company = companyName
                end
.endc
            end

        endmethod

        public static method LoadHarmonyCoreExtensions, void
            required in context, @CodeGenContext
        proc
            context.Taskset.DevDebugLog("----------------------------------------------------------")
            context.Taskset.DevDebugLog("HARMONY CORE EXTENSIONS")

            ;;Look for the extensions assembly in the same folder as CodeGen
            data codeBaseUri = new UriBuilder(Assembly.GetExecutingAssembly().CodeBase)
            data harmonyLocation = Path.GetDirectoryName(Uri.UnescapeDataString(codeBaseUri.Path))
            data extensionsAssembly = Path.Combine(harmonyLocation,"HarmonyCoreExtensions.dll")

            if (File.Exists(extensionsAssembly)) then
            begin
                ;;Report the extensions assembly we're going to use
                context.Taskset.DevDebugLog(String.Format("Found Harmony Core extensions assembly {0}",extensionsAssembly))	

                ;;Open the assembly and load extensions
                if (!loadExtensionsFromAssembly(extensionsAssembly,context))
                    context.Taskset.DevDebugLog("No extension classes were found in the extensions assembly!")					
            end
            else
            begin
                context.Taskset.DevDebugLog("No Harmony Core extensions assembly was found!")
            end

            context.Taskset.DevDebugLog("Finished loading Harmony Core extensions.")

        endmethod

        public static method LoadExtensions, void
            required in context, @CodeGenContext
        proc
            context.Taskset.DevDebugLog("----------------------------------------------------------")
            context.Taskset.DevDebugLog("OTHER EXTENSIONS")

            ;;Do we have a CODEGEN_EXTDIR environment variable?
            data location = Environment.GetEnvironmentVariable("CODEGEN_EXTDIR")
            if (!string.IsNullOrWhiteSpace(location))
            begin
                if (!Directory.Exists(location))
                begin
                    context.Taskset.DevDebugLog("Ignoring extensions location specified by CODEGEN_EXTDIR because the location does not exist")
                    location = String.Empty
                end
            end

            if (String.IsNullOrWhiteSpace(location))
            begin
                ;;No CODEGEN_EXTDIR so we'll use CODEGEN_EXE which is ALWAYS defined
                location = Environment.GetEnvironmentVariable("CODEGEN_EXE")
            end

            context.Taskset.DevDebugLog("Searching for extensions in " + location)

            data extensionAssembly, String
            data extensionsFound = false

            foreach extensionAssembly in Directory.GetFiles(location,"custom*.dll")
            begin
                if (loadExtensionsFromAssembly(extensionAssembly,context))
                    extensionsFound = true
            end

            if (!extensionsFound)
                context.Taskset.DevDebugLog("No extensions found")

            context.Taskset.DevDebugLog("Finished loading extensions")

        endmethod

        public static method LoadProformaExtensions, boolean
            required in context, @CodeGenContext
        proc
            data errStatus = false

            ;;-------------------------------------------------------------------------
            ;;Do we have a custom assembly containing a BusinessCreft ProForma processor?

            context.Taskset.DevDebugLog("Attempting to load BusinessCraft Proforma extensions")

            ;;Do we have a CODEGEN_EXTDIR environment variable?
            data location = Environment.GetEnvironmentVariable("CODEGEN_EXTDIR")
            if (String.IsNullOrWhiteSpace(location))
            begin
                ;;No CODEGEN_EXTDIR so we'll use CODEGEN_EXE which is ALWAYS defined
                location = Environment.GetEnvironmentVariable("CODEGEN_EXE")
            end

            ;;Setup a file spec to locate custom token processor extensions
            data extensionsAssembly = Path.Combine(location,"CodeGenProForma.dll")

            ;;Search for and open custom token processor extensions
            if (!File.Exists(extensionsAssembly)) then
                errStatus = context.Taskset.Errorlog(String.Format("Proforma assembly {0} not found!",extensionsAssembly))
            else
            begin
                ;;Open the assembly and load extensions
                if (!loadExtensionsFromAssembly(extensionsAssembly,context))
                    errStatus = context.Taskset.ErrorLog("No extensions were found in the proforma extensions assembly!")					
            end

            mreturn !errStatus

        endmethod

        private static method LoadExtensionsFromAssembly, boolean
            required in extensionAssembly, string
            required in context, @CodeGenContext
        proc
            data ok = true
            data extensionsLoaded = 0

            ;;Open the assembly
            data asm, @Assembly
            try
            begin
                asm = Assembly.LoadFrom(extensionAssembly)
            end
            catch (e, @System.IO.FileLoadException)
            begin
                data messageToReport = (e.InnerException!=^null) ? e.InnerException.Message : e.Message
                context.Taskset.Warning(String.Format("Failed to activate extensions assembly {0}. Error was: {1}.",Path.GetFileName(extensionAssembly),messageToReport))
                ok = false
            end
            catch (e, @Exception)
            begin
                context.Taskset.Warning(String.Format("Failed to activate extensions assembly {0}. Error was: {1}.",Path.GetFileName(extensionAssembly),e.Message))
                ok = false
            end
            endtry

            if (ok)
            begin
                context.Taskset.DevDebugLog(String.Format("Opened assembly {0}",extensionAssembly))

                ;;Look through all the types in the assembly searching for types that implement
                ;;IExpansionToken or IExpressionToken and record them in the extension collections.

                data discoveredType, @Type
                data discoveredTypes, [#]@Type

                try
                begin
                    discoveredTypes = asm.GetTypes()
                end
                catch (ex, @ReflectionTypeLoadException)
                begin

                    data sb = new StringBuilder()
                    data exSub, @Exception
                    foreach exSub in ex.LoaderExceptions
                    begin
                        sb.AppendLine(exSub.Message)
                        sb.AppendLine()
                    end
                    context.Taskset.Warning(String.Format("Failed to load extensions from assembly {0}. Error was {1}.",Path.GetFileName(extensionAssembly),sb.ToString()))
                    ok = false
                end
                endtry

                if (!ok)
                    exit

                foreach discoveredType in discoveredTypes
                begin
                    data discoveredInterfaces, [#]@Type, discoveredType.GetInterfaces()
                    if (discoveredInterfaces.Length)
                    begin
                        ;;The type we found implements at least one interface
                        data interfaceType, @Type
                        foreach interfaceType in discoveredInterfaces
                        begin
                            if (interfaceType==^typeof(IExpansionToken)&&(discoveredType.GetConstructor(Type.EmptyTypes)!=^null)) then
                            begin
                                data expander, @IExpansionToken, (@IExpansionToken)Activator.CreateInstance(discoveredType)
                                context.CustomTokenExpanders.Add(Tuple.Create(expander.TokenName,expander.Description,expander.Validity,expander.TokenCase,(@Func<Token, FileNode, IEnumerable<LoopNode>, String>)expander.Expand))
                                extensionsLoaded += 1
                                exitloop
                            end
                            else if (interfaceType==^typeof(IExpressionToken)&&(discoveredType.GetConstructor(Type.EmptyTypes)!=^null))
                            begin
                                data evaluator, @IExpressionToken, (@IExpressionToken)Activator.CreateInstance(discoveredType)
                                context.CustomExpressionEvaluators.Add(Tuple.Create(evaluator.TokenName,evaluator.Description,evaluator.Validity,(@Func<Token, FileNode, IEnumerable<LoopNode>, Boolean>)evaluator.Evaluate))
                                extensionsLoaded += 1
                                exitloop
                            end
                        end
                    end
                end
            end

            mreturn (extensionsLoaded > 0)

        endmethod

        private method reportLoadedExtensions, void
        proc
            context.Taskset.DevDebugLog("----------------------------------------------------------")
            context.Taskset.DevDebugLog("SUMMARY OF LOADED EXTENSIONS")

            if (context.CustomTokenExpanders.Count>0) then
            begin
                context.Taskset.DevDebugLog(" - Custom tokens have been loaded:")
                if (context.DeveloperDebugLoggingEnabled)
                begin
                    data expander, @Tuple<String,String,TokenValidity,TokenCaseMode,Func<Token, FileNode, IEnumerable<LoopNode>, String>>
                    foreach expander in context.CustomTokenExpanders
                        context.Taskset.DevDebugLog("   <" + expander.Item1 + ">")
                end
            end
            else
                context.Taskset.DevDebugLog(" - No custom tokens have been loaded")

            if (context.CustomExpressionEvaluators.Count>0) then
            begin
                context.Taskset.DevDebugLog(" - Custom expressions have been loaded:")
                if (context.DeveloperDebugLoggingEnabled)
                begin
                    data evaluator, @Tuple<String,String,TokenValidity,Func<Token, FileNode, IEnumerable<LoopNode>, Boolean>>
                    foreach evaluator in context.CustomExpressionEvaluators
                        context.Taskset.DevDebugLog("   <" + evaluator.Item1 + ">")
                end
            end
            else
                context.Taskset.DevDebugLog(" - No custom expressions have been loaded")

        endmethod

        private method loadMethodCatalog, boolean
        proc
            ;; NOTE: We only get here if a method catalog XML file is specified in context.CurrentTask.MethodCatalogFile

            ;;--------------------------------------------------------------------------------------
            ;;Load the method catalog from the XML file

            if (context.MethodCatalog != ^null && !String.IsNullOrWhiteSpace(context.MethodCatalogLastFile) && context.MethodCatalogLastFile == context.CurrentTask.MethodCatalogFile && !context.MethodCatalogCustomized) then
            begin
                ;;We can use the same SMC that we used for the last task
            end
            else
            begin
                ;;We need to load the method catalog from scratch
                try
                begin
                    context.MethodCatalog = new Smc(context.CurrentTask.MethodCatalogFile)
                end
                catch (ex, @Exception)
                begin
                    mreturn context.CurrentTask.ErrorLog(String.Format("Failed to load method catalog. {0}",ex.Message))
                end
                endtry
            end

            ;;--------------------------------------------------------------------------------------
            ;; This code was previously included in the -smc command line processing.

            if (!context.CurrentTask.MethodCatalogStructureMode)
            begin
                ;;Are we processing a single interface?
                if (!String.IsNullOrWhiteSpace(context.CurrentTask.MethodCatalogInterface))
                begin
                    ;;Make sure it exists in the catalog
                    data selectedInterface = context.MethodCatalog.Interfaces.FirstOrDefault(lambda(intf) {intf.Name.ToUpper()==context.CurrentTask.MethodCatalogInterface.ToUpper()})
                    if (selectedInterface == ^null)
                    begin
                        mreturn context.CurrentTask.ErrorLog(String.Format("Interface {0} was not found in the method catalog!",context.CurrentTask.MethodCatalogInterface))
                    end
 
                    ;;And remove all other interfaces
                    context.MethodCatalog.Interfaces.RemoveAll(lambda(intf) {intf!=selectedInterface})
                    context.MethodCatalogCustomized = true
                end
            end

            ;;--------------------------------------------------------------------------------------
            ;; This code was previously included in the -smcstrs command line processing.
            ;; Now the method catalog file is in context.MethodCatalogFile and if in structures mode
            ;; the context.MethodCatalogStructureMode property will be true.

            if (context.CurrentTask.MethodCatalogStructureMode)
            begin
                ;;If we have an interface name, make sure it exists in the catalog
                if (!String.IsNullOrWhiteSpace(context.CurrentTask.MethodCatalogInterface))
                begin
                    if (context.MethodCatalog.Interfaces.FirstOrDefault(lambda(i) {i.Name==context.CurrentTask.MethodCatalogInterface}) == ^null)
                    begin
                        mreturn context.CurrentTask.ErrorLog(String.Format("Interface {0} was not found in the method catalog!",context.CurrentTask.MethodCatalogInterface))
                    end
                end
                
                if (context.MethodCatalog.Structures.Count == 0)
                begin
                    mreturn context.CurrentTask.ErrorLog("Method catalog export file contains no structures!")
                end

                ;;So the method catalog has structutures, but does our interface reference any?

                data str, @RpsStructure
                foreach str in context.MethodCatalog.Structures
                begin
                    if (String.IsNullOrWhiteSpace(context.CurrentTask.MethodCatalogInterface)) then
                    begin
                        ;;No interface specified, process all structures in the SMC
                        context.CurrentTask.Structures.Add(str.Name)
                    end
                    else
                    begin
                        ;;Interface specified, process only those structures in the SMC that are used by the interface.
                        data i, @SmcInterface, context.MethodCatalog.Interfaces.First(lambda(if) {if.Name==context.CurrentTask.MethodCatalogInterface})

                        data m, @SmcMethod
                        foreach m in i.Methods
                        begin
                            data p, @SmcParameter
                            foreach p in m.Parameters
                            begin
                                if ( !String.IsNullOrWhiteSpace(p.StructureName) && !context.CurrentTask.Structures.Contains(p.StructureName) )
                                begin
                                    context.CurrentTask.Structures.Add(p.StructureName)
                                end
                            end
                        end
                    end
                end

                if (context.CurrentTask.Structures.Count == 0)
                begin
                    ;;Interface does not reference any structures!
                    context.CurrentTask.Log("INFO: Method catalog interface references no structures!")
                    mreturn true
                end
            end

            ;;--------------------------------------------------------------------------------------
            ;; This code was previously part of the -iloop command line option processing

            if (context.CurrentTask.MethodCatalogInterfaces != ^null)
            begin
                data newInterfaceCollection = new List<SmcInterface>()
                data interfaceToInclude, @SmcInterface
                data candidateInterfaceName, string
                foreach candidateInterfaceName in context.CurrentTask.MethodCatalogInterfaces
                begin
                    interfaceToInclude = context.MethodCatalog.Interfaces.FirstOrDefault(lambda(iface) {iface.Name.ToUpper().Equals(candidateInterfaceName.ToUpper())})
                    if (interfaceToInclude != ^null) then
                    begin
                        newInterfaceCollection.Add(interfaceToInclude)
                    end
                    else
                    begin
                        mreturn context.CurrentTask.ErrorLog(String.Format("Interface {0} was not found in the method catalog!",candidateInterfaceName))
                    end
                end
                context.MethodCatalog.Interfaces = newInterfaceCollection
                context.MethodCatalogCustomized = true
            end

            ;;--------------------------------------------------------------------------------------
            ;;This code was previously part of the -minclude command line option processing

            if (context.CurrentTask.MethodCatalogIncludeMethods != ^null)
            begin
                data currentInterface = context.MethodCatalog.Interfaces.First()
                data newMethodCollection = new List<SmcMethod>()
                data candidateMethodName, string

                foreach candidateMethodName in context.CurrentTask.MethodCatalogIncludeMethods
                begin
                    data methodToInclude = currentInterface.Methods.FirstOrDefault(lambda(meth) {meth.Name.ToUpper().Equals(candidateMethodName.ToUpper())})
                    if (methodToInclude != ^null) then
                    begin
                        newMethodCollection.Add(methodToInclude)
                    end
                    else
                    begin
                        mreturn context.CurrentTask.ErrorLog(String.Format("Method {0} was not found in interface {1}!",candidateMethodName,currentInterface.Name))
                    end
                end
                currentInterface.Methods = newMethodCollection
                context.MethodCatalogCustomized = true
            end

            ;;--------------------------------------------------------------------------------------
            ;;This code was previously part of the -mexclude command line option processing

            if (context.CurrentTask.MethodCatalogExcludeMethods != ^null)
            begin
                data currentInterface = context.MethodCatalog.Interfaces.First()
                data candidateMethodName, string

                foreach candidateMethodName in context.CurrentTask.MethodCatalogExcludeMethods
                begin
                    data methodToExclude = currentInterface.Methods.FirstOrDefault(lambda(meth) {meth.Name.ToUpper().Equals(candidateMethodName.ToUpper())})
                    if (methodToExclude != ^null) then
                    begin
                        currentInterface.Methods.Remove(methodToExclude)
                        context.MethodCatalogCustomized = true
                    end
                    else
                    begin
                        mreturn context.CurrentTask.ErrorLog(String.Format("Method {0} was not found in interface {1}!",candidateMethodName,currentInterface.Name))
                    end
                end
            end

        endmethod

        ;;; <summary>
        ;;; Generates code for all tasks in the current taskset.
        ;;; </summary>
        ;;; <returns>Returns true if code generation for all tasks completes successfully.</returns>
        public method GenerateCode, Boolean
        proc
            data taskSetComplete = true

            ;;Make sure we have at least one task
            if (context.Taskset.Tasks.Count == 0)
            begin
                context.Taskset.ErrorLog("Your CodeGen task set doesn't contain any tasks!")
                context.Taskset.Complete = false
                mreturn false
            end

            ;;Raise the StartingTaskSet event
            context.Taskset.RaiseStartingTaskSet()

            ;;Process each task
            data task, @CodeGenTask
            foreach task in context.Taskset.Tasks
            begin
                ;;Reset the context for the new task and specify the current task
                context.ResetTaskContext()
                context.CurrentTask = task

                ;;Raise the TaskStarting event
                task.RaiseStartingTask()

                ;;If this task defines a repository then use it. If not, and the task set has a repository, use that.
                ;;Otherwise, reset the repository to the way it was on entry
                if (!String.IsNullOrWhiteSpace(task.RepositoryMainFile) && !String.IsNullOrWhiteSpace(task.RepositoryTextFile)) then
                begin
                    if (context.DeveloperDebugLoggingEnabled)
                    begin
                        task.DevDebugLog("Repository set by TASK")
                        task.DevDebugLog(String.Format(" - Main file {0}",task.RepositoryMainFile))
                        task.DevDebugLog(String.Format(" - Text file {0}",task.RepositoryTextFile))
                    end
.ifdef D_NETSTANDARD
                    ;TODO: BUG: 4/12/2018 Using SetEnvironmentVariable seems to cause some issues in .NET Core
                    data sts, i4
                    xcall setlog("RPSMFIL",task.RepositoryMainFile,sts)
                    xcall setlog("RPSTFIL",task.RepositoryTextFile,sts)
.else
                    Environment.SetEnvironmentVariable("RPSMFIL",task.RepositoryMainFile)
                    Environment.SetEnvironmentVariable("RPSTFIL",task.RepositoryTextFile)
.endc
                end
                else if (!String.IsNullOrWhiteSpace(context.Taskset.RepositoryMainFile) && !String.IsNullOrWhiteSpace(context.Taskset.RepositoryTextFile)) then
                begin
                    if (context.DeveloperDebugLoggingEnabled)
                    begin
                        task.DevDebugLog("Repository set by TASK SET")
                        task.DevDebugLog(String.Format(" - Main file {0}",context.Taskset.RepositoryMainFile))
                        task.DevDebugLog(String.Format(" - Text file {0}",context.Taskset.RepositoryTextFile))
                    end
.ifdef D_NETSTANDARD
                    ;TODO: BUG: 4/12/2018 Using SetEnvironmentVariable seems to cause some issues in .NET Core
                    data sts, i4
                    xcall setlog("RPSMFIL",context.Taskset.RepositoryMainFile,sts)
                    xcall setlog("RPSTFIL",context.Taskset.RepositoryTextFile,sts)
.else
                    Environment.SetEnvironmentVariable("RPSMFIL",context.Taskset.RepositoryMainFile)
                    Environment.SetEnvironmentVariable("RPSTFIL",context.Taskset.RepositoryTextFile)
.endc
                end
                else
                begin
                    data mainFile = String.IsNullOrWhiteSpace(originalRpsmain) ? String.Empty : originalRpsmain
                    data textFile = String.IsNullOrWhiteSpace(originalRpstext) ? String.Empty : originalRpstext
                    if (context.DeveloperDebugLoggingEnabled)
                    begin
                        task.DevDebugLog("Repository NOT specified by TASK or TASK SET")
                        task.DevDebugLog(String.Format(" - Main file {0}",mainFile))
                        task.DevDebugLog(String.Format(" - Text file {0}",textFile))
                    end
.ifdef D_NETSTANDARD
                    ;TODO: BUG: 4/12/2018 Using SetEnvironmentVariable seems to cause some issues in .NET Core
                    data sts, i4
                    xcall setlog("RPSMFIL",mainFile,sts)
                    xcall setlog("RPSTFIL",textFile,sts)
.else
                    Environment.SetEnvironmentVariable("RPSMFIL",mainFile)
                    Environment.SetEnvironmentVariable("RPSTFIL",textFile)
.endc
                end

                ;;Generate code
                generateCodeForTask()

                ;;Record the final status of the task
                task.Complete = (task.Errors == 0) && (task.Warnings == 0)

                ;;If the task failed, then so did the overall task set
                if (!task.Complete)
                    taskSetComplete = false

                ;;Raise the TaskComplete event
                task.RaiseTaskComplete()
            end

            ;;Record if everything in the task set was completed successfully
            context.Taskset.Complete = taskSetComplete

            ;;Raise the TaskSetComplete event
            context.Taskset.RaiseTaskSetComplete()

            mreturn context.Taskset.Complete

        endmethod

        ;;;<summary>
        ;;;Generates code for a single task.
        ;;;</summary>
        private method generateCodeForTask, void
        proc

            data errStatus = false

            ;;-------------------------------------------------------------------------
            ;;Echo command line?

            if (context.Taskset.EchoCommands)
                context.CurrentTask.EchoCommand()

            ;;-------------------------------------------------------------------------
            ;;Try to load the entire repository into the current task context

            try
            begin
                context.Repository = new Repository()

                if (context.DeveloperDebugLoggingEnabled)
                begin
                    context.CurrentTask.DevDebugLog("Repository opened")
                    context.CurrentTask.DevDebugLog(String.Format(" - Main file {0}",context.Repository.MainFile))
                    context.CurrentTask.DevDebugLog(String.Format(" - Text file {0}",context.Repository.TextFile))
                end
            end
            catch (ex, @RpsException)
            begin
                ;;Failed to load a repository. If we're processing structures we're dead!
                if (context.CurrentTask.Structures.Count > 0)
                    errStatus = context.CurrentTask.ErrorLog(ex.Message)
            end
            endtry

            ;;-------------------------------------------------------------------------
            ;;If we are doing method catalog processing, configure that environment

            ;;If we are in method catalog mode, load up the catalog
            if (!errStatus && !String.IsNullOrWhiteSpace(context.CurrentTask.MethodCatalogFile))
                errStatus = loadMethodCatalog()

            ;;-------------------------------------------------------------------------
            ;;Do we have a custom data mappings file specified?

            if (!errStatus)
            begin
                if (!String.IsNullOrWhiteSpace(context.Taskset.DataMappingsFile))
                begin
                    ;;Expand any logical names that might be there
                    data mappingFile = context.taskset.DataMappingsFile
                    if (!FileTools.ExpandLogicalName(mappingFile)) then
                        errStatus = context.CurrentTask.ErrorLog(String.Format("Failed to translate logical names in data mappings file {0}",context.Taskset.DataMappingsFile))
                    else
                    begin
                        ;;Make sure the file exists
                        if (!File.Exists(mappingFile)) then
                            errStatus = context.CurrentTask.Errorlog(string.Format("Failed to open custom data mappings file {0}", context.Taskset.DataMappingsFile))
                        else
                        begin
.ifdef D_NETSTANDARD
                            ;TODO: BUG: 4/12/2018 Using SetEnvironmentVariable seems to cause some issues in .NET Core
                            data sts, i4
                            xcall setlog("CODEGEN_DATAMAPPING_FILE",mappingFile,sts)
.else
                            Environment.SetEnvironmentVariable("CODEGEN_DATAMAPPING_FILE",mappingFile)
.endc
                            context.CurrentTask.DevDebugLog("Custom data mapping file set to " + mappingFile)
                        end
                    end
                end
            end

            ;;-------------------------------------------------------------------------
            ;;Tell Repositoiry API if we want to use a database other than SQL Server

            if (!errStatus)
            begin
                if (context.Taskset.DatabaseType != SqlDatabaseType.SQLServer)
                begin
.ifdef D_NETSTANDARD
                    ;TODO: BUG: 4/12/2018 Using SetEnvironmentVariable seems to cause some issues in .NET Core
                    data sts, i4
                    xcall setlog("CODEGEN_DATABASE_TYPE",context.Taskset.DatabaseType.ToString(),sts)
.else
                    Environment.SetEnvironmentVariable("CODEGEN_DATABASE_TYPE",context.Taskset.DatabaseType.ToString())
.endc
                end
            end

            ;;-------------------------------------------------------------------------
            ;;Do we have a template folder specified via CODEGEN_TPLDIR: ? If so this overrides the default location of current directory.

            if (!errStatus)
            begin
                data folder = Environment.GetEnvironmentVariable("CODEGEN_TPLDIR")
                if (!String.IsNullOrWhiteSpace(folder))
                begin
                    ;;Make sure there is no whitespace
                    folder = folder.Trim()

                    ;;Expand any logical names in the file spec.
                    if (!FileTools.ExpandLogicalName(folder)) then
                        errStatus = context.CurrentTask.ErrorLog(String.Format("Failed to expand logical name {0} in CODEGEN_TPLDIR:",folder))
                    else
                    begin
                        ;;Make sure the folder ends with a path seperator
                        if (!folder.EndsWith(Path.DirectorySeparatorChar.ToString()))
                            folder += Path.DirectorySeparatorChar

                        ;;Make sure the folder exists.
                        if (!Directory.Exists(folder))
                        begin
                            ;;CODEGEN_TPLDIR: is bad, but do we care?
                            if (String.IsNullOrWhiteSpace(context.CurrentTask.TemplateFolder) && String.IsNullOrWhiteSpace(context.Taskset.TemplateFolder))
                            begin
                                ;;Yes, we care!
                                errStatus = context.CurrentTask.ErrorLog(String.Format("CODEGEN_TPLDIR is set to {0} and the folder does not exist!",folder))
                            end
                        end

                        ;;Looks like we're using CODEGEN_TPLDIR: for now
                        if (!errStatus)
                        begin
                            context.TemplateFolder = folder
                            context.CurrentTask.DevDebugLog(String.Format("CODEGEN_TPLDIR sets template folder to {0}",folder))
                        end
                    end
                end
            end

            ;;-------------------------------------------------------------------------
            ;;Do we have a template folder specified for the task or taskset?
            ;;If so this overrides CODEGEN_TPLDIR:

            if (!errStatus)
            begin
                if (!String.IsNullOrWhiteSpace(context.CurrentTask.TemplateFolder)) then
                begin
                    ;;We have a task template folder
                    data folder = context.CurrentTask.TemplateFolder

                    ;;Expand any logical names
                    if (!FileTools.ExpandLogicalName(folder)) then
                        errStatus = context.CurrentTask.ErrorLog(String.Format("Failed to expand logical name {0} in task template folder",folder))
                    else
                    begin
                        ;;Make sure the folder ends with a path separator
                        if (!folder.EndsWith(Path.DirectorySeparatorChar.ToString()))
                            folder += Path.DirectorySeparatorChar

                        ;;Is the folder valid?
                        if (!Directory.Exists(folder)) then
                            errStatus = context.CurrentTask.ErrorLog(String.Format("Task specifies an invalid template folder {0}",folder))
                        else
                        begin
                            context.TemplateFolder = folder
                            context.CurrentTask.DevDebugLog(String.Format("Task sets template folder to {0}",folder))
                        end
                    end
                end
                else if (!String.IsNullOrWhiteSpace(context.Taskset.TemplateFolder))
                begin
                    ;;We have a task template folder
                    data folder = context.Taskset.TemplateFolder

                    ;;Expand any logical names
                    if (!FileTools.ExpandLogicalName(folder)) then
                        errStatus = context.CurrentTask.ErrorLog(String.Format("Failed to expand logical name {0} in task set template folder",folder))
                    else
                    begin
                        ;;Make sure the folder ends with a path separator
                        if (!folder.EndsWith(Path.DirectorySeparatorChar.ToString()))
                            folder += Path.DirectorySeparatorChar

                        ;;Is the folder valid?
                        if (!Directory.Exists(folder)) then
                            errStatus = context.CurrentTask.ErrorLog(String.Format("Task set specifies an invalid template folder {0}",folder))
                        else
                        begin
                            context.TemplateFolder = folder
                            context.CurrentTask.DevDebugLog(String.Format("Task set sets template folder to {0}",folder))
                        end
                    end
                end
            end

            ;;-------------------------------------------------------------------------
            ;;Report template file folder (verbose mode only)

            if ((!errStatus) && context.VerboseLoggingEnabled)
            begin
                if (String.IsNullOrWhiteSpace(context.TemplateFolder)) then
                    context.CurrentTask.Log("Template folder : Current directory", true, false)
                else
                    context.CurrentTask.Log("Template folder : " + context.TemplateFolder, true, false)
            end

            ;;-------------------------------------------------------------------------
            ;;Make sure there are template file(s) in the template folder

            if (!errStatus)
            begin
                data tplfiles = Directory.GetFiles(context.TemplateFolder,"*.tpl")
                if (tplfiles.Length == 0)
                    errStatus = context.CurrentTask.ErrorLog(string.Format("No templates found in template folder {0}", context.TemplateFolder))
            end

            ;;-------------------------------------------------------------------------
            ;;See if we have an output location specified with CODEGEN_OUTDIR
            ;;If present, this location overrides the default location (current dir)

            if (!errStatus)
            begin
                data folder = Environment.GetEnvironmentVariable("CODEGEN_OUTDIR")
                if (!String.IsNullOrWhiteSpace(folder))
                begin
                    ;;Make sure there is no whitespace
                    folder = folder.Trim()

                    ;;Expand any logical names in the file spec.
                    if (!FileTools.ExpandLogicalName(folder)) then
                        errStatus = context.CurrentTask.ErrorLog(String.Format("Failed to expand logical name {0} in CODEGEN_OUTDIR:",folder))
                    else
                    begin
                        ;;Make sure the path ends with a path separator
                        if (!folder.EndsWith(Path.DirectorySeparatorChar.ToString()))
                            folder += Path.DirectorySeparatorChar

                        ;;Make sure the folder exists.
                        if (!Directory.Exists(folder))
                        begin
                            ;;CODEGEN_OUTDIR: is bad, but do we care?
                            if (String.IsNullOrWhiteSpace(context.CurrentTask.OutputFolder) && String.IsNullOrWhiteSpace(context.Taskset.OutputFolder))
                            begin
                                ;;Yes, we care!
                                errStatus = context.CurrentTask.ErrorLog(String.Format("CODEGEN_OUTDIR is set to {0} and the folder doesn't exist!",folder))
                            end
                        end

                        ;;Looks like we're using CODEGEN_OUTDIR: for now
                        if (!errStatus)
                        begin
                            context.OutputFolder = folder
                            context.CurrentTask.DevDebugLog(String.Format("CODEGEN_OUTDIR sets output folder to {0}",folder))
                        end
                    end
                end
            end

            ;;-------------------------------------------------------------------------
            ;;Do we have an output folder specified for the task or taskset?
            ;;If so this overrides CODEGEN_OUTDIR:

            if (!errStatus)
            begin
                if (!String.IsNullOrWhiteSpace(context.CurrentTask.OutputFolder)) then
                begin
                    ;;We have a task output folder
                    data folder = context.CurrentTask.OutputFolder

                    ;;Expand any logical names
                    if (!FileTools.ExpandLogicalName(folder)) then
                        errStatus = context.CurrentTask.ErrorLog(String.Format("Failed to expand logical name {0} in task output folder",folder))
                    else
                    begin
                        ;;Make sure the folder ends with a path separator
                        if (!folder.EndsWith(Path.DirectorySeparatorChar.ToString()))
                            folder += Path.DirectorySeparatorChar

                        ;;Is the folder valid?
                        if (!Directory.Exists(folder)) then
                            errStatus = context.CurrentTask.ErrorLog(String.Format("Task specifies an invalid output folder {0}",folder))
                        else
                        begin
                            context.OutputFolder = folder
                            context.CurrentTask.DevDebugLog(String.Format("Task sets output folder to {0}",folder))
                        end
                    end
                end
                else if (!String.IsNullOrWhiteSpace(context.Taskset.OutputFolder))
                begin
                    ;;We have a task set output folder
                    data folder = context.Taskset.OutputFolder

                    ;;Expand any logical names
                    if (!FileTools.ExpandLogicalName(folder)) then
                        errStatus = context.CurrentTask.ErrorLog(String.Format("Failed to expand logical name {0} in task set output folder",folder))
                    else
                    begin
                        ;;Make sure the folder ends with a path separator
                        if (!folder.EndsWith(Path.DirectorySeparatorChar.ToString()))
                            folder += Path.DirectorySeparatorChar

                        ;;Is the folder valid?
                        if (!Directory.Exists(folder)) then
                            errStatus = context.CurrentTask.ErrorLog(String.Format("Task set specifies an invalid output folder {0}",folder))
                        else
                        begin
                            context.OutputFolder = folder
                            context.CurrentTask.DevDebugLog(String.Format("Task set sets output folder to {0}",folder))
                        end
                    end
                end
            end

            ;;-------------------------------------------------------------------------
            ;;Report output location (verbose mode only)

            if (!errStatus)
            begin
                if (context.VerboseLoggingEnabled)
                begin
                    if (String.IsNullOrWhiteSpace(context.OutputFolder)) then
                        context.CurrentTask.Log("Output folder   : Current directory")
                    else
                        context.CurrentTask.Log("Output folder   : " + context.OutputFolder)
                end
            end

            ;;-------------------------------------------------------------------------
            ;;Make sure we can create files in the output folder

            if (!errStatus && !FileTools.CanCreateFileInFolder(context.OutputFolder))
                errStatus = context.CurrentTask.ErrorLog(String.Format("Can't create files in output folder {0}!",context.OutputFolder))

            ;;-------------------------------------------------------------------------
            ;;Report if we're replacing existing files

            if (!errStatus)
            begin
                if (context.CurrentTask.ReplaceFiles) then
                    context.CurrentTask.VerboseLog("Replace files   : YES")
                else
                    context.CurrentTask.VerboseLog("Replace files   : NO")
            end

            ;;-------------------------------------------------------------------------
            ;;Namespace processing

            if (!errStatus)
            begin
                ;;Does the task have a namespace?
                if (!String.IsNullOrWhiteSpace(context.CurrentTask.Namespace)) then
                    context.CurrentTask.DevDebugLog("Namespace set by task to " + context.CurrentTask.Namespace)
                else
                begin
                    data namespace = Environment.GetEnvironmentVariable("SYNDEFNS")
                    if (!String.IsNullOrEmpty(namespace))
                    begin
                        context.Namespace = namespace.Trim()
                        context.CurrentTask.DevDebugLog("Namespace set by SYNDEFNS to " + context.CurrentTask.Namespace)
                    end
                end
            end

            ;;-------------------------------------------------------------------------
            ;;Are we being asked to override the key that is used with the <PRIMARY_KEY> construct?

            if (!errStatus && (context.CurrentTask.PrimaryKeyNumber!=0))
                context.CurrentTask.DebugLog(String.Format("<PRIMARY_KEY> blocks will use key {0}",context.CurrentTask.PrimaryKeyNumber),true,false)

            ;;-------------------------------------------------------------------------
            ;;Get a list of template files in template directory

            if (!errStatus)
            begin
                context.CurrentTask.VerboseLog("")

                if (context.CurrentTask.Templates.Count==0) then
                    errStatus = context.CurrentTask.ErrorLog("Nothing to do ... specify template(s) to process!")
                else
                begin
                    if (context.CurrentTask.Templates[0]=="*") then
                    begin
                        ;;We already checked that there are .tpl files in the template folder!
                        context.TemplateFiles = new List<String>(Directory.GetFiles(context.TemplateFolder,"*.tpl",SearchOption.TopDirectoryOnly))
                    end
                    else
                    begin
                        ;;Check that all of the specified template files exist
                        data templateName, String
                        foreach templateName in context.CurrentTask.Templates
                            errStatus = !addTemplateToProcessList(templateName, true)
                    end
                end

                if (!errStatus)
                begin
                    ;;Report templates to process
                    if (context.DebugLoggingEnabled)
                    begin
                        data tmpTemplate, String
                        context.CurrentTask.Log("Template(s):",true,false)
                        foreach tmpTemplate in context.TemplateFiles
                            context.CurrentTask.Log(" - " + Path.GetFileNameWithoutExtension(tmpTemplate).ToUpper())
                    end
                end
            end

            ;;-------------------------------------------------------------------------
            ;;Do we have a repository file definition specified?

            if (!errStatus && (!String.IsNullOrWhiteSpace(context.CurrentTask.RepositoryFile)))
            begin
                ;;Get the file details from the repository
                context.CurrentTask.RepositoryFile = context.CurrentTask.RepositoryFile.ToUpper()
                try
                begin
                    context.FileDefinition = new RpsFile(context.CurrentTask.RepositoryFile,context.CurrentTask.UseAlternateFieldNames)
                end
                catch (e, @RpsFileException)
                begin
                    errStatus = context.CurrentTask.Errorlog("Failed to load repository file definition " + context.CurrentTask.RepositoryFile)
                end
                endtry

                if (!errStatus)
                begin
                    ;;Make sure the file has at least one structure defined, and if so set them as the structures to process
                    if (context.FileDefinition.StructureCount>0) then
                    begin
                        context.Structures = context.FileDefinition.Structures

                        ;;Default all structures to use the file being processed
                        begin
                            data ix, int
                            context.StructureFileIndex = new int[context.Structures.Count]
                            for ix from 0 thru context.Structures.Count-1
                            begin
                                data iy, int
                                context.StructureFileIndex[ix] = 0
                                for iy from 0 thru context.Structures[ix].Files.Count-1
                                begin
                                    if (context.Structures[ix].Files[iy].Name==context.FileDefinition.Name)
                                    begin
                                        context.StructureFileIndex[ix] = iy
                                        exitloop
                                    end
                                end
                            end
                        end
                    end
                    else
                        errStatus = context.CurrentTask.Errorlog("Repository file " + context.CurrentTask.RepositoryFile + " doesn't have any structures assigned")
                end
            end

            ;;-------------------------------------------------------------------------
            ;;Do we have a UI Toolkit window script specified?

            if (!errStatus && (!String.IsNullOrWhiteSpace(context.CurrentTask.WindowScript)))
            begin
                if (!String.IsNullOrWhiteSpace(context.CurrentTask.RepositoryFile)) then
                    errStatus = context.CurrentTask.Errorlog("The repository file and window script file options can't be used together!")
                else
                    context.CurrentTask.DevDebugLog("Window script file " + context.CurrentTask.WindowScript + " will be processed")
            end

            ;;-------------------------------------------------------------------------
            ;;Do we have a BusinessCraft Proforma file specified?

            if (!errStatus && (!String.IsNullOrWhiteSpace(context.CurrentTask.ProformaFile)))
            begin
                if (context.FileDefinition!=^null) then
                    errStatus = context.CurrentTask.ErrorLog("Proforma and repository file processing can't be used together!")
                else if (!String.IsNullOrWhiteSpace(context.CurrentTask.WindowScript)) then
                    errStatus = context.CurrentTask.ErrorLog("Proforma and window script processing can't be used together!")
                else
                    context.CurrentTask.DevDebugLog("Processing BusinessCraft proforma file " + context.CurrentTask.ProformaFile)
            end

            ;;-------------------------------------------------------------------------
            ;;Are we provided with a UI Toolkit window script to search for selection windows in?

            if (!errStatus && (!String.IsNullOrWhiteSpace(context.CurrentTask.SelectionWindowScript)))
            begin
                ;;Translate any logical names that may be present
                data fileSpec = context.CurrentTask.SelectionWindowScript
                if (!FileTools.ExpandLogicalName(fileSpec)) then
                    errStatus = context.CurrentTask.ErrorLog(String.Format("Failed to expand logical names in task selection window script {0}",context.CurrentTask.SelectionWindowScript))
                else
                begin
                    ;;Open the file, fail if can't.
                    if (!File.Exists(fileSpec)) then
                        errStatus = context.CurrentTask.Errorlog(String.Format("Can't open selection window script {0}. Check your -ws option!",context.CurrentTask.SelectionWindowScript))
                    else
                    begin
                        context.SelectionWindowScript = fileSpec
                        context.CurrentTask.DebugLog(String.Format("Selection window processing enabled from file {0}",fileSpec))				
                    end
                end
            end

            ;;-------------------------------------------------------------------------
            ;;Do we have Repository structures specified in the task?

            if (!errStatus && ((context.CurrentTask.Structures != ^null && context.CurrentTask.Structures.Count > 0) || (context.TaskSet.Structures.Count > 0)))
            begin
                if (context.FileDefinition!=^null) then
                    errStatus = context.CurrentTask.Errorlog("You can't specify both a repository file and repository structures at the same time!")
                else if (!String.IsNullOrWhiteSpace(context.CurrentTask.WindowScript)) then
                    errStatus = context.CurrentTask.Errorlog("You can't specify a window script and repository structures at the same time!")
                else if (!String.IsNullOrEmpty(context.CurrentTask.ProformaFile)) then
                    errStatus = context.CurrentTask.Errorlog("You can't specify a proforma file and repository structures at the same time!")
                else if (context.CurrentTask.Structures != ^null && context.CurrentTask.Structures.Count>0) then
                begin
                    ;;All or specific structures?
                    if (context.CurrentTask.Structures[0]=="*") then
                    begin
                        ;;Process all structures
                        try
                        begin
                            context.Structures = new RpsStructureCollection(RpsLoadMode.Load,context.CurrentTask.UseAlternateFieldNames)
                            if (context.Structures.Count == 0)
                                errStatus = context.CurrentTask.Errorlog("Your repository contains no structures!")
                        end
                        catch (ex, @RpsException)
                        begin
                            errStatus = context.CurrentTask.Errorlog(ex.Message)
                        end
                        endtry
                    end
                    else
                    begin
                        ;;Process specified structures
                        data ix, int
                        for ix from 0 thru context.CurrentTask.Structures.Count-1 
                        begin
                            try
                            begin
                                data newStructure, @RpsStructure, new RpsStructure(context.CurrentTask.Structures[ix],context.CurrentTask.UseAlternateFieldNames)
                                if (!String.IsNullOrWhiteSpace(context.SelectionWindowScript))
                                begin
                                    if (!ProcessSelectionWindows(context,newStructure))
                                    begin
                                        errStatus = context.CurrentTask.Errorlog(String.Format("Failed to resolve selection windows for structure {0}.",newStructure.Name))
                                        exitloop
                                    end
                                end
                                context.Structures.Add(newStructure)
                            end
                            catch (ex)
                            begin
                                errStatus = context.CurrentTask.Errorlog(ex.Message)
                            end
                            endtry
                        end
                    end
                end
                else if (context.Taskset.Structures.Count > 0)
                begin
                    ;;All or specific structures?
                    if (context.Taskset.Structures[0]=="*") then
                    begin
                        ;;Process all structures
                        try
                        begin
                            context.Structures = new RpsStructureCollection(RpsLoadMode.Load,context.CurrentTask.UseAlternateFieldNames)
                            if (context.Structures.Count == 0)
                                errStatus = context.CurrentTask.Errorlog("Your repository contains no structures!")
                        end
                        catch (ex, @RpsException)
                        begin
                            errStatus = context.CurrentTask.Errorlog(ex.Message)
                        end
                        endtry
                    end
                    else
                    begin
                        ;;Process specified structures
                        data ix, int
                        for ix from 0 thru context.Taskset.Structures.Count-1 
                        begin
                            try
                            begin
                                data newStructure, @RpsStructure, new RpsStructure(context.Taskset.Structures[ix],context.CurrentTask.UseAlternateFieldNames)
                                if (!String.IsNullOrWhiteSpace(context.SelectionWindowScript))
                                begin
                                    if (!ProcessSelectionWindows(context,newStructure))
                                    begin
                                        errStatus = context.CurrentTask.Errorlog(String.Format("Failed to resolve selection windows for structure {0}.",newStructure.Name))
                                        exitloop
                                    end
                                end
                                context.Structures.Add(newStructure)
                            end
                            catch (ex)
                            begin
                                errStatus = context.CurrentTask.Errorlog(ex.Message)
                            end
                            endtry
                        end
                    end
                end

                ;;Default all structures to use the first file assigned
                if (!errStatus)
                begin
                    data ix, int
                    context.StructureFileIndex = new int[context.Structures.Count]
                    for ix from 0 thru context.Structures.Count - 1
                        context.StructureFileIndex[ix] = 0
                end

            end

            ;;-------------------------------------------------------------------------
            ;;Are we being asked to process a subset of the fields in a structure?

            if (!errStatus && (!String.IsNullOrWhiteSpace(context.CurrentTask.Subset)))
                context.CurrentTask.DevDebugLog("Subset processing was enabled for subset " + context.CurrentTask.Subset)					

            ;;-------------------------------------------------------------------------
            ;;Are we being asked to create a subset from a list of field names?

            if (!errStatus && (context.CurrentTask.SubsetFields.Count>0))
            begin
                if (!String.IsNullOrWhiteSpace(context.CurrentTask.Subset)) then
                    errStatus = context.CurrentTask.Errorlog("Field subsets from field names can't be used at the same time as a named subset!")
                else
                begin
                    ;;Make sure that each structure named in SubSetFields is being processed, and each field exists within the structure!
                    data subsetField, @Tuple<String, String>
                    foreach subsetField in context.CurrentTask.SubsetFields
                    begin
                        data str, @RpsStructure
                        data fld, @RpsField

                        lambda matchStructure(str) str.Name == subsetField.Item1
                        lambda matchField(fld) fld.OriginalName == subsetField.Item2

                        str = context.Structures.FirstOrDefault(matchStructure)

                        if (str != ^null)
                            fld = str.Fields.FirstOrDefault(matchField)

                        if (str == ^null || fld == ^null)
                        begin
                            ;;Report the issue, but continue processing for now, so that we report all errors not just one
                            errStatus = context.CurrentTask.ErrorLog(string.Format("An invalid subset field {0}.{1} was requested!",subsetField.Item1,subsetField.Item2))
                        end
                    end
                    if (!errStatus)
                        context.CurrentTask.DevDebugLog("Subset processing was enabled via a list of supplied field names")
                end
            end

            ;;-------------------------------------------------------------------------
            ;;If we have a window script file or ProForma file then process it

            if (!errStatus)
            begin
                ;;Now parse the script file
                if (!String.IsNullOrWhiteSpace(context.CurrentTask.WindowScript)) then
                begin
                    context.CurrentTask.DevDebugLog("Parsing window script " + context.CurrentTask.WindowScript)					
                    errStatus = (boolean)ParseWindowScript(context)
                end
                else if (!String.IsNullOrWhiteSpace(context.CurrentTask.ProformaFile))
                begin
                    data errTxt, string
                    data address, D_ADDR

                    ;;Try to load the Proforma extensions
                    if (!loadProformaExtensions(context)) then
                        errStatus = true
                    else
                    begin
                        context.CurrentTask.DevDebugLog("Parsing ProForma file " + context.CurrentTask.ProFormaFile)					

                        if (address = %xaddr("ParseProForma",,1)) then
                        begin
                            data pfStructure, @RpsStructure

                            context.CurrentTask.ProFormaStructures = new RpsStructureCollection(RpsLoadMode.NoLoad)

                            try
                            begin
                                context.CurrentTask.DebugLog("Executing ParseProForma()")

                                if (errStatus = (boolean)%xsubr(address,(a)context.CurrentTask.ProFormaFile))
                                    exit

                                ;;Did we get any structures loaded?
                                if (!context.CurrentTask.ProFormaStructures.Count)
                                    errStatus = context.CurrentTask.Errorlog("ParseProForma() did not load any structures!")
                            end
                            catch (e, @Exception)
                            begin
                                errStatus = context.CurrentTask.Errorlog(String.Format("Failed to execute ParseProForma(). Error was {0}",e.Message))
                                if (e.InnerException!=^null)
                                    context.CurrentTask.Log(String.Format("       {0}",e.InnerException.Message))
                            end
                            endtry

                            ;;Load the structures from ParseProForma()
                            if (!errStatus)
                            begin
                                context.Structures.Clear()
                                foreach pfStructure in context.CurrentTask.ProFormaStructures
                                    context.Structures.Add(pfStructure)
                            end
                        end
                        else
                            errStatus = context.CurrentTask.Errorlog("Failed to locate the ParseProForma() routine!")
                    end
                end

                if (errStatus)
                    exit

                ;;Default the structures to using the first assigned file definition
                data ix, int
                context.StructureFileIndex = new int[context.Structures.Count]
                for ix from 0 thru context.Structures.Count -1
                    context.StructureFileIndex[ix] = 0

                ;;If we got buttons from the script file, but we're being told not to do
                ;;button processing (-bn), then delete the buttons
                if (context.CurrentTask.NeverLoadAnyButtons && (context.Buttons.Count > 0))
                begin
                    context.CurrentTask.DebugLog("Removing script file buttons because of the NeverLoadAnyButtons property")
                    context.Buttons.Clear()
                end

                ;;If after parsing the script file we don't have any buttons, or we are being
                ;;told to always use default buttons (-ba), and we're not being told to not
                ;;load default buttons (-bd) and were not being told to not use any buttons
                ;;(-bn) then add the default buttons that are defined in
                ;;CODEGEN_EXE:DefaultButtons.xml
                if (((context.Buttons.Count == 0) || (context.CurrentTask.AlwaysLoadDefaultButtons)) && (!context.CurrentTask.NeverLoadDefaultButtons) && (!context.CurrentTask.NeverLoadAnyButtons))
                begin
                    if (context.Buttons.Count == 0) then
                        context.CurrentTask.DebugLog("Loading default buttons because no script file buttons were found",true,false)
                    else if (context.CurrentTask.AlwaysLoadDefaultButtons)
                        context.CurrentTask.DebugLog("Loading default buttons because of the AlwaysLoadDefaultButtons property",true,false)
                    context.Buttons.LoadDefaultButtons(context)
                end
            end

            ;;-------------------------------------------------------------------------
            ;;Report if we're doing Repository processing

            if ((!errStatus) && (context.DebugLoggingEnabled) && (context.Structures.Count>0))
            begin
                context.CurrentTask.Log("Structure(s):",true,false)						
                data str, @RpsStructure
                foreach str in context.Structures
                    context.CurrentTask.Log(" - " + str.Name)
            end

            ;;-------------------------------------------------------------------------
            ;;Do we have structure aliases specified

            if (!errStatus)
            begin
                ;;First, default all alias names to the same as the structure name
                data tmpStr, @RpsStructure
                foreach tmpStr in context.Structures
                    tmpStr.Alias = tmpStr.Name

                ;;Now apply specific aliases from the command line
                if (context.CurrentTask.Aliases != ^null && context.CurrentTask.Aliases.Count>0) then
                begin
                    if (!String.IsNullOrWhiteSpace(context.CurrentTask.WindowScript)) then
                        errStatus = context.CurrentTask.Errorlog("Can't use WindowScript and Aliases properties together!")
                    else if (context.CurrentTask.Aliases.Count > context.Structures.Count) then
                        errStatus = context.CurrentTask.Errorlog("More aliases than repository structures!")
                    else
                    begin
                        context.CurrentTask.DebugLog("Applying structure aliases",true,false)
                        data AliasIndex, int
                        for AliasIndex from 0 thru context.CurrentTask.Aliases.Count - 1
                        begin
                            if (!String.IsNullOrWhiteSpace(context.CurrentTask.Aliases[AliasIndex]))
                            begin
                                context.Structures[AliasIndex].Alias = context.CurrentTask.Aliases[AliasIndex].ToUpper()
                                context.CurrentTask.DebugLog(" - Structure " + context.Structures[AliasIndex].Name + " aliased as " + context.Structures[AliasIndex].Alias)
                            end
                        end
                    end
                end
                else if (context.Taskset.Aliases.Count > 0)
                begin
                    if (!String.IsNullOrWhiteSpace(context.CurrentTask.WindowScript)) then
                        errStatus = context.CurrentTask.Errorlog("Can't use WindowScript and Aliases properties together!")
                    else if (context.TaskSet.Aliases.Count > context.Structures.Count) then
                        errStatus = context.CurrentTask.Errorlog("More aliases than repository structures!")
                    else
                    begin
                        context.CurrentTask.DebugLog("Applying structure aliases",true,false)
                        data AliasIndex, int
                        for AliasIndex from 0 thru context.TaskSet.Aliases.Count - 1
                        begin
                            if (!String.IsNullOrWhiteSpace(context.TaskSet.Aliases[AliasIndex]))
                            begin
                                context.Structures[AliasIndex].Alias = context.TaskSet.Aliases[AliasIndex].ToUpper()
                                context.CurrentTask.DebugLog(" - Structure " + context.Structures[AliasIndex].Name + " aliased as " + context.Structures[AliasIndex].Alias)
                            end
                        end
                    end
                end
            end

            ;;-------------------------------------------------------------------------
            ;;Are  we being asked to use structure alternate names?
            ;;If so we will use the alternate (ODBC) name of the first structure assigned
            ;;to the first file assined to the current structure, if present.

            ;;Code in CodeGen.dbl will prevent UseAlternateStructureNames being true if structure aliases are present
            if (!errStatus && context.CurrentTask.UseAlternateStructureNames)
            begin
                context.CurrentTask.DebugLog("Applying structure alternate names",true,false)
                data tmpStr, @RpsStructure
                foreach tmpStr in context.Structures
                begin
                    ;;First, default all alias names to the same as the structure name
                    tmpStr.Alias = tmpStr.Name

                    ;;Now apply alternate (ODBC) names (if specified) based on the first assigned file (if any).
                    if (tmpStr.Files.Count>0)
                    begin
                        ;;Does the first assigned file have a structure assignment with an ODBC table name?
                        data tmpFile = tmpStr.Files[0]
                        if (tmpFile.OdbcTableNames.Count>0 && !String.IsNullOrWhiteSpace(tmpFile.OdbcTableNames[0]))
                        begin
                            ;;Alias the structure using the ODBC table name
                            tmpStr.Alias = tmpFile.OdbcTableNames[0]
                            context.CurrentTask.DebugLog(" - Structure " + tmpStr.Name + " aliased as " + tmpStr.Alias)
                        end
                    end
                end
            end

            ;;-------------------------------------------------------------------------
            ;;Do we have alternate repository file references specified

            if (!errStatus)
            begin
                ;;File overrides on the current task win out over any on the taskset
                if (context.CurrentTask.FileOverrides != ^null && context.CurrentTask.FileOverrides.Count > 0) then
                begin
                    if (context.CurrentTask.FileOverrides.Count > context.Structures.Count) then
                        errStatus = context.CurrentTask.Errorlog("You have specified more file name overrides than structures!")
                    else if (!String.IsNullOrWhiteSpace(context.CurrentTask.WindowScript)) then
                        errStatus = context.CurrentTask.Errorlog("File overrides can't be used when processing a window script file!")
                    else
                    begin
                        ;;Check that the alternate file names are valid for the structures
                        data clFileIndex, int
                        for clFileIndex from 0 thru context.CurrentTask.FileOverrides.Count -1
                        begin
                            context.CurrentTask.FileOverrides[clFileIndex] = context.CurrentTask.FileOverrides[clFileIndex].ToUpper()

                            data strFileIndex, int
                            data foundFile = false

                            for strFileIndex from 0 thru context.Structures[clFileIndex].Files.Count-1
                            begin
                                if (context.Structures[clFileIndex].Files[strFileIndex].Name == context.CurrentTask.FileOverrides[clFileIndex])
                                begin
                                    ;;Found it - this is the one we need later
                                    context.StructureFileIndex[clFileIndex] = strFileIndex
                                    foundFile = true
                                    context.CurrentTask.DebugLog("Using file definition " + context.Structures[clFileIndex].Files[strFileIndex].Name,true,false)
                                    exitloop
                                end
                            end
                            if (!foundFile)
                            begin
                                errStatus = context.CurrentTask.Errorlog("Structure "+context.Structures[clFileIndex].Name+" is not assigned to file "+context.CurrentTask.FileOverrides[clFileIndex])
                                exitloop
                            end
                        end
                    end
                end
                else if ((context.TaskSet.FileOverrides != ^null && context.TaskSet.FileOverrides.Count > 0))
                begin
                    ;;File overrides are being processed from the TaskSet
                    if (context.TaskSet.FileOverrides.Count > context.Structures.Count) then
                        errStatus = context.CurrentTask.Errorlog("You have specified more file name overrides than structures!")
                    else if (!String.IsNullOrWhiteSpace(context.CurrentTask.WindowScript)) then
                        errStatus = context.CurrentTask.Errorlog("File overrides can't be used when processing a window script file!")
                    else
                    begin
                        ;;Check that the alternate file names are valid for the structures
                        data clFileIndex, int
                        for clFileIndex from 0 thru context.TaskSet.FileOverrides.Count -1
                        begin
                            context.TaskSet.FileOverrides[clFileIndex] = context.TaskSet.FileOverrides[clFileIndex].ToUpper()

                            data strFileIndex, int
                            data foundFile = false

                            for strFileIndex from 0 thru context.Structures[clFileIndex].Files.Count-1
                            begin
                                if (context.Structures[clFileIndex].Files[strFileIndex].Name == context.TaskSet.FileOverrides[clFileIndex])
                                begin
                                    ;;Found it - this is the one we need later
                                    context.StructureFileIndex[clFileIndex] = strFileIndex
                                    foundFile = true
                                    context.CurrentTask.DebugLog("Using file definition " + context.Structures[clFileIndex].Files[strFileIndex].Name,true,false)
                                    exitloop
                                end
                            end
                            if (!foundFile)
                            begin
                                errStatus = context.CurrentTask.Errorlog("Structure "+context.Structures[clFileIndex].Name+" is not assigned to file "+context.TaskSet.FileOverrides[clFileIndex])
                                exitloop
                            end
                        end
                    end
                end
            end

            ;;-------------------------------------------------------------------------
            ;;See if we have any special field processing filters specified

            if (!errStatus)
            begin
                if (context.CurrentTask.IncludeOverlayFields||context.CurrentTask.IgnoreExcludeLanguage||context.CurrentTask.HonorExcludeToolkit||context.CurrentTask.HonorExcludeReportWriter||context.CurrentTask.HonorExcludeWeb)
                begin
                    if (!String.IsNullOrWhiteSpace(context.CurrentTask.WindowScript)) then
                    begin
                        ;;Can't use filters if we're processing a script file, the fields to include are determined by the script file.
                        errStatus = context.CurrentTask.Errorlog("Field filters can't be used when processing a window script!")
                    end
                    else if (context.DebugLoggingEnabled)
                    begin
                        context.CurrentTask.Log("Custom field filters in use", true, false)							
                        if (context.CurrentTask.IncludeOverlayFields)
                            context.CurrentTask.Log(" - Overlays will be included")
                        if (context.CurrentTask.IgnoreExcludeLanguage)
                            context.CurrentTask.Log(" - 'Excluded by Language' will be ignored")
                        if (context.CurrentTask.HonorExcludeToolkit)
                            context.CurrentTask.Log(" - 'Excluded by Toolkit' will be honored")
                        if (context.CurrentTask.HonorExcludeReportWriter)
                            context.CurrentTask.Log(" - 'Excluded by ReportWriter' will be honored")
                        if (context.CurrentTask.HonorExcludeWeb)
                            context.CurrentTask.Log(" - 'Excluded by Web' will be honored")
                    end
                end
            end

            ;;-------------------------------------------------------------------------
            ;;See if we have any special group processing filters specified

            if (!errStatus)
            begin
                if (context.CurrentTask.GroupFieldNoGroupPrefix||context.CurrentTask.GroupFieldNoRpsPrefix||context.CurrentTask.ExplicitGroupNoExpand||context.CurrentTask.ImplicitGroupNoExpand)
                begin
                    if (!String.IsNullOrWhiteSpace(context.CurrentTask.WindowScript)) then
                    begin
                        ;;Can't specify group prefixes if we're processing a script file, the field names are determined by the script file.
                        errStatus = context.CurrentTask.Errorlog("Custom group processing rules can't be used when processing a window script!")
                    end
                    else if (context.DebugLoggingEnabled)
                    begin
                        context.CurrentTask.Log("Custom group processing rules are in use", true, false)						
                        if (context.CurrentTask.ExplicitGroupNoExpand)
                            context.CurrentTask.Log(" - Explicit groups will not be expanded to individual fields")
                        if (context.CurrentTask.GroupFieldNoGroupPrefix)  ;;Do not prefix group fields with group name
                            context.CurrentTask.Log(" - Group fields will not be prefixed with the group name")
                        if (context.CurrentTask.ImplicitGroupNoExpand)
                            context.CurrentTask.Log(" - Implicit groups will not be expanded to individual fields")
                        if (context.CurrentTask.GroupFieldNoRpsPrefix)  ;;Do not use repository group field prefix
                            context.CurrentTask.Log(" - Repository group field prefix will not be used")
                    end
                end
            end

            ;;-------------------------------------------------------------------------
            ;;Are we being asked to process multiple structures at the same time (in the same template)

            if (!errStatus && (context.CurrentTask.MultipleStructures || ((context.FileDefinition!=^null)&&(context.Structures.Count>1))))
            begin
                ;;Make sure that we have at least one structures
                if ((context.FileDefinition==^null) && (context.Structures.Count<1)) then
                    errStatus = context.CurrentTask.Errorlog("Processing multiple structures (-ms) requires that you specify repository structures!")
                else
                begin
                    context.MultiStructureMode = true
                    context.CurrentTask.VerboseLog(String.Format("Processing {0} structures concurrently",context.Structures.Count),true,false)
                end
            end

            ;;-------------------------------------------------------------------------
            ;;Do we have a repoository customization file in the template folder?
            ;;If so then apply the overrides to the repository.
            ;;Right now this only allows keys to be excluded but in future we plan to support customizing anything in repository.

            if (!errStatus)
            begin
                if (!String.IsNullOrWhiteSpace(context.CurrentTask.RepositoryOverrideFile))
                begin
                    errStatus = RepositoryOverride.ApplyOverrides(context)
                end
            end

            ;;-------------------------------------------------------------------------
            ;;Are we being asked to process a user defined token file?

            if (!errStatus && (!String.IsNullOrWhiteSpace(context.CurrentTask.UserTokenFile)))
                errStatus = UserTokenCollection.LoadTokensFromFile(context)

            ;;-------------------------------------------------------------------------
            ;;Do we have user defined tokens on in the task?

            if (!errStatus && (context.CurrentTask.UserTokens.Count>0))
            begin
                if (context.UserTokens.Count==0) then
                begin
                    data token, @UserToken
                    foreach token in context.CurrentTask.UserTokens
                        context.UserTokens.Add(token)					
                end
                else
                    UserTokenCollection.AddTokens(context.CurrentTask.UserTokens,context.CurrentTask,context)
            end

            ;;-------------------------------------------------------------------------
            ;;Report the user-defined tokens we're dealing with
            if (!errStatus && context.UserTokens.Count > 0 && context.DebugLoggingEnabled)
            begin
                context.CurrentTask.Log("User-defined tokens are available:",true,false)
                data ut, @UserToken
                foreach ut in context.UserTokens
                    context.CurrentTask.Log(string.Format(" - {0} = {1}", ut.Name, ut.Value))
            end

            ;;-------------------------------------------------------------------------
            ;;Report the defines we're dealing with
            if (!errStatus && context.Taskset.Defines.Count > 0 && context.DebugLoggingEnabled)
            begin
                context.CurrentTask.Log("Defined values are available:",true,false)
                data define, string
                foreach define in context.Taskset.Defines
                    context.CurrentTask.Log(string.Format(" - {0}", define.Replace("DEFINED_","")))
            end

            ;;-------------------------------------------------------------------------
            ;;We're good to go. Generate souce code

            if (!errStatus)
            begin
                if (context.DeveloperDebugLoggingEnabled)
                begin
                    context.CurrentTask.Log("------------------------------",true,false)
                    context.CurrentTask.DevDebugLog("READY TO GENERATE CODE")
                    context.CurrentTask.Log("------------------------------")
                end

                ;;Don't do a foreach because we dynamically change the size of the collection
                data templateIndex = -1
                while ((templateIndex += 1) < context.TemplateFiles.Count)
                begin
                    context.CurrentTemplate = context.TemplateFiles[templateIndex]
                    errStatus = false

                    context.CurrentTask.VerboseLog(String.Format("Processing template {0}",context.CurrentTemplateBaseName), true, false)

                    ;;Turn the template into a collection of tokens
                    context.CurrentTask.DebugLog(" - Tokenization phase beginning", true, false)
                    data tokens, @List<Token>
                    data tokenizerError, String
                    if (!new Tokenizer(context).TokenizeCurrentTemplate(tokens))
                    begin
                        ;;The errors will have been written to the tasks messages
                        nextloop
                    end

                    ;;Write the tokens to a log file?
                    if (context.Taskset.LogTokenizerResults)
                        writeTokensToLogFile(tokens)

                    ;;Implement any custom validation that can only be done at this late stage
                    if (context.CurrentTask.MethodCatalogStructureMode)
                    begin
                        ;;Make sure there are no interface loop or method loop tokens present
                        if (tokens.Any(lambda(tkn) { tkn.TypeOfToken == TokenType.InterfaceLoop || tkn.TypeOfToken == TokenType.MethodLoop || tkn.TypeOfToken == TokenType.ParameterLoop }))
                        begin
                            errStatus = context.CurrentTask.ErrorLog(String.Format("Template {0} contains method catalog tokens that may not be used when processing repository structures!",context.CurrentTemplate))
                            nextloop
                        end
                    end

                    ;;Parse the collection of tokens into a tree the file name is only provided for error reporting purposes
                    context.CurrentTask.DebugLog(" - Parser phase beginning")
                    data tree, @FileNode
                    if (!Parser.Parse(context,tokens,tree))
                    begin
                        ;;The errors will have been written to the tasks messages
                        nextloop
                    end

                    ;;Write the initial tree to a log file?
                    if (context.Taskset.LogTokenizerResults)
                        writeTreeToLogFile(tree,"PARSER_OUTPUT")

                    ;;If the template file specifies an output folder, report it
                    if (!String.IsNullOrWhiteSpace(tree.OutputFolder))
                    begin
                        if (context.CurrentTask.AllowTemplateFolder) then
                        begin
                            context.CurrentTask.VerboseLog(String.Format(" - Template specifies output subfolder '{0}'",tree.OutputFolder))
                        end
                        else
                        begin
                            context.CurrentTask.Warning(string.Format("Template specified output folder '{0}' will not be used because option -tf has not been specified",tree.OutputFolder))
                            tree.OutputFolder = ^null
                        end
                    end

                    ;;Walk the tree for errors
                    context.CurrentTask.DebugLog(" - Tree validation phase beginning")
                    data errorReporter = new ErrorReporting()
                    errorReporter.Visit(tree)
                    if (errorReporter.Errors.Count > 0)
                    begin
                        data treeError, @Tuple<String, int, int, String>
                        foreach treeError in errorReporter.Errors
                        begin
                            ;If line numbers were working we could do this:
                            ;errStatus = task.ErrorLog(String.Format("{0} at line {1} position {2} in {3}", treeError.Item1, treeError.Item2, treeError.Item3, Path.GetFileName(treeError.Item4)))
                            ;But they are not, so we'll do this:
                            errStatus = context.CurrentTask.ErrorLog(treeError.Item1)
                        end
                        nextloop
                    end

                    ;;If we get here we have a valid tree that represents the template file we're processing

                    ;;Pre-processes the tree to deal with newline characters around loops, etc.
                    context.CurrentTask.DebugLog(" - Tree pre-expansion phase beginning")
                    data preExpander = new TreePreExpander()
                    preExpander.Visit(tree)

                    ;;Write the pre-expanded tree to a log file?
                    if (context.Taskset.LogTokenizerResults)
                        writeTreeToLogFile(tree,"EXPANDER_INPUT")

                    context.CurrentTask.DebugLog(" - Tree expansion phase beginning", false, true)

                    ;;Are we processing multiple structures at the same time?
                    if (context.MultiStructureMode) then
                    begin
                        ;;Process the template once for all structures

                        ;;Check each structure, flatten arrays and groups, etc.
                        context.CurrentTask.DebugLog("")
                        data ix, int
                        for ix from 0 thru context.Structures.Count-1
                        begin
                            errStatus = !RepositoryTools.CheckStructure(context,context.Structures[ix])
                            if (errStatus)
                                exitloop
                        end

                        if (!errStatus)
                        begin
                            ;;Set the initial context to the first structure. This isn't required for <STRUCTURE_LOOP> but will ensure that
                            ;;the default context is <STRUCTURE#1> if <STRUCTURE_LOOP> is not used.
                            context.SetCurrentStructure(context.Structures[0])

                            ;;Generate the code
                            errStatus = expandTreeToCode(tree)
                        end
                    end
                    else
                    begin
                        if (context.Structures.Count > 0) then
                        begin
                            ;;Process the template once per structure
                            data ix, int
                            for ix from 0 thru context.Structures.Count-1
                            begin
                                ;;Check the structure, flatten arrays and groups, etc.
                                if (!RepositoryTools.CheckStructure(context,context.Structures[ix])) then
                                    errStatus = true
                                else
                                begin
                                    ;;Set structure context
                                    context.SetCurrentStructure(context.Structures[ix])

                                    ;;Set the file reference to use
                                    context.CurrentFileIndex = context.StructureFileIndex[ix]

                                    ;;Generate the code
                                    errStatus = expandTreeToCode(tree)
                                end
                                ;;Bail structure loop on failure?
                                if ((errStatus) && (!context.Taskset.ContinueAfterError))
                                    exitloop
                            end
                        end
                        else
                        begin
                            ;;Generate the code
                            errStatus = expandTreeToCode(tree)
                        end
                    end

                    ;;Bail template loop on failure?
                    if (errStatus && !context.Taskset.ContinueAfterError)
                        exitloop
                end

                context.CurrentTemplate = String.Empty
            end

            ;;All done with this task
            reportTaskSummary()

        endmethod

        private method expandTreeToCode, boolean
            required in tree, @FileNode
        proc
            data errStatus = false

            if (context.Structures.Count > 0 && !context.MultiStructureMode)
                context.CurrentTask.VerboseLog(String.Format(" - Processing structure {0}",context.GetCurrentStructure().Name))

            ;;Create a stream for the TreeExpander to write the generated code to
            disposable data generatedCode = new StringWriter()

            ;;Produce the code
            try
            begin
                data expander = new TreeExpander(context, generatedCode)
                expander.Visit(tree)
            end
            catch (ex, @ApplicationException)
            begin
                ;;If the expander throws an ApplicationException it will already have
                ;;logged the message to the current tasks messages collection.
                generatedCode.Close()
                context.CurrentTask.FilesFailed += 1
                errStatus = true
            end
            catch (ex, @Exception)
            begin
                ;;Something unexpected!
                errStatus = context.CurrentTask.ErrorLog(String.Format("Unexpected error during tree expansion. Error was {0}", ex.Message))
                generatedCode.Close()
                context.CurrentTask.FilesFailed += 1
                if (context.Taskset.ThrowOnError)
                    throw
            end
            endtry

            ;;Create the output file
            if (!errStatus)
            begin
                disposable data newFile, @StreamWriter
                try
                begin
                    ;;Does the file we just generated content for already exist?
                    data skipFile = False
                    data fileMsg = "Creating"

                    data folder = context.OutputFolder

                    if (!String.IsNullOrWhiteSpace(tree.OutputFolder))
                    begin
                        folder = Path.Combine(folder,tree.OutputFolder)
                        if (!Directory.Exists(folder))
                            Directory.CreateDirectory(folder)
                    end

                    data outputFile = Path.Combine(folder,tree.OutputFileName)

                    if (File.Exists(outputFile)) then
                    begin
                        if (context.CurrentTask.ReplaceFiles) then
                            fileMsg = "Replacing"
                        else
                        begin
                            context.CurrentTask.VerboseLog(String.Format(" - Not replacing file {0}",Path.GetFileName(outputFile)))
                            skipFile = true
                            context.CurrentTask.FilesFailed += 1
                        end
                    end
                    else if (context.CurrentTask.FilesGenerated.Contains(outputFile))
                    begin
                        if (context.CurrentTask.MultiWriteFiles == false) then
                        begin
                            context.CurrentTask.VerboseLog(String.Format(" - Not writing file {0} multiple times",Path.GetFileName(outputFile)))
                            skipFile = true
                            context.CurrentTask.FilesFailed += 1
                        end
                        else
                        begin
                            context.CurrentTask.VerboseLog(String.Format(" - Writing file {0} multiple times",Path.GetFileName(outputFile)))
                        end
                    end

                    if (!skipFile)
                    begin
                        context.CurrentTask.DebugLog(String.Format(" - {0} {1}",fileMsg,Path.GetFileName(outputFile)))

                        ;;Write the generated code to the new file!
                        newFile = File.CreateText(outputFile)
                        newFile.Write(generatedCode.ToString())

                        ;;Close the file and clean up
                        newFile.Close()

                        ;;Record the file that was created
                        context.CurrentTask.FilesGenerated.Add(outputFile)
                    end
                end
                catch (ex, @Exception)
                begin
                    ;;Something unexpected!
                    errStatus = context.CurrentTask.ErrorLog(String.Format("Unexpected error while saving new file. Error was {0}", ex.Message))
                    context.CurrentTask.FilesFailed += 1
                end
                finally
                begin
                    if (newFile!=^null)
                        newFile.Close()
                    generatedCode.Close()
                end
                endtry
            end

            ;;Did the current template request any additional templates be processed?
            if (!errStatus)
                addTemplatesToProcessList(tree)

            ;;Did the template request that additional files be provided?
            if (!errStatus)
                provideAdditionalFiles(tree)

            mreturn errStatus

        endmethod

        private method provideAdditionalFiles, void
            required in tree, @FileNode
        proc
            if ((tree.ProvideFiles != ^null) && (tree.ProvideFiles.Count>0))
            begin
                data fileToProvide, String
                foreach	fileToProvide in tree.ProvideFiles
                begin
                    ;;First expand any logicals.
                    FileTools.ExpandLogicalName(fileToProvide)

                    ;;If we only have a file name then look for the file in the template folder
                    if (Path.GetDirectoryName(fileToProvide) == string.Empty)
                        fileToProvide = Path.Combine(context.TemplateFolder,fileToProvide)

                    ;;Does the input file exist?
                    if (!File.Exists(fileToProvide))
                    begin
                        context.CurrentTask.Warning(string.Format("Template {0} specifies that file {1} be copied to the output folder, but the file does not exist!",context.CurrentTemplateBaseName,Path.GetFileName(fileToProvide).ToUpper()))
                        nextloop
                    end

                    ;;Make sure the name we're using exactly matches the on-disk name
                    fileToProvide = Directory.GetFiles(Path.GetDirectoryName(fileToProvide),Path.GetFileName(fileToProvide))[0]

                    ;;Did we already provide the same file?
                    data outputFile = Path.Combine(context.OutputFolder,Path.GetFileName(fileToProvide))
                    if (context.CurrentTask.FilesProvided.Contains(outputFile))
                        nextloop

                    ;;Provide the file
                    try
                    begin
                        File.Copy(fileToProvide,outputFile,context.CurrentTask.ReplaceFiles)
                        ;;Record what we did
                        context.CurrentTask.FilesProvided.Add(outputFile)
                    end
                    catch (e, @Exception)
                    begin
                        ;;If the copy fails we'll ignore it, it's because we said an existing file can't be replaced!
                        nop
                    end
                    endtry
                end
            end
        endmethod

        private method addTemplatesToProcessList, void
            required in tree, @FileNode
        proc
            if ((tree.ProcessTemplates != ^null) && (tree.ProcessTemplates.Count>0))
            begin
                data templateName, String
                foreach templateName in tree.ProcessTemplates
                    addTemplateToProcessList(templateName,false )
            end
        endmethod

        private method addTemplateToProcessList, boolean
            required in templateBaseName, String
            required in initialLoad, boolean
        proc
            data ok = true

            ;;Add ".tpl" if necessary
            data templateName = templateBaseName.Trim()
            if (!templateName.ToLower().EndsWith(".tpl"))
                templateName = templateName + ".tpl"

            ;;Does this template spec contain a wildward?
            if (templateName.Contains("*")) then
            begin
                data matchingFiles = Directory.GetFiles(context.TemplateFolder,templateName)
                if (matchingFiles.Length == 0) then
                begin
                    if (initialLoad) then
                    begin
                        context.CurrentTask.ErrorLog(String.Format("No templates match wildcard specification {0}",templateName))
                        ok = false
                    end
                    else
                        context.CurrentTask.Warning(String.Format("Template {0} requested additional templates matching {1} be processed, but no matching templates were found.",context.CurrentTemplateBaseName,Path.GetFileNameWithoutExtension(templateName).ToUpper()))
                end
                else
                begin
                    ;;Add the matching templates to the list to process, if not already there
                    foreach templateName in matchingFiles
                    begin
                        if (!context.TemplateFiles.Contains(templateName))
                            context.TemplateFiles.Add(templateName)
                    end
                end
            end
            else
            begin
                ;;Turn the template file name into a full path
                templateName = Path.Combine(context.TemplateFolder,templateName)

                ;;Make sure the file exists
                if (!File.Exists(templateName)) then
                begin
                    if (initialLoad) then
                    begin
                        context.CurrentTask.Errorlog(String.Format("Template {0} not found!",Path.GetFileNameWithoutExtension(templateName).ToUpper()))
                        ok = false
                    end
                    else
                        context.CurrentTask.Warning(String.Format("Template {0} requested additional template {1} be processed, but that template was not found.",context.CurrentTemplateBaseName,Path.GetFileNameWithoutExtension(templateName).ToUpper()))
                end
                else
                begin
                    ;;Make sure the case of the file spec matches the on-disk name
                    templateName = Directory.GetFiles(Path.GetDirectoryName(templateName),Path.GetFileName(templateName))[0]

                    ;;Add the template to the collection
                    if (!context.TemplateFiles.Contains(templateName))
                    begin
                        context.TemplateFiles.Add(templateName)
                        if (!initialLoad)
                            context.CurrentTask.VerboseLog(String.Format(" - Process additional template {0}",Path.GetFileNameWithoutExtension(templateName).ToUpper()))
                    end
                end
            end

            mreturn ok

        endmethod

        private method reportTaskSummary, void
        proc

            data msg = String.Empty

            if ((context.CurrentTask.Errors == 0) && (context.CurrentTask.Warnings == 0)) then
                msg = "Task complete"

            else if ((context.CurrentTask.Errors > 0) && (context.CurrentTask.Warnings > 0)) then
            begin
                msg = "Task incomplete with " + context.CurrentTask.Errors.ToString() + " error"
                if (context.CurrentTask.Errors != 1)
                    msg = msg + "s"
                msg = msg + " and " + context.CurrentTask.Warnings.ToString() + " warning"
                if (context.CurrentTask.Warnings != 1)
                    msg = msg + "s"
            end

            else if (context.CurrentTask.Errors > 0) then
            begin
                msg = "Task incomplete with " + context.CurrentTask.Errors.ToString() + " error"
                if (context.CurrentTask.Errors != 1)
                    msg = msg + "s"
            end

            else if (context.CurrentTask.Warnings > 0)
            begin
                msg = "Task incomplete with " + context.CurrentTask.Warnings.ToString() + " warning"
                if (context.CurrentTask.Warnings != 1)
                    msg = msg + "s"
            end

            if ((context.CurrentTask.FilesGenerated.Count > 0) || (context.CurrentTask.FilesFailed > 0)) then
            begin
                if (context.CurrentTask.FilesGenerated.Count > 0 && context.CurrentTask.FilesFailed > 0) then
                begin
                    msg = msg + ", " + context.CurrentTask.FilesGenerated.Count.ToString() + " file"
                    if (context.CurrentTask.FilesGenerated.Count > 1)
                        msg = msg + "s"
                    msg = msg + " generated, " + context.CurrentTask.FilesFailed.ToString() + " failed."
                end
                else if (context.CurrentTask.FilesGenerated.Count > 0 ) then
                begin
                    msg = msg + ", " + %string(context.CurrentTask.FilesGenerated.Count) + " file"
                    if (context.CurrentTask.FilesGenerated.Count > 1)
                        msg = msg + "s"
                    msg = msg + " generated."
                end
                else if (context.CurrentTask.FilesFailed > 0)
                begin
                    msg = msg + ", " + %string(context.CurrentTask.FilesFailed) + " file"
                    if (context.CurrentTask.FilesFailed > 1)
                        msg = msg + "s"
                    msg = msg + " failed."
                end
            end
            else
                msg = msg + "."

            context.CurrentTask.Log(msg, true, false)

            if ((context.CurrentTask.FilesGenerated.Count > 0) && (context.Taskset.ListGeneratedFiles || context.VerboseLoggingEnabled))
            begin
                context.CurrentTask.Log("")
                data fileSpec, String
                foreach fileSpec in context.CurrentTask.FilesGenerated
                    context.CurrentTask.Log(" - " + Path.GetFileName(fileSpec))
            end

        endmethod

        private method writeTokensToLogFile, void
            required in tokens, @List<Token>
        proc
            data logFile = String.Format("{0}.TOKENS.LOG",context.CurrentTemplateBaseName)
            if (Tokenizer.WriteTokensToFile(tokens, Path.Combine(context.OutputFolder,logFile))) then
                context.CurrentTask.DevDebugLog(string.Format("Tokenization results were recorded in {0}",logFile))
            else
                context.CurrentTask.DevDebugLog("Failed to record tokenization results!")
        endmethod

        private method writeTreeToLogFile, void
            required in tree, @FileNode
            required in suffix, String
        proc
            data logFile = Path.Combine(context.OutputFolder,string.Format("{0}.{1}.LOG",context.CurrentTemplateBaseName,suffix))
            try
            begin
                data logger = new TreeLogger(logFile)
                logger.Visit(tree)
                context.CurrentTask.DevDebugLog(string.Format("Tree data was recorded in {0}",logFile))
            end
            catch (e, @Exception)
            begin
                context.CurrentTask.DevDebugLog("Failed to record tree data!")
            end
            endtry
        endmethod

    endclass

endnamespace
