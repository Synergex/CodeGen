;; *****************************************************************************
;; 
;;  Title:       TokenExpanderFieldLoop.dbl
;; 
;;  Type:        Partial class
;; 
;;  Description: Expands field loop token nodes
;; 
;;  Date:        30th August 2014
;; 
;;  Author:      Steve Ives, Synergex Professional Services Group
;;               http://www.synergex.com
;; 
;; *****************************************************************************
;; 
;;  Copyright (c) 2014, Synergex International, Inc.
;;  All rights reserved.
;; 
;;  Redistribution and use in source and binary forms, with or without
;;  modification, are permitted provided that the following conditions are met:
;; 
;;  * Redistributions of source code must retain the above copyright notice,
;;    this list of conditions and the following disclaimer.
;; 
;;  * Redistributions in binary form must reproduce the above copyright notice,
;;    this list of conditions and the following disclaimer in the documentation
;;    and/or other materials provided with the distribution.
;; 
;;  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
;;  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
;;  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
;;  ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
;;  LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
;;  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
;;  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
;;  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
;;  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
;;  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
;;  POSSIBILITY OF SUCH DAMAGE.
;; 
;; *****************************************************************************

import System
import System.Collections.Generic
import System.Linq
import System.Text
import System.Threading.Tasks
import CodeGen.Engine
import CodeGen.RepositoryAPI

.array 0

namespace CodeGen.Engine

    public partial class TokenExpander

        fieldLoopTokenExpanders, @Dictionary<string, Func<Token, FileNode, IEnumerable<LoopNode>, string>>

        private method registerFieldLoopTokens, void
            endparams
        proc

            fieldLoopTokenExpanders = new Dictionary<string, Func<Token, FileNode, IEnumerable<LoopNode>, string>>()

            fieldLoopTokenExpanders.Add("FIELD_ALTNAME", expandFieldAltName)
            fieldLoopTokenExpanders.Add("FIELD_ARRIVEM", expandFieldArriveMethod)
            fieldLoopTokenExpanders.Add("FIELD_BASENAME", expandFieldBaseName)
            fieldLoopTokenExpanders.Add("FIELD_BREAK_MODE", expandFieldBreakMode)
            fieldLoopTokenExpanders.Add("FIELD_CHANGEM", expandFieldChangeMethod)
            fieldLoopTokenExpanders.Add("FIELD_CLASS", expandFieldClass)
            fieldLoopTokenExpanders.Add("FIELD_COL", expandFieldColumn)
            fieldLoopTokenExpanders.Add("FIELD_CSCONVERT", expandFieldCsConvert)
            fieldLoopTokenExpanders.Add("FIELD_CSDEFAULT", expandFieldCsDefault)
            fieldLoopTokenExpanders.Add("FIELD_CSTYPE", expandFieldCsType)
            fieldLoopTokenExpanders.Add("FIELD_CUSTOM_DBL_TYPE", expandFieldCustomDblType)
            fieldLoopTokenExpanders.Add("FIELD_CUSTOM_SQL_TYPE", expandFieldCustomSqlType)
            fieldLoopTokenExpanders.Add("FIELD_CUSTOM_CONVERT_FUNCTION", expandFieldCustomConvertFunction)
            fieldLoopTokenExpanders.Add("FIELD_CUSTOM_STRING_FUNCTION", expandFieldCustomStringFunction)
            fieldLoopTokenExpanders.Add("FIELD_DBL_NET_CONVERTER", expandFieldDblNetConverterer)
            fieldLoopTokenExpanders.Add("FIELD_DEFAULT", expandFieldDefault)
            fieldLoopTokenExpanders.Add("FIELD_DESC", expandFieldDescription)
            fieldLoopTokenExpanders.Add("FIELD_DESC_DOUBLE", expandFieldDescriptionDouble)
            fieldLoopTokenExpanders.Add("FIELD_DESC_SINGLE", expandFieldDescriptionSingle)
            fieldLoopTokenExpanders.Add("FIELD_DIMENSION1_INDEX", expandFieldDim1Index)
            fieldLoopTokenExpanders.Add("FIELD_DIMENSION2_INDEX", expandFieldDim2Index)
            fieldLoopTokenExpanders.Add("FIELD_DIMENSION3_INDEX", expandFieldDim3Index)
            fieldLoopTokenExpanders.Add("FIELD_DIMENSION4_INDEX", expandFieldDim4Index)
            fieldLoopTokenExpanders.Add("FIELD_DISPLAY_LENGTH", expandFieldDisplayLength)
            fieldLoopTokenExpanders.Add("FIELD_DRILLM", expandFieldDrillMethod)
            fieldLoopTokenExpanders.Add("FIELD_DRILL_PIXEL_COL", expandFieldDrillPixelCol)
            fieldLoopTokenExpanders.Add("FIELD_ELEMENT", expandFieldElement)
            fieldLoopTokenExpanders.Add("FIELD_ELEMENT0", expandFieldElement0)
            fieldLoopTokenExpanders.Add("FIELD_ENDPOS", expandFieldEndPos)
            fieldLoopTokenExpanders.Add("FIELD_ENUMBASEVAL", expandFieldEnumBaseVal)
            fieldLoopTokenExpanders.Add("FIELD_ENUMLENGTH", expandFieldEnumLength)
            fieldLoopTokenExpanders.Add("FIELD_ENUMSTEPVAL", expandFieldEnumStepVal)
            fieldLoopTokenExpanders.Add("FIELD_ENUMWIDTH", expandFieldEnumWidth)
            fieldLoopTokenExpanders.Add("FIELD_FORMATNAME", expandFieldFormatName)
            fieldLoopTokenExpanders.Add("FIELD_FORMATSTRING", expandFieldFormatString)
            fieldLoopTokenExpanders.Add("FIELD_GROUP_EXPAND", expandFieldGroupExpand)
            fieldLoopTokenExpanders.Add("FIELD_GROUP_MEMBER_PREFIX",exapndFieldGroupMemberPrefix)
            fieldLoopTokenExpanders.Add("FIELD_GROUP_STRUCTURE",exapndFieldGroupStructure)
            fieldLoopTokenExpanders.Add("FIELD_HEADING", expandFieldHeading)
            fieldLoopTokenExpanders.Add("FIELD_HELPID", expandFieldHelpId)
            fieldLoopTokenExpanders.Add("FIELD_HYPERM", expandFieldHyperMethod)
            fieldLoopTokenExpanders.Add("FIELD_INFOLINE", expandFieldInfoLine)
            fieldLoopTokenExpanders.Add("FIELD_INPUT_JUSTIFICATION", expandFieldInputJustification)
            fieldLoopTokenExpanders.Add("FIELD_INPUT_LENGTH", expandFieldInputLength)
            fieldLoopTokenExpanders.Add("FIELD_LDESC", expandFieldLongDescription)
            fieldLoopTokenExpanders.Add("FIELD_LDESC2", expandFieldLongDescription2)
            fieldLoopTokenExpanders.Add("FIELD_LEAVEM", expandFieldLeaveMethod)
            fieldLoopTokenExpanders.Add("FIELD_MAXVALUE", expandFieldMaxValue)
            fieldLoopTokenExpanders.Add("FIELD_MINVALUE", expandFieldMinValue)
            fieldLoopTokenExpanders.Add("FIELD_NAME", expandFieldName)
            fieldLoopTokenExpanders.Add("FIELD_NETNAME", expandFieldNetName)
            fieldLoopTokenExpanders.Add("FIELD_NET_ALTNAME", expandFieldSqlAltname)
            fieldLoopTokenExpanders.Add("FIELD_NOECHO_CHAR", expandFieldNoEchoChar)
            fieldLoopTokenExpanders.Add("FIELD_OCDEFAULT", expandFieldOcDefault)
            fieldLoopTokenExpanders.Add("FIELD_OCTYPE", expandFieldOcType)
            fieldLoopTokenExpanders.Add("FIELD_ODBCNAME", expandFieldOdbcName)
            fieldLoopTokenExpanders.Add("FIELD_ORIGINAL_NAME", expandFieldOriginalName)
            fieldLoopTokenExpanders.Add("FIELD_ORIGINAL_NAME_MODIFIED", expandFieldOriginalNameModified)
            fieldLoopTokenExpanders.Add("FIELD_OVERLAY_FIELD", expandFieldOverlayField)
            fieldLoopTokenExpanders.Add("FIELD_OVERLAY_OFFSET", expandFieldOverlayOffset)
            fieldLoopTokenExpanders.Add("FIELD_OVERLAY_SPEC", expandFieldOverlaySpec)
            fieldLoopTokenExpanders.Add("FIELD_PAINTCHAR", expandFieldPaintChar)
            fieldLoopTokenExpanders.Add("FIELD_PAINTFIELD", expandFieldPaintField)
            fieldLoopTokenExpanders.Add("FIELD_PATH", expandFieldPath)
            fieldLoopTokenExpanders.Add("FIELD_PATH_CONV", expandFieldPathConv)
            fieldLoopTokenExpanders.Add("FIELD_PII_TYPE", expandFieldPiiType)
            fieldLoopTokenExpanders.Add("FIELD_PIXEL_COL", expandFieldPixelCol)
            fieldLoopTokenExpanders.Add("FIELD_PIXEL_ROW", expandFieldPixelRow)
            fieldLoopTokenExpanders.Add("FIELD_PIXEL_WIDTH", expandFieldPixelWidth)
            fieldLoopTokenExpanders.Add("FIELD_POSITION", expandFieldPosition)
            fieldLoopTokenExpanders.Add("FIELD_POSITION_COL", expandFieldPositionCol)
            fieldLoopTokenExpanders.Add("FIELD_POSITION_MODE", expandFieldPositionMode)
            fieldLoopTokenExpanders.Add("FIELD_POSITION_ROW", expandFieldPositionRow)
            fieldLoopTokenExpanders.Add("FIELD_POSITION_ZERO", expandFieldPositionZero)
            fieldLoopTokenExpanders.Add("FIELD_PRECISION", expandFieldPrecision)
            fieldLoopTokenExpanders.Add("FIELD_PRECISION0", expandFieldPrecision0)
            fieldLoopTokenExpanders.Add("FIELD_PRECISION2", expandFieldPrecision2)
            fieldLoopTokenExpanders.Add("FIELD_PROMPT", expandFieldPrompt)
            fieldLoopTokenExpanders.Add("FIELD_RANGE_MAX", expandFieldRangeMax)
            fieldLoopTokenExpanders.Add("FIELD_RANGE_MIN", expandFieldRangeMin)
            fieldLoopTokenExpanders.Add("FIELD_REGEX", expandFieldRegex)
            fieldLoopTokenExpanders.Add("FIELD_REPORT_JUSTIFICATION", expandFieldReportJustification)
            fieldLoopTokenExpanders.Add("FIELD_ROW", expandFieldRow)
            fieldLoopTokenExpanders.Add("FIELD_SAMPLE_DATA", expandFieldSampleData)
            fieldLoopTokenExpanders.Add("FIELD_SAMPLE_DATA_NOQUOTES", expandFieldSampleDataNoQuotes)
            fieldLoopTokenExpanders.Add("FIELD_SELECTION_COUNT", expandFieldSelectionCount)
            fieldLoopTokenExpanders.Add("FIELD_SELECTIONS", expandFieldSelections)
            fieldLoopTokenExpanders.Add("FIELD_SELECTIONS1", expandFieldSelections1)
            fieldLoopTokenExpanders.Add("FIELD_SELECTIONS_COL", expandFieldSelectionsCol)
            fieldLoopTokenExpanders.Add("FIELD_SELECTIONS_HEIGHT", expandFieldSelectionsHeight)
            fieldLoopTokenExpanders.Add("FIELD_SELECTIONS_ROW", expandFieldSelectionsRow)
            fieldLoopTokenExpanders.Add("FIELD_SELLENGTH", expandFieldSelLength)
            fieldLoopTokenExpanders.Add("FIELD_SELWND", expandFieldSelWnd)
            fieldLoopTokenExpanders.Add("FIELD_SELWND_ORIGINAL", expandFieldSelWndOriginal)
            fieldLoopTokenExpanders.Add("FIELD_SIZE", expandFieldSize)
            fieldLoopTokenExpanders.Add("FIELD_SNTYPE", expandFieldSnType)
            fieldLoopTokenExpanders.Add("FIELD_SNDEFAULT", expandFieldSnDefault)
            fieldLoopTokenExpanders.Add("FIELD_SPEC", expandFieldSpec)
            fieldLoopTokenExpanders.Add("FIELD_SQL_ALTNAME", expandFieldSqlAltname)
            fieldLoopTokenExpanders.Add("FIELD_SQLNAME", expandFieldSqlName)
            fieldLoopTokenExpanders.Add("FIELD_SQLTYPE", expandFieldSqlType)
            fieldLoopTokenExpanders.Add("FIELD_TEMPLATE", expandFieldTemplate)
            fieldLoopTokenExpanders.Add("FIELD_TKSCRIPT", expandFieldTkScript)
            fieldLoopTokenExpanders.Add("FIELD_TSDEFAULT", expandFieldTsDefault)
            fieldLoopTokenExpanders.Add("FIELD_TSTYPE", expandFieldTsType)
            fieldLoopTokenExpanders.Add("FIELD_TYPE", expandFieldType)
            fieldLoopTokenExpanders.Add("FIELD_TYPE_NAME", expandFieldTypeName)
            fieldLoopTokenExpanders.Add("FIELD_USER_TYPE",expandFieldUserType)
            fieldLoopTokenExpanders.Add("FIELD_UTEXT", expandFieldUserText)
            fieldLoopTokenExpanders.Add("FIELD_VBDEFAULT", expandFieldVbDefault)
            fieldLoopTokenExpanders.Add("FIELD_VBTYPE", expandFieldVbType)
            fieldLoopTokenExpanders.Add("FIELD_VIEW_LENGTH",expandFieldViewLength)
            fieldLoopTokenExpanders.Add("FIELD#", expandFieldNumber)
            fieldLoopTokenExpanders.Add("FIELD#_ZERO", expandFieldNumberZero)
            fieldLoopTokenExpanders.Add("FIELD#LOGICAL", expandFieldNumberLogical)
            fieldLoopTokenExpanders.Add("FIELD#LOGICAL_ZERO", expandFieldNumberLogicalZero)
            fieldLoopTokenExpanders.Add("HARMONY_ROLES", expandFieldHarmonyRoles)
            fieldLoopTokenExpanders.Add("MAPPED_FIELD", expandFieldMappedField)
            fieldLoopTokenExpanders.Add("MAPPED_PATH", expandFieldMappedPath)
            fieldLoopTokenExpanders.Add("MAPPED_PATH_CONV", expandFieldMappedPathConv)
            fieldLoopTokenExpanders.Add("MAPPING_FUNCTION", expandMappingFunction)
            fieldLoopTokenExpanders.Add("UNMAPPING_FUNCTION", expandUnmappingFunction)
            fieldLoopTokenExpanders.Add("PROMPT_COL", expandFieldPromptCol)
            fieldLoopTokenExpanders.Add("PROMPT_PIXEL_COL", expandFieldPromptPixelCol)
            fieldLoopTokenExpanders.Add("PROMPT_PIXEL_ROW", expandFieldPromptPixelRow)
            fieldLoopTokenExpanders.Add("PROMPT_PIXEL_WIDTH", expandFieldPromptPixelWidth)
            fieldLoopTokenExpanders.Add("PROMPT_ROW", expandFieldPromptRow)
            fieldLoopTokenExpanders.Add("PROMPT_POSITION_COL", expandFieldPromptPositionCol)
            fieldLoopTokenExpanders.Add("PROMPT_POSITION_MODE", expandFieldPromptPositionMode)
            fieldLoopTokenExpanders.Add("PROMPT_POSITION_ROW", expandFieldPromptPositionRow)

        endmethod

        ;;; <summary>
        ;;; 
        ;;; </summary>
        ;;; <param name="tkn"></param>
        ;;; <param name="template"></param>
        ;;; <param name="loops"></param>
        ;;; <param name="specific"></param>
        ;;; <returns></returns>
        public static method ExpandFieldLoopToken, string
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            specific, @Func<RpsStructure, RpsField, string> 
            endparams
        proc

            lambda isFieldOrSegmentLoop(node) (node .is. FieldLoopNode || node .is. SegmentLoopNode)
            data loop, @LoopNode, loops.Last(isFieldOrSegmentLoop)
            data currentStructure = template.Context.GetCurrentStructure()

            data str, @RpsStructure
            data fld, @RpsField

            if (loop .is. FieldLoopNode) then
            begin
                ;;We're in a field loop
                str = currentStructure
                fld = ((@FieldLoopNode)loop).GetCurrentField()
            end
            else if (loop .is. RelationSegmentLoopNode) then
            begin
                ;;We're in a relation key segment loop

                ;;First get a handle on the outer relation loop that must be above us in the tree
                lambda isRelationLoop(node) (node .is. RelationLoopNode)
                data relationLoop, @RelationLoopNode, ^as(loops.First(isRelationLoop), @RelationLoopNode)

                ;;Determine which structure we're dealing with, based on the TYPE of relation segment loop (FROM_KEY_SEGMENT_LOOP or TO_KEY_SEGMENT_LOOP)
                str = loop.OpenToken.Value.StartsWith("FROM_KEY_SEGMENT_LOOP") ? currentStructure : relationLoop.ToStructure

                ;;Now get a handle on the full definition of the key segment we're dealing with
                data segment, @RpsKeySegment, ((@RelationSegmentLoopNode)loop).CurrentSegment

                ;;And get a handle on the field associated with the current segment
                ;;Could return null if it a "literal" segment
                lambda isSegmentField(f) (f.OriginalName == segment.Field)
                fld = str.Fields.FirstOrDefault(isSegmentField)
                nop
            end
            else if (loop .is. SegmentLoopNode)
            begin
                ;;We're in a regular key segment loop
                data segloop = (@SegmentLoopNode)loop

                ;;There are some scenarios where field loop tokens are theoretically valid,
                ;;But where in some specific scenarios there may be no current field.
                ;;For example this can happen in key segment loops if a key segment that
                ;;is not associated with a field is encountered (e.g. foreign key segments
                ;;can be specified as a literal value).

                if (segloop.CurrentField == ^null)
                    throw new ApplicationException(String.Format("Can't use field loop token in segment loop for structure {0} key {1} segment {2}. No associated field!",currentStructure.Name, segloop.CurrentKey.Name, segloop.CurrentIndex + 1))

                str = currentStructure
                fld = segloop.CurrentField
            end

            mreturn specific(str, fld)

        endmethod

        private static method expandFieldAltName, string
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            lambda doExpand(str, field) field.AlternateName
            mreturn ExpandFieldLoopToken(tkn, template, loops, doExpand)
        endmethod

        private static method expandFieldArriveMethod, string
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            lambda doExpand(str, field) field.ArriveMethod
            mreturn ExpandFieldLoopToken(tkn, template, loops, doExpand)
        endmethod

        private static method expandFieldBaseName, string
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            lambda doExpand(str, field) field.BaseName
            mreturn ExpandFieldLoopToken(tkn, template, loops, doExpand)
        endmethod

        private static method expandFieldBreakMode, string
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            lambda doExpand(str, field)
            begin
                using (field.BreakMode) select
                (RpsFieldBreak.Always),
                    mreturn "Always"
                (RpsFieldBreak.Change),
                    mreturn "Change"
                (RpsFieldBreak.None),
                    mreturn "None"
                (RpsFieldBreak.OnReturn),
                    mreturn "Return"
                (),
                    mreturn "None"
                endusing
            end
            mreturn ExpandFieldLoopToken(tkn, template, loops, doExpand)
        endmethod

        private static method expandFieldChangeMethod, string
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            lambda doExpand(str, field) field.ChangeMethod
            mreturn ExpandFieldLoopToken(tkn, template, loops, doExpand)
        endmethod

        private static method expandFieldClass, string
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            lambda doExpand(str, field)
            begin
                using field.DataTypeSubclass select
                (RpsFieldSubclass.DateYYMMDD),
                    mreturn "YYMMDD"
                (RpsFieldSubclass.DateYYYYMMDD),
                    mreturn "YYYYMMDD"
                (RpsFieldSubclass.DateYYJJJ),
                    mreturn "YYJJJ"
                (RpsFieldSubclass.DateYYYYJJJ),
                    mreturn "YYYYJJJ"
                (RpsFieldSubclass.DateYYPP),
                    mreturn "YYPP"
                (RpsFieldSubclass.DateYYYYPP),
                    mreturn "YYYYPP"
                (RpsFieldSubclass.TimeHHMMSS),
                    mreturn "HHMMSS"
                (RpsFieldSubclass.TimeHHMM),
                    mreturn "HHMM"
                (RpsFieldSubclass.Binary),
                    mreturn "UserBinary"
                (RpsFieldSubclass.UserAlpha),
                    mreturn "UserAlpha"
                (RpsFieldSubclass.UserNumeric),
                    mreturn "UserNumeric"
                (RpsFieldSubclass.UserDate),
                    mreturn "UserDate"
                (),
                    mreturn ""
                endusing
            end
            mreturn ExpandFieldLoopToken(tkn, template, loops, doExpand)
        endmethod

        private static method expandFieldColumn, string
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            lambda doExpand(str, field)
            begin
                if (field.FieldColumn == 0) then
                    mreturn Convert.ToString(DefaultValues.DefaultFieldColumn)
                else
                    mreturn Convert.ToString(field.FieldColumn)
            end
            mreturn ExpandFieldLoopToken(tkn, template, loops, doExpand)
        endmethod

        private static method expandFieldCsConvert, string
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            lambda doExpand(str, field) field.CsNumericConvert
            mreturn ExpandFieldLoopToken(tkn, template, loops, doExpand)
        endmethod

        private static method expandFieldCsDefault, string
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            lambda doExpand(str, field) field.CsDefault
            mreturn ExpandFieldLoopToken(tkn, template, loops, doExpand)
        endmethod

        private static method expandFieldCsType, string
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            lambda doExpand(str, field) field.CsType
            mreturn ExpandFieldLoopToken(tkn, template, loops, doExpand)
        endmethod

        private static method expandFieldCustomDblType, string
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            lambda doExpand(str, field)
            begin
                data propValue = field.GetProperty<string>(template, "CUSTOM_DBL_TYPE")
                if(propValue != ^null) then
                    mreturn propValue
                else
                    mreturn expandFieldSpec(tkn, template, loops)
            end
            mreturn ExpandFieldLoopToken(tkn, template, loops, doExpand)
        endmethod

        private static method expandFieldCustomSqlType, string
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            lambda doExpand(str, field)
            begin
                data propValue = field.GetProperty<string>(template, "CUSTOM_SQL_TYPE")
                if(propValue != ^null) then
                    mreturn propValue
                else
                    mreturn expandFieldSqlType(tkn, template, loops)
            end
            mreturn ExpandFieldLoopToken(tkn, template, loops, doExpand)
        endmethod

        private static method expandFieldCustomConvertFunction, string
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            lambda doExpand(str, field)
            begin
                data propValue = field.GetProperty<string>(template, "CUSTOM_CONVERT_FUNCTION")
                if(propValue != ^null) then
                    mreturn propValue
                else
                    mreturn ""
            end
            mreturn ExpandFieldLoopToken(tkn, template, loops, doExpand)
        endmethod

        private static method expandFieldCustomStringFunction, string
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            lambda doExpand(str, field)
            begin
                data propValue = field.GetProperty<string>(template, "CUSTOM_STRING_FUNCTION")
                if(propValue != ^null) then
                    mreturn propValue
                else
                    mreturn ""
            end
            mreturn ExpandFieldLoopToken(tkn, template, loops, doExpand)
        endmethod

        private static method expandFieldDblNetConverterer, string
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            lambda doExpand(str, field) field.DblNetConverterer
            mreturn ExpandFieldLoopToken(tkn, template, loops, doExpand)
        endmethod

        private static method expandFieldDefault, string
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            lambda doExpand(str, field) field.DefaultValue
            mreturn ExpandFieldLoopToken(tkn, template, loops, doExpand)
        endmethod

        private static method expandFieldDescription, string
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            lambda doExpand(str, field) field.Description
            mreturn ExpandFieldLoopToken(tkn, template, loops, doExpand)
        endmethod

        private static method expandFieldDescriptionDouble, string
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            lambda doExpand(str, field) field.Description.Replace('"',"'")
            mreturn ExpandFieldLoopToken(tkn, template, loops, doExpand)
        endmethod

        private static method expandFieldDescriptionSingle, string
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            lambda doExpand(str, field) field.Description.Replace("'",'"')
            mreturn ExpandFieldLoopToken(tkn, template, loops, doExpand)
        endmethod

        private static method expandFieldDim1Index, string
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            lambda doExpand(str, field)
            begin
                if (field.WasArrayElement) then
                    mreturn Convert.ToString(field.OriginalElement[0])
                else
                    mreturn "0"
            end
            mreturn ExpandFieldLoopToken(tkn, template, loops, doExpand)
        endmethod

        private static method expandFieldDim2Index, string
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            lambda doExpand(str, field) Convert.ToString(field.OriginalElement[1])
            mreturn ExpandFieldLoopToken(tkn, template, loops, doExpand)
        endmethod

        private static method expandFieldDim3Index, string
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            lambda doExpand(str, field) Convert.ToString(field.OriginalElement[2])
            mreturn ExpandFieldLoopToken(tkn, template, loops, doExpand)
        endmethod

        private static method expandFieldDim4Index, string
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            lambda doExpand(str, field) Convert.ToString(field.OriginalElement[3])
            mreturn ExpandFieldLoopToken(tkn, template, loops, doExpand)
        endmethod

        private static method expandFieldDisplayLength, string
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            lambda doExpand(str, field) field.DisplayLength > 0 ? Convert.ToString(field.DisplayLength) : ""
            mreturn ExpandFieldLoopToken(tkn, template, loops, doExpand)
        endmethod

        private static method expandFieldDrillMethod, string
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            lambda doExpand(str, field) field.DrillMethod
            mreturn ExpandFieldLoopToken(tkn, template, loops, doExpand)
        endmethod

        private static method expandFieldElement, string
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            lambda doExpand(str, field)
            begin
                if ((((field.OriginalElement[0] != 0) && (field.OriginalElement[1] != 0)) && (field.OriginalElement[2] != 0)) && (field.OriginalElement[3] != 0)) then
                    mreturn String.Format("{0},{1},{2},{3}", field.OriginalElement[0], field.OriginalElement[1], field.OriginalElement[2], field.OriginalElement[3])
                else if (((field.OriginalElement[0] != 0) && (field.OriginalElement[1] != 0)) && (field.OriginalElement[2] != 0)) then
                    mreturn String.Format("{0},{1},{2}", field.OriginalElement[0], field.OriginalElement[1], field.OriginalElement[2])
                else if ((field.OriginalElement[0] != 0) && (field.OriginalElement[1] != 0)) then
                    mreturn String.Format("{0},{1}", field.OriginalElement[0], field.OriginalElement[1])
                else if ((field.OriginalElement[0] != 0) && (field.WasArrayElement)) then
                    mreturn Convert.ToString(field.OriginalElement[0])
                else
                    mreturn ""
            end
            mreturn ExpandFieldLoopToken(tkn, template, loops, doExpand)
        endmethod

        private static method expandFieldElement0, string
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            lambda doExpand(str, field)
            begin
                if ((((field.OriginalElement[0] != 0) && (field.OriginalElement[1] != 0)) && (field.OriginalElement[2] != 0)) && (field.OriginalElement[3] != 0)) then
                    mreturn String.Format("{0},{1},{2},{3}", field.OriginalElement[0], field.OriginalElement[1], field.OriginalElement[2], field.OriginalElement[3])
                else if (((field.OriginalElement[0] != 0) && (field.OriginalElement[1] != 0)) && (field.OriginalElement[2] != 0)) then
                    mreturn String.Format("{0},{1},{2}", field.OriginalElement[0], field.OriginalElement[1], field.OriginalElement[2])
                else if ((field.OriginalElement[0] != 0) && (field.OriginalElement[1] != 0)) then
                    mreturn String.Format("{0},{1}", field.OriginalElement[0], field.OriginalElement[1])
                else if ((field.OriginalElement[0] != 0) && (field.WasArrayElement)) then
                    mreturn Convert.ToString(field.OriginalElement[0])
                else
                    mreturn "0"
            end
            mreturn ExpandFieldLoopToken(tkn, template, loops, doExpand)
        endmethod

        private static method expandFieldEndPos, string
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            lambda doExpand(str, field)
            begin
                data endpos, int
                if (template.Context.CurrentTask.PreserveArrays && (field.ArrayDimension[0]>1 || field.ArrayDimension[1]>1 || field.ArrayDimension[2]>1 || field.ArrayDimension[3]>1)) then
                begin
                    data elements, int, field.ArrayDimension[0] + field.ArrayDimension[1] + field.ArrayDimension[2] + field.ArrayDimension[3]
                    endpos = field.StartPosition + (field.Size * elements) - 1
                end
                else
                begin
                    endpos = field.StartPosition + field.Size - 1
                end
                mreturn Convert.ToString(endpos)
            end
            mreturn ExpandFieldLoopToken(tkn, template, loops, doExpand)
        endmethod

        private static method expandFieldEnumBaseVal, string
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            lambda doExpand(str, field) field.Enumerated ? Convert.ToString(field.EnumeratedBaseValue) : ""
            mreturn ExpandFieldLoopToken(tkn, template, loops, doExpand)
        endmethod

        private static method expandFieldEnumLength, string
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            lambda doExpand(str, field) field.Enumerated ? Convert.ToString(field.EnumeratedDisplayLength) : ""
            mreturn ExpandFieldLoopToken(tkn, template, loops, doExpand)
        endmethod

        private static method expandFieldEnumStepVal, string
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            lambda doExpand(str, field) field.Enumerated ? Convert.ToString(field.EnumeratedStepValue) : ""
            mreturn ExpandFieldLoopToken(tkn, template, loops, doExpand)
        endmethod

        private static method expandFieldEnumWidth, string
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            data width, int, DefaultValues.DefaultCharacterWidth
            if (template.Context.CurrentTask.CharacterWidth > 0)
                width = template.Context.CurrentTask.CharacterWidth
            lambda doExpand(str, field) Convert.ToString(field.EnumeratedDisplayLength * width)
            mreturn ExpandFieldLoopToken(tkn, template, loops, doExpand)
        endmethod

        private static method expandFieldFormatName, string
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            lambda doExpand(str, field) field.FormatName
            mreturn ExpandFieldLoopToken(tkn, template, loops, doExpand)
        endmethod

        private static method expandFieldFormatString, string
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            lambda doExpand(str, field) field.FormatString
            mreturn ExpandFieldLoopToken(tkn, template, loops, doExpand)
        endmethod

        private static method expandFieldGroupExpand, string
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            lambda doExpand(str, field)
            begin
                if (field.GroupType != RpsFieldGroup.Yes)
                    throw new ApplicationException(String.Format("Field loop token {0} can only be used with non-overlay GROUP fields!",tkn.Value))
                mreturn LoopExpander.ProcessGroup(tkn,template,loops,str,field)
            end
            mreturn ExpandFieldLoopToken(tkn, template, loops, doExpand)
        endmethod

        private static method exapndFieldGroupMemberPrefix, string
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            lambda doExpand(str, field) field.IsGroup ? field.GroupMemberPrefix : String.Empty
            mreturn ExpandFieldLoopToken(tkn, template, loops, doExpand)
        endmethod

        private static method exapndFieldGroupStructure, string
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            lambda doExpand(str, field) field.GroupStructure
            mreturn ExpandFieldLoopToken(tkn, template, loops, doExpand)
        endmethod

        private static method expandFieldHeading, string
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            lambda doExpand(str, field)
            begin
                data value, string
                if (!String.IsNullOrWhiteSpace(field.ReportHeading)) then
                    value = field.ReportHeading
                else if (!String.IsNullOrWhiteSpace(field.Prompt)) then
                    value = field.Prompt
                else
                    value = field.Name
                ;; Clean up the data (remove " and ^)
                mreturn value.Replace("""", "").Replace("^", "")
            end
            mreturn ExpandFieldLoopToken(tkn, template, loops, doExpand)
        endmethod

        private static method expandFieldHelpId, string
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            lambda doExpand(str, field) field.HelpIdentifier
            mreturn ExpandFieldLoopToken(tkn, template, loops, doExpand)
        endmethod

        private static method expandFieldHyperMethod, string
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            lambda doExpand(str, field) field.HyperlinkMethod
            mreturn ExpandFieldLoopToken(tkn, template, loops, doExpand)
        endmethod

        private static method expandFieldInfoLine, string
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            lambda doExpand(str, field) field.InfoLineText.Replace("""", "")
            mreturn ExpandFieldLoopToken(tkn, template, loops, doExpand)
        endmethod

        private static method expandFieldInputJustification, string
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            lambda doExpand(str, field) field.InputJustification.ToString()
            mreturn ExpandFieldLoopToken(tkn, template, loops, doExpand)
        endmethod

        private static method expandFieldLongDescription, string
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            lambda doExpand(str, field) field.LongDescription
            mreturn ExpandFieldLoopToken(tkn, template, loops, doExpand)
        endmethod

        private static method expandFieldLongDescription2, string
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            lambda doExpand(str, field)
            begin
                data ldesc, a1800, field.LongDescription
                data result = String.Empty
                data ix = 0
                for ix from 1 thru 30
                begin
                    if (ldesc((60*ix)-59:60))
                    begin
                        result = result + %atrim(ldesc((60*ix)-59:60)) + "  "
                    end
                end
                mreturn result.Trim()
            end
            mreturn ExpandFieldLoopToken(tkn, template, loops, doExpand)
        endmethod

        private static method expandFieldLeaveMethod, string
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            lambda doExpand(str, field) field.LeaveMethod
            mreturn ExpandFieldLoopToken(tkn, template, loops, doExpand)
        endmethod

        private static method expandFieldMaxValue, string
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            lambda doExpand(str, field)
            begin
                data tmpMaxVal, string, ""
                ;; If the field has a range specified  use it
                if (field.NumericRangeMaximum > 0) then
                begin
                    if (field.Precision > 0) then
                        tmpMaxVal = Convert.ToString(field.NumericRangeMaximum)
                    else
                        tmpMaxVal = string.Format("{0:0}", field.NumericRangeMaximum)
                end
                else
                begin
                    ;; Make sure the field is numeric
                    using (field.DataType) select
                    (RpsFieldDataType.Decimal),
                    begin
                        if (field.ViewAs == RpsFieldViewAs.CheckBox) then
                            tmpMaxVal = "1"
                        else if (field.Enumerated && field.SelectionList.Count > 0) then
                        begin
                            if (field.EnumeratedStepValue > 0) then
                                tmpMaxVal = Convert.ToString(field.EnumeratedBaseValue + (field.EnumeratedStepValue * (field.SelectionList.Count - 1)))
                            else
                                tmpMaxVal = Convert.ToString(field.EnumeratedBaseValue)
                        end
                        else if (field.Precision > 0) then
                        begin
                            if (field.Precision < field.Size) then
                                tmpMaxVal = ((string)"9999999999999999999999999999").Substring(0, field.Size - field.Precision)
                            else
                                tmpMaxVal = "0"
                            tmpMaxVal += "."
                            tmpMaxVal += ((string)"9999999999999999999999999999").Substring(0, field.Precision)
                        end
                        else
                            tmpMaxVal = ((string)"9999999999999999999999999999").Substring(0, field.Size)
                    end
                    (RpsFieldDataType.Integer),
                    begin
                        if (field.ViewAs == RpsFieldViewAs.CheckBox) then
                            tmpMaxVal = "1"
                        else if (field.Enumerated && field.SelectionList.Count > 0) then
                        begin
                            if (field.EnumeratedBaseValue > 0) then
                                tmpMaxVal = Convert.ToString(field.EnumeratedBaseValue + (field.EnumeratedStepValue * (field.SelectionList.Count - 1)))
                            else
                                tmpMaxVal = Convert.ToString(field.EnumeratedBaseValue)
                        end
                        else
                        begin
                            using (field.Size) select
                            (1),
                                tmpMaxVal = "127"
                            (2),
                                tmpMaxVal = "32767"
                            (4),
                                tmpMaxVal = "2147483647"
                            (8),
                                tmpMaxVal = "9223372036854775807"
                            endusing
                        end
                        exit
                    end
                    (),
                    begin
                        ;; Not numeric, throw an error
                        ;; TODO: The error should not be thrown if output is off because of an expression!
                        throw new ApplicationException(template.GetTokenErrorMessage(tkn, "can only be used with numeric fields"))
                    end
                    endusing
                end
                mreturn tmpMaxVal
            end
            mreturn ExpandFieldLoopToken(tkn, template, loops, doExpand)
        endmethod

        private static method expandFieldMinValue, string
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            lambda doExpand(str, field)
            begin
                data tmpMinVal, string, ""
                ;; If the field has a range specified then use it
                if (field.NumericRangeMinimum != 0) then
                begin
                    if (field.Precision > 0) then
                        tmpMinVal = Convert.ToString(field.NumericRangeMinimum)
                    else
                        tmpMinVal = string.Format("{0:0}", field.NumericRangeMinimum)
                end
                else
                begin
                    ;; Make sure the field is numeric
                    using (field.DataType) select
                    (RpsFieldDataType.Decimal),
                    begin
                        if (field.ViewAs == RpsFieldViewAs.CheckBox) then
                            tmpMinVal = "0"
                        else if (field.Enumerated) then
                        begin
                            if (field.EnumeratedStepValue > 0) then
                                tmpMinVal = Convert.ToString(field.EnumeratedBaseValue)
                            else
                                tmpMinVal = Convert.ToString(field.EnumeratedBaseValue + (field.EnumeratedStepValue * (field.SelectionList.Count - 1)))
                        end
                        else if (field.Precision > 0) then
                        begin
                            if (field.NegativeAllowed != RpsFieldNegatives.None) then
                            begin
                                tmpMinVal = "-"
                                if (field.Precision < field.Size) then
                                    tmpMinVal += ((string)"9999999999999999999999999999").Substring(0, field.Size - field.Precision)
                                else
                                    tmpMinVal += "0"
                                tmpMinVal += "."
                                tmpMinVal += ((string)"9999999999999999999999999999").Substring(0, field.Precision)
                            end
                            else
                                tmpMinVal = "0"
                        end
                        else
                        begin
                            if (field.NegativeAllowed != RpsFieldNegatives.None) then
                            begin
                                tmpMinVal = "-" + (((string)"9999999999999999999999999999").Substring(0, field.Size))
                            end
                            else if (field.Required) then
                                tmpMinVal = "1"
                            else
                                tmpMinVal = "0"
                        end
                    end
                    (RpsFieldDataType.Integer),
                    begin
                        if (field.ViewAs == RpsFieldViewAs.CheckBox) then
                            tmpMinVal = "0"
                        else if (field.Enumerated) then
                        begin
                            if (field.EnumeratedStepValue > 0) then
                                tmpMinVal = Convert.ToString(field.EnumeratedBaseValue)
                            else
                                tmpMinVal = Convert.ToString(field.EnumeratedBaseValue + (field.EnumeratedStepValue * (field.SelectionList.Count - 1)))
                        end
                        else if (field.NegativeAllowed == RpsFieldNegatives.None) then
                        begin
                            if (field.Required) then
                                tmpMinVal = "1"
                            else
                                tmpMinVal = "0"
                        end
                        else
                        begin
                            using (field.Size) select
                            (1),
                                tmpMinVal = "-128"
                            (2),
                                tmpMinVal = "-32768"
                            (4),
                                tmpMinVal = "-2147483648"
                            (8),
                                tmpMinVal = "-9223372036854775808"
                            endusing
                        end
                    end
                    (),
                    begin
                        ;; Not numeric, throw an error
                        ;; TODO: The error should not be thrown if output is off because of an expression!
                        throw new ApplicationException(template.GetTokenErrorMessage(tkn, "can only be used with numeric fields"))
                    end
                    endusing
                end
                mreturn tmpMinVal
            end
            mreturn ExpandFieldLoopToken(tkn, template, loops, doExpand)
        endmethod

        private static method expandFieldName, string
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            lambda doExpand(str, field) field.Name
            mreturn ExpandFieldLoopToken(tkn, template, loops, doExpand)
        endmethod

        private static method expandFieldNoEchoChar, string
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            lambda doExpand(str, field)
            begin
                if (String.IsNullOrWhiteSpace(field.NoEchoCharacter)) then
                    mreturn DefaultValues.DefaultFieldNoEchoChar
                else
                    mreturn field.NoEchoCharacter
            end
            mreturn ExpandFieldLoopToken(tkn, template, loops, doExpand)
        endmethod

        private static method expandFieldOcDefault, string
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            lambda doExpand(str, field) field.OcDefault
            mreturn ExpandFieldLoopToken(tkn, template, loops, doExpand)
        endmethod

        private static method expandFieldOcType, string
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            lambda doExpand(str, field) field.OcType
            mreturn ExpandFieldLoopToken(tkn, template, loops, doExpand)
        endmethod

        private static method expandFieldOriginalName, string
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            lambda doExpand(str, field) field.OriginalName
            mreturn ExpandFieldLoopToken(tkn, template, loops, doExpand)
        endmethod

        private static method expandFieldOriginalNameModified, string
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            lambda doExpand(str, field) field.OriginalNameModified
            mreturn ExpandFieldLoopToken(tkn, template, loops, doExpand)
        endmethod

        private static method expandFieldPath, string
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            lambda doExpand(str, field) String.Format("{0}.{1}", str.Alias, field.Name)
            mreturn ExpandFieldLoopToken(tkn, template, loops, doExpand)
        endmethod

        private static method expandFieldPathConv, string
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            lambda doExpand(str, field)
            begin
                ;; Do we have conversion function?
                if (String.IsNullOrWhiteSpace(field.UnmappingFunction)) then
                    mreturn String.Format("{0}.{1}", str.Alias, field.Name)
                else
                    mreturn String.Format("%{0}({1}.{2})", field.UnmappingFunction, str.Alias, field.Name)
            end
            mreturn ExpandFieldLoopToken(tkn, template, loops, doExpand)
        endmethod

        private static method expandFieldPiiType, string
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            lambda doExpand(str, field)
            begin
                data propValue = field.GetProperty<string>(template, "PII_TYPE")
                if(propValue != ^null) then
                    mreturn propValue
                else
                    mreturn ""
            end
            mreturn ExpandFieldLoopToken(tkn, template, loops, doExpand)
        endmethod

        private static method expandFieldPixelCol, string
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            lambda doExpand(str, field)
            begin
                data width, int, DefaultValues.DefaultCharacterWidth
                if (template.Context.CurrentTask.CharacterWidth > 0)
                    width = template.Context.CurrentTask.CharacterWidth
                if (field.FieldColumn > 0) then
                    mreturn Convert.ToString((field.FieldColumn * width) - (width - 1))
                else
                    mreturn Convert.ToString((DefaultValues.DefaultFieldColumn * width) - (width - 1))
            end
            mreturn ExpandFieldLoopToken(tkn, template, loops, doExpand)
        endmethod

        private static method expandFieldPixelRow, string
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            lambda doExpand(str, field)
            begin
                data height, int, DefaultValues.DefaultCharacterHeight
                if (template.Context.CurrentTask.CharacterHeight > 0)
                    height = template.Context.CurrentTask.CharacterHeight
                if (field.FieldRow > 0) then
                    mreturn Convert.ToString(((field.FieldRow + field.ArrayDimension[1] - 1) * height) - (height - 1))
                else
                    mreturn Convert.ToString((field.LogicalFieldNumber * height) - (height - 1))
            end
            mreturn ExpandFieldLoopToken(tkn, template, loops, doExpand)
        endmethod

        private static method expandFieldPixelWidth, string
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            lambda doExpand(str, field)
            begin
                data width, int, DefaultValues.DefaultCharacterWidth
                if (template.Context.CurrentTask.CharacterWidth > 0)
                    width = template.Context.CurrentTask.CharacterWidth
                if (field.SelectionList.Count > 0) then
                    mreturn Convert.ToString(field.SelectionListMaxLength * width)
                else if (field.Enumerated) then
                    mreturn Convert.ToString(field.EnumeratedDisplayLength * width)
                else
                    mreturn Convert.ToString(field.Size * width)
            end
            mreturn ExpandFieldLoopToken(tkn, template, loops, doExpand)
        endmethod

        private static method expandFieldDrillPixelCol, string
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            lambda doExpand(str, field)
            begin
                data width, int, DefaultValues.DefaultCharacterWidth
                if (template.Context.CurrentTask.CharacterWidth > 0)
                    width = template.Context.CurrentTask.CharacterWidth
                data fieldPixWidth, int
                if (field.SelectionList.Count > 0) then
                    fieldPixWidth = field.SelectionListMaxLength * width
                else if (field.Enumerated) then
                    fieldPixWidth = field.EnumeratedDisplayLength * width
                else
                    fieldPixWidth = field.Size * width
                if (field.FieldColumn > 0) then
                    mreturn Convert.ToString((field.FieldColumn * width) + fieldPixWidth - width)
                else
                    mreturn Convert.ToString((DefaultValues.DefaultFieldColumn * width) + fieldPixWidth - width)
            end
            mreturn ExpandFieldLoopToken(tkn, template, loops, doExpand)
        endmethod

        private static method expandFieldInputLength, string
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            lambda doExpand(str, field)
            begin
                data fieldInputLength, int
                using (field.DataType) select
                (RpsFieldDataType.Alpha),
                    mreturn Convert.ToString(field.Size)
                (RpsFieldDataType.Decimal),
                begin
                    fieldInputLength = field.Size
                    if (field.NegativeAllowed != RpsFieldNegatives.None)
                        fieldInputLength += 1
                    if (field.Precision > 0)
                        fieldInputLength += 1
                    mreturn Convert.ToString(fieldInputLength)
                end
                (RpsFieldDataType.Integer),
                begin
                    fieldInputLength = 0
                    using (field.Size) select
                    (1),
                        fieldInputLength = 3
                    (2),
                        fieldInputLength = 5
                    (4),
                        fieldInputLength = 10
                    (8),
                        fieldInputLength = 19
                    endusing
                    if (field.NegativeAllowed != RpsFieldNegatives.None)
                        fieldInputLength += 1
                    mreturn Convert.ToString(fieldInputLength)
                end
                (),
                    mreturn Convert.ToString(field.Size)
                endusing
            end
            mreturn ExpandFieldLoopToken(tkn, template, loops, doExpand)
        endmethod

        private static method expandFieldNetName, string
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            lambda doExpand(str, field) field.SqlName
            mreturn ExpandFieldLoopToken(tkn, template, loops, doExpand)
        endmethod

        private static method expandFieldOdbcName, string
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            lambda doExpand(str, field) field.OdbcName
            mreturn ExpandFieldLoopToken(tkn, template, loops, doExpand)
        endmethod

        private static method expandFieldOverlayField, string
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            lambda doExpand(str, field) field.OverlaysField
            mreturn ExpandFieldLoopToken(tkn, template, loops, doExpand)
        endmethod

        private static method expandFieldOverlayOffset, string
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            lambda doExpand(str, field) String.IsNullOrWhiteSpace(field.OverlaysField) ? "" : field.OverlayOffset.ToString()
            mreturn ExpandFieldLoopToken(tkn, template, loops, doExpand)
        endmethod

        private static method expandFieldOverlaySpec, string
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            lambda doExpand(str, field)
            begin
                if (String.IsNullOrWhiteSpace(field.OverlaysField)) then
                begin
                    mreturn ""
                end
                else
                begin
                    mreturn String.Format("@{0}{1}",field.OverlaysField,field.OverlayOffset>0 ? " + " + field.OverlayOffset.ToString() : "")
                end
            end
            mreturn ExpandFieldLoopToken(tkn, template, loops, doExpand)
        endmethod

        private static method expandFieldPaintChar, string
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            lambda doExpand(str, field) field.PaintCharacter
            mreturn ExpandFieldLoopToken(tkn, template, loops, doExpand)
        endmethod

        private static method expandFieldPaintField, string
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            lambda doExpand(str, field) field.PaintField ? "Yes" : "No"
            mreturn ExpandFieldLoopToken(tkn, template, loops, doExpand)
        endmethod

        private static method expandFieldPosition, string
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            lambda doExpand(str, field) Convert.ToString(field.StartPosition)
            mreturn ExpandFieldLoopToken(tkn, template, loops, doExpand)
        endmethod

        private static method expandFieldPositionCol, string
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            lambda doExpand(str, field) field.FieldPositionMode == RpsPositionMode.None ? "" : field.FieldColumn.ToString()
            mreturn ExpandFieldLoopToken(tkn, template, loops, doExpand)
        endmethod

        private static method expandFieldPositionMode, string
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            lambda doExpand(str, field) field.FieldPositionMode.ToString()
            mreturn ExpandFieldLoopToken(tkn, template, loops, doExpand)
        endmethod

        private static method expandFieldPositionRow, string
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            lambda doExpand(str, field) field.FieldPositionMode == RpsPositionMode.None ? "" : field.FieldRow.ToString()
            mreturn ExpandFieldLoopToken(tkn, template, loops, doExpand)
        endmethod

        private static method expandFieldPositionZero, string
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            lambda doExpand(str, field) Convert.ToString(field.StartPosition - 1)
            mreturn ExpandFieldLoopToken(tkn, template, loops, doExpand)
        endmethod

        private static method expandFieldPrecision, string
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            lambda doExpand(str, field)
            begin
                if (field.Precision > 0) then
                    mreturn Convert.ToString(field.Precision)
                else
                    mreturn ""
            end
            mreturn ExpandFieldLoopToken(tkn, template, loops, doExpand)
        endmethod

        private static method expandFieldPrecision0, string
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            lambda doExpand(str, field) Convert.ToString(field.Precision)
            mreturn ExpandFieldLoopToken(tkn, template, loops, doExpand)
        endmethod

        private static method expandFieldPrecision2, string
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            lambda doExpand(str, field)
            begin
                if (field.Precision > 0) then
                    mreturn "." + Convert.ToString(field.Precision)
                else
                    mreturn ""
            end
            mreturn ExpandFieldLoopToken(tkn, template, loops, doExpand)
        endmethod

        private static method expandFieldPrompt, string
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            lambda doExpand(str, field) field.Prompt.Replace("""", "").Replace("^", "").Replace("<", "").Replace(">", "").Replace(":", "")
            mreturn ExpandFieldLoopToken(tkn, template, loops, doExpand)
        endmethod

        private static method expandFieldRangeMax, string
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            lambda doExpand(str, field) Convert.ToString(field.NumericRangeMaximum)
            mreturn ExpandFieldLoopToken(tkn, template, loops, doExpand)
        endmethod

        private static method expandFieldRangeMin, string
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            lambda doExpand(str, field) Convert.ToString(field.NumericRangeMinimum)
            mreturn ExpandFieldLoopToken(tkn, template, loops, doExpand)
        endmethod

        private static method expandFieldRegex, string
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            lambda doExpand(str, field) StringTools.FieldRegex(field)
            mreturn ExpandFieldLoopToken(tkn, template, loops, doExpand)
        endmethod

        private static method expandFieldReportJustification, string
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            lambda doExpand(str, field) field.ReportJustification.ToString()
            mreturn ExpandFieldLoopToken(tkn, template, loops, doExpand)
        endmethod

        private static method expandFieldRow, string
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            lambda doExpand(str, field)
            begin
                if (field.FieldRow > 0) then
                    mreturn Convert.ToString(field.FieldRow + field.ArrayDimension[1] - 1)
                else
                    mreturn Convert.ToString(field.LogicalFieldNumber)
            end
            mreturn ExpandFieldLoopToken(tkn, template, loops, doExpand)
        endmethod

        private static method expandFieldSampleData, string
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            lambda doExpand(str, field)
            begin
                data propValue = field.GetProperty<string>(template, "SAMPLE_DATA")
                if(propValue != ^null) then
                    mreturn propValue
                else
                begin
                    using field.DataType select
                    (RpsFieldDataType.Alpha),
                    begin
                        mreturn '"ABC"'
                    end
                    (RpsFieldDataType.Decimal),
                    begin
                        if (field.Precision) then
                            mreturn '1.23'
                        else
                            mreturn '123'
                    end
                    (RpsFieldDataType.Integer),
                    begin
                        mreturn '123'
                    end
                    (RpsFieldDataType.User),
                    begin
                        mreturn ''
                    end
                    (RpsFieldDataType.Boolean),
                    begin
                        mreturn 'True'
                    end
                    (RpsFieldDataType.Binary),
                    begin
                        mreturn ''
                    end
                    (RpsFieldDataType.AutoTime),
                    begin
                        mreturn ''
                    end
                    (RpsFieldDataType.StructField),
                    begin
                        mreturn ''
                    end
                    (RpsFieldDataType.AutoSequence),
                    begin
                        mreturn '123'
                    end
                    (RpsFieldDataType.Enum),
                    begin
                        mreturn ''
                    end
                    endusing
                end
            end
            mreturn ExpandFieldLoopToken(tkn, template, loops, doExpand)
        endmethod

        private static method expandFieldSampleDataNoQuotes, string
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            lambda doExpand(str, field)
            begin
                data startPos = field.LongDescription.IndexOf("SAMPLE_DATA=")
                data semiPos = -1
                if (startPos!=-1)
                    semiPos = field.LongDescription.IndexOf(";",startPos)

                if ((startPos!=-1) && (semiPos!=-1) && (semiPos>(startPos+12))) then
                begin
                    mreturn field.LongDescription.SubString(startPos+12,semiPos-startPos-12)
                end
                else
                begin
                    using field.DataType select
                    (RpsFieldDataType.Alpha),
                    begin
                        mreturn 'ABC'
                    end
                    (RpsFieldDataType.Decimal),
                    begin
                        if (field.Precision) then
                            mreturn '1.23'
                        else
                            mreturn '123'
                    end
                    (RpsFieldDataType.Integer),
                    begin
                        mreturn '123'
                    end
                    (RpsFieldDataType.User),
                    begin
                        mreturn ''
                    end
                    (RpsFieldDataType.Boolean),
                    begin
                        mreturn 'True'
                    end
                    (RpsFieldDataType.Binary),
                    begin
                        mreturn ''
                    end
                    (RpsFieldDataType.AutoTime),
                    begin
                        mreturn ''
                    end
                    (RpsFieldDataType.StructField),
                    begin
                        mreturn ''
                    end
                    (RpsFieldDataType.AutoSequence),
                    begin
                        mreturn '123'
                    end
                    (RpsFieldDataType.Enum),
                    begin
                        mreturn ''
                    end
                    endusing
                end
            end
            mreturn ExpandFieldLoopToken(tkn, template, loops, doExpand)
        endmethod

        private static method expandFieldSelectionCount, string
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            lambda doExpand(str, field)
            begin
                mreturn field.SelectionList.Count.ToString()
            end
            mreturn ExpandFieldLoopToken(tkn, template, loops, doExpand)
        endmethod

        private static method expandFieldSelections, string
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            lambda doExpand(str, field)
            begin
                if (field.SelectionList.Count > 0) then
                begin
                    data selections, string, ""
                    data selection, string
                    foreach selection in field.SelectionList
                        selections = selections + String.Format("""{0}"",", selection)
                    ;; Return the string without the trailing comma
                    mreturn selections.Substring(0, selections.Length - 1)
                end
                else
                    mreturn ""
            end
            mreturn ExpandFieldLoopToken(tkn, template, loops, doExpand)
        endmethod

        private static method expandFieldSelections1, string
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            lambda doExpand(str, field)
            begin
                if (field.SelectionList.Count > 0) then
                begin
                    data selections, string, """"
                    data selection, string
                    foreach selection in field.SelectionList
                        selections += String.Format("{0}|", selection)
                    ;; Return the string without the trailing pipe, and with a close quote
                    mreturn selections.Substring(0, selections.Length - 1) + """"
                end
                else
                    mreturn ""
            end
            mreturn ExpandFieldLoopToken(tkn, template, loops, doExpand)
        endmethod

        private static method expandFieldSelectionsCol, string
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            lambda doExpand(str, field) (field.SelectionList.Count > 1 || !String.IsNullOrWhiteSpace(field.SelectionWindowName)) && field.SelectionWindowColumn > 0 ? Convert.ToString(field.SelectionWindowColumn) : ""
            mreturn ExpandFieldLoopToken(tkn, template, loops, doExpand)
        endmethod

        private static method expandFieldSelectionsHeight, string
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            lambda doExpand(str, field) field.SelectionList.Count > 1 ? Convert.ToString(field.SelectionWindowHeight) : ""
            mreturn ExpandFieldLoopToken(tkn, template, loops, doExpand)
        endmethod

        private static method expandFieldSelectionsRow, string
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            lambda doExpand(str, field) (field.SelectionList.Count > 1 || !String.IsNullOrWhiteSpace(field.SelectionWindowName)) && field.SelectionWindowRow > 0 ? Convert.ToString(field.SelectionWindowRow) : ""
            mreturn ExpandFieldLoopToken(tkn, template, loops, doExpand)
        endmethod

        private static method expandFieldSelLength, string
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            lambda doExpand(str, field) Convert.ToString(field.SelectionListMaxLength)
            mreturn ExpandFieldLoopToken(tkn, template, loops, doExpand)
        endmethod

        private static method expandFieldSelWnd, string
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            lambda doExpand(str, field) field.SelectionWindowName.ToUpper()
            ;;This one is slightly different because the data from the repository is mixed case.
            ;;So we upper case it here before case processing.
            mreturn ExpandFieldLoopToken(tkn, template, loops, doExpand)
        endmethod

        private static method expandFieldSelWndOriginal, string
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            lambda doExpand(str, field) field.SelectionWindowName
            ;; This one is slightly different because the data from the repository is mixed case and this tokens purpose is to maintain the original casing.
            mreturn ExpandFieldLoopToken(tkn, template, loops, doExpand)
        endmethod

        private static method expandFieldSize, string
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            lambda doExpand(str, field) Convert.ToString(field.Size)
            mreturn ExpandFieldLoopToken(tkn, template, loops, doExpand)
        endmethod

        private static method expandFieldSnType, string
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            lambda doExpand(str, field) field.SnType
            mreturn ExpandFieldLoopToken(tkn, template, loops, doExpand)
        endmethod

        private static method expandFieldSnDefault, string
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            lambda doExpand(str, field) field.SnDefault
            mreturn ExpandFieldLoopToken(tkn, template, loops, doExpand)
        endmethod

        private static method expandFieldSpec, string
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            lambda doExpand(str, field)
            begin
                data tmpSpec, string, ""
                if ((field.IsGroup && !String.IsNullOrWhiteSpace(field.GroupStructure)) && template.Context.CurrentTask.ImplicitGroupNoExpand) then
                begin
                    ;; We've got an implicit group that has not been expanded
                    tmpSpec = String.Format("{0}{1}",field.TypeCode,Convert.ToString(field.Size))
                end
                else if ((field.IsGroup && String.IsNullOrWhiteSpace(field.GroupStructure)) && template.Context.CurrentTask.ExplicitGroupNoExpand) then
                begin
                    ;; We've got an explicit group that has not been expanded
                    tmpSpec = String.Format("{0}{1}",field.TypeCode,Convert.ToString(field.Size))
                end
                else
                begin
                    using (field.DataType) select
                    (RpsFieldDataType.Boolean),
                        tmpSpec = "BOOLEAN"
                    (RpsFieldDataType.Binary),
                    begin
                        tmpSpec = String.Format("{0}{1}",field.TypeCode,Convert.ToString(field.Size))
                    end
                    (RpsFieldDataType.StructField),
                    begin
                        data prefix = template.Context.Taskset.StructFieldPrefix
                        tmpSpec = String.IsNullOrWhiteSpace(prefix) ?  field.StructFieldStructure : String.Format("{0}{1}",prefix,field.StructFieldStructure)
                    end
                    (RpsFieldDataType.Enum),
                    begin
                        tmpSpec = field.EnumName
                    end
                    (),
                    begin
                        tmpSpec = String.Format("{0}{1}",field.TypeCode,Convert.ToString(field.Size))
                        if (field.Precision > 0)
                            tmpSpec += "." + Convert.ToString(field.Precision)
                    end
                    endusing
                end

                ;;Do we have an unexpanded array?
                if (template.Context.CurrentTask.PreserveArrays && ((Field.ArrayDimension[0]>1)||(Field.ArrayDimension[1])||(Field.ArrayDimension[2])||(Field.ArrayDimension[3])))
                begin
                    if (field.ArrayDimension[3]) then
                    begin
                        tmpSpec = String.Format("[{0},{1},{2},{3}]{4}",Field.ArrayDimension[0],Field.ArrayDimension[1],Field.ArrayDimension[2],Field.ArrayDimension[3],tmpSpec)
                    end
                    else if (field.ArrayDimension[2]) then
                    begin
                        tmpSpec = String.Format("[{0},{1},{2}]{3}",Field.ArrayDimension[0],Field.ArrayDimension[1],Field.ArrayDimension[2],tmpSpec)
                    end
                    else if (field.ArrayDimension[1]) then
                    begin
                        tmpSpec = String.Format("[{0},{1}]{2}",Field.ArrayDimension[0],Field.ArrayDimension[1],tmpSpec)
                    end
                    else
                    begin
                        tmpSpec = String.Format("[{0}]{1}",Field.ArrayDimension[0],tmpSpec)
                    end
                end

                mreturn tmpSpec
            end
            mreturn ExpandFieldLoopToken(tkn, template, loops, doExpand)
        endmethod

        private static method expandFieldSqlAltname, string
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            lambda doExpand(str, field) StringTools.SqlName(field.AlternateName)
            mreturn ExpandFieldLoopToken(tkn, template, loops, doExpand)
        endmethod

        private static method expandFieldSqlName, string
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            lambda doExpand(str, field)
            begin
                data task, @CodeGenTask, template.Context.CurrentTask
                if (task.Tweaks != ^null)
                begin
                    if (task.Tweaks.Contains("SQLNAMENO$")) then
                    begin
                        mreturn field.SqlName.Replace("$","")
                    end
                    else if (task.Tweaks.Contains("SQLNAME$$ID"))
                    begin
                        mreturn field.SqlName.Replace("$$","Id")
                    end
                end
                mreturn field.SqlName
            end
            mreturn ExpandFieldLoopToken(tkn, template, loops, doExpand)
        endmethod

        private static method expandFieldSqlType, string
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            lambda doExpand(str, field) field.SqlType
            mreturn ExpandFieldLoopToken(tkn, template, loops, doExpand)
        endmethod

        private static method expandFieldTemplate, string
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            lambda doExpand(str, field) field.Template
            mreturn ExpandFieldLoopToken(tkn, template, loops, doExpand)
        endmethod

        private static method expandFieldTkScript, string
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            lambda doExpand(str, field)
            begin
                if ((((field.PromptRow > 0) && (field.PromptColumn > 0)) && (field.FieldRow > 0)) && (field.FieldColumn > 0)) then
                    mreturn String.Format(".field {0}, pos({1},{2}), fpos({3},{4})", field.Name, field.PromptRow, field.PromptColumn, field.FieldRow, field.FieldColumn)
                else
                    mreturn String.Format(".field {0}, pos({1},1)", field.Name, field.LogicalFieldNumber)
            end
            mreturn ExpandFieldLoopToken(tkn, template, loops, doExpand)
        endmethod

        private static method expandFieldTsDefault, string
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            lambda doExpand(str, field) field.TsDefault
            mreturn ExpandFieldLoopToken(tkn, template, loops, doExpand)
        endmethod

        private static method expandFieldTsType, string
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            lambda doExpand(str, field) field.TsType
            mreturn ExpandFieldLoopToken(tkn, template, loops, doExpand)
        endmethod

        private static method expandFieldType, string
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            lambda doExpand(str, field) field.TypeCode
            mreturn ExpandFieldLoopToken(tkn, template, loops, doExpand)
        endmethod

        private static method expandFieldTypeName, string
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            lambda doExpand(str, field) field.TypeName
            mreturn ExpandFieldLoopToken(tkn, template, loops, doExpand)
        endmethod

        private static method expandFieldUserType, string
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            lambda doExpand(str, field) field.UserFieldType
            mreturn ExpandFieldLoopToken(tkn, template, loops, doExpand)
        endmethod

        private static method expandFieldUserText, string
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            lambda doExpand(str, field) field.UserText
            mreturn ExpandFieldLoopToken(tkn, template, loops, doExpand)
        endmethod

        private static method expandFieldVbDefault, string
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            lambda doExpand(str, field) field.VbDefault
            mreturn ExpandFieldLoopToken(tkn, template, loops, doExpand)
        endmethod

        private static method expandFieldVbType, string
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            lambda doExpand(str, field) field.VbType
            mreturn ExpandFieldLoopToken(tkn, template, loops, doExpand)
        endmethod

        private static method expandFieldViewLength, string
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            lambda doExpand(str, field) Field.ViewLength > 0 ? Convert.ToString(field.ViewLength) : ""
            mreturn ExpandFieldLoopToken(tkn, template, loops, doExpand)
        endmethod

        private static method expandFieldNumber, string
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            lambda doExpand(str, field) Convert.ToString(field.FieldNumber)
            mreturn ExpandFieldLoopToken(tkn, template, loops, doExpand)
        endmethod

        private static method expandFieldNumberZero, string
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            lambda doExpand(str, field) Convert.ToString(field.FieldNumber - 1)
            mreturn ExpandFieldLoopToken(tkn, template, loops, doExpand)
        endmethod

        private static method expandFieldNumberLogical, string
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            lambda doExpand(str, field) Convert.ToString(field.LogicalFieldNumber)
            mreturn ExpandFieldLoopToken(tkn, template, loops, doExpand)
        endmethod

        private static method expandFieldNumberLogicalZero, string
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            lambda doExpand(str, field) Convert.ToString(field.LogicalFieldNumber - 1)
            mreturn ExpandFieldLoopToken(tkn, template, loops, doExpand)
        endmethod

        private static method expandFieldMappedField, string
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            lambda doExpand(str, field)
            begin
                data value, string, ""
                if (!String.IsNullOrWhiteSpace(field.MappedField)) then
                    value = field.MappedField.ToUpper()
                else
                begin
                    using (field.TypeCode) select
                    ("A", "U"),
                        value = '""'
                    ("D", "I"),
                        value = "0"
                    ("@"),
                        value = String.Format("new {0}()", field.TypeCode)
                    endusing
                end
                mreturn value
            end
            mreturn ExpandFieldLoopToken(tkn, template, loops, doExpand)
        endmethod

        private static method expandFieldMappedPath, string
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            lambda doExpand(str, field)
            begin
                if (String.IsNullOrWhiteSpace(str.MappedStructure)) then
                    throw new ApplicationException(template.GetTokenErrorMessage(tkn, String.Format("requires structure {0} be mapped to another structure", str.Name)))
                else
                begin
                    data value, string, ""
                    if (!String.IsNullOrWhiteSpace(field.MappedField)) then
                        value = String.Format("{0}.{1}", str.MappedStructure.ToUpper(), field.MappedField.ToUpper())
                    else
                    begin
                        using (field.TypeCode) select
                        ("A", "U"),
                            value = '""'
                        ("D", "I"),
                            value = "0"
                        ("@"),
                            value = String.Format("new {0}()", field.TypeCode)
                        endusing
                    end
                    mreturn value
                end
            end
            mreturn ExpandFieldLoopToken(tkn, template, loops, doExpand)
        endmethod

        private static method expandFieldMappedPathConv, string
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            lambda doExpand(str, field)
            begin
                if (String.IsNullOrWhiteSpace(str.MappedStructure)) then
                    throw new ApplicationException(template.GetTokenErrorMessage(tkn, String.Format("requires structure {0} be mapped to another structure", str.Name)))
                else
                begin
                    data value, string, ""
                    if (!String.IsNullOrWhiteSpace(field.MappedField)) then
                        value = String.Format("{0}.{1}", str.MappedStructure.ToUpper(), field.MappedField.ToUpper())
                    else
                    begin
                        using (field.TypeCode) select
                        ("A", "U"),
                            value = '""'
                        ("D", "I"),
                            value = "0"
                        ("@"),
                            value = String.Format("new {0}()", field.TypeCode)
                        endusing
                    end
                    if (!String.IsNullOrWhiteSpace(field.MappingFunction))
                        value = String.Format("%{0}({1})", field.MappingFunction.ToUpper(), value)
                    mreturn value
                end
            end
            mreturn ExpandFieldLoopToken(tkn, template, loops, doExpand)
        endmethod

        private static method expandMappingFunction, string
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            lambda doExpand(str, field) field.MappingFunction
            mreturn ExpandFieldLoopToken(tkn, template, loops, doExpand)
        endmethod

        private static method expandUnmappingFunction, string
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            lambda doExpand(str, field) field.UnmappingFunction
            mreturn ExpandFieldLoopToken(tkn, template, loops, doExpand)
        endmethod

        private static method expandFieldPromptCol, string
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            lambda doExpand(str, field)
            begin
                if (field.PromptColumn != 0) then
                    mreturn Convert.ToString(field.PromptColumn)
                else
                    mreturn Convert.ToString(DefaultValues.DefaultFieldPromptColumn)
            end
            mreturn ExpandFieldLoopToken(tkn, template, loops, doExpand)
        endmethod

        private static method expandFieldPromptPixelCol, string
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            lambda doExpand(str, field)
            begin
                data width, int, DefaultValues.DefaultCharacterWidth
                if (template.Context.CurrentTask.CharacterWidth > 0)
                    width = template.Context.CurrentTask.CharacterWidth
                if (field.PromptColumn > 0) then
                    mreturn Convert.ToString((field.PromptColumn * width) - (width - 1))
                else
                    mreturn Convert.ToString((DefaultValues.DefaultFieldPromptColumn * width) - (width - 1))
            end
            mreturn ExpandFieldLoopToken(tkn, template, loops, doExpand)
        endmethod

        private static method expandFieldPromptPixelRow, string
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            lambda doExpand(str, field)
            begin
                data height, int, DefaultValues.DefaultCharacterHeight
                if (template.Context.CurrentTask.CharacterHeight > 0)
                    height = template.Context.CurrentTask.CharacterHeight
                if (field.PromptRow > 0) then
                    mreturn Convert.ToString(((field.PromptRow + field.ArrayDimension[1] - 1) * height) - (height - 1))
                else
                    mreturn Convert.ToString((field.LogicalFieldNumber * height) - (height - 1))
            end
            mreturn ExpandFieldLoopToken(tkn, template, loops, doExpand)
        endmethod

        private static method expandFieldPromptPixelWidth, string
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            data width, int, DefaultValues.DefaultCharacterWidth
            if (template.Context.CurrentTask.CharacterWidth > 0)
                width = template.Context.CurrentTask.CharacterWidth
            lambda doExpand(str, field) Convert.ToString(field.Prompt.Length * width)
            mreturn ExpandFieldLoopToken(tkn, template, loops, doExpand)
        endmethod

        private static method expandFieldPromptRow, string
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            lambda doExpand(str, field)
            begin
                if (field.PromptRow > 0) then
                    mreturn Convert.ToString(field.PromptRow + field.ArrayDimension[0] - 1)
                else
                    mreturn Convert.ToString(field.LogicalFieldNumber)
            end
            mreturn ExpandFieldLoopToken(tkn, template, loops, doExpand)
        endmethod

        private static method expandFieldHarmonyRoles, string
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            lambda doExpand(str, field)
            begin
                data propValue = field.GetProperty<string>(template, "HARMONY_ROLES")
                if(propValue != ^null) then
                    mreturn propValue
                else
                begin
                    mreturn ""
                end
            end
            mreturn ExpandFieldLoopToken(tkn, template, loops, doExpand)
        endmethod

        private static method expandFieldPromptPositionCol, string
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            lambda doExpand(str, field) field.PromptPositionMode == RpsPositionMode.None ? "" : field.PromptColumn.ToString()
            mreturn ExpandFieldLoopToken(tkn, template, loops, doExpand)
        endmethod

        private static method expandFieldPromptPositionMode, string
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            lambda doExpand(str, field) field.PromptPositionMode.ToString()
            mreturn ExpandFieldLoopToken(tkn, template, loops, doExpand)
        endmethod

        private static method expandFieldPromptPositionRow, string
            tkn, @Token 
            template, @FileNode 
            loops, @IEnumerable<LoopNode> 
            endparams
        proc
            lambda doExpand(str, field) field.PromptPositionMode == RpsPositionMode.None ? "" : field.PromptRow.ToString()
            mreturn ExpandFieldLoopToken(tkn, template, loops, doExpand)
        endmethod

    endclass

endnamespace
