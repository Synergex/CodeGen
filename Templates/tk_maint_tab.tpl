<CODEGEN_FILENAME><structure_name>_maint_tab.dbl</CODEGEN_FILENAME>
;//****************************************************************************
;//
;// Title:       tk_maint_tab.tpl
;//
;// Type:        CodeGen Template
;//
;// Description: This template creates a tab-based master file maintenance
;//              program for a structure and file defined in repository.
;//
;// Date:        19th March 2007
;//
;// Author:      Steve Ives, Synergex Professional Services Group
;//              http://www.synergex.com
;//
;//****************************************************************************
;//
;// Copyright (c) 2012, Synergex International, Inc.
;// All rights reserved.
;//
;// Redistribution and use in source and binary forms, with or without
;// modification, are permitted provided that the following conditions are met:
;//
;// * Redistributions of source code must retain the above copyright notice,
;//   this list of conditions and the following disclaimer.
;//
;// * Redistributions in binary form must reproduce the above copyright notice,
;//   this list of conditions and the following disclaimer in the documentation
;//   and/or other materials provided with the distribution.
;//
;// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
;// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
;// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
;// ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
;// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
;// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
;// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
;// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
;// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
;// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
;// POSSIBILITY OF SUCH DAMAGE.
;//
;;*****************************************************************************
;;
;; Routine:     <STRUCTURE_NAME>_MAINT_TAB
;;
;; Description: Master file maintenance for <STRUCTURE_NAME> structure
;;
;; Author:      <AUTHOR>
;;
;; Company:     <COMPANY>
;;
;;*****************************************************************************
;;
;; WARNING:     This code was generated by CodeGen. Any changes that you make
;;              to this file will be lost if the code is regenerated.
;;
;;*****************************************************************************
;
; This routine first builds and processes a tab set which allows searching the
; master file based on multiple keys.  The first page of the tab set allows
; the user to select the key to be used, and optionally enter a partial value
; for the key search.  For example, for a customer file, searches may be done
; by account number, company name, city, state, zip code etc.  The user could
; for example select company name, and enter S to search for all customers
; beginning with S.  When the user clicks OK or hits return, the results are
; shown in a list on the second tab page.
;
; When the user clicks on or hits return on a record in the results list, the
; routine presents a second tab set containing multiple pages allowing them
; to maintain the record.
;
; The routine also supports creating new records, deleting records and printing
; a master file listing.  These functions can all be supressed if not required.
;
; The routine requires several windows to be present in the window library
; referred to by g_utlib. The names of those windows are constructed using a
; base window name which is the name of the structure:
;
;    <STRUCTURE_NAME>_CTA        ;Search criteria input window
;    <STRUCTURE_NAME>_LUP        ;Search results list input window
;    <STRUCTURE_NAME>n           ;Multiple input windows for the input tab set
;
; In constructing these windows you must comply with the following requirements:
;
; Search criteria input window
; ----------------------------
;
; Must be named <STRUCTURE_NAME>_CTA and fields MUST be defined in a structure
; called <STRUCTURE_NAME>_CRITERIA
;
; The size of this window will determine the size of the search tabset.
; The first field in the window MUST be a D1 called MODE.  This field indicates
; the search mode (in other words which key to read the master file on when
; searching).  The field should normally be an enumerated selection list
; (displayed as radio buttons or a dropdown list).  The base enumeration value
; MUST be 1 and the step value MUST be 1. The field MUST specify a change method
; name of "<structure_name>_mntmode".
;
; For each selectable item in the MODE field there should be an ALPHA field of
; the appropriate size for the key value required.  These fields MUST be named
; FIELD<n> (FIELD1, FIELD2 etc.)
;
; There MUST be 2 sets defined in the window. The first set MUST be called ALL
; and MUST contain all fields in the window.  The second set MUST be called DATA
; and must contain all fields except MODE.
;
; I would recommend defining these fields in a repository structure.
;
; The keys referred to by the various MODE options MUST be encoded into the
; title of the window, as a string of D2 values.  For example, if the first
; search option uses key 2 and the second search option uses key 4, the title of
; the criteria window MUST be set to 0204
;
; An example of a search criteria window would be:
;
;       .input <STRUCTURE_NAME>_CTA, 20, 88
;       .title "0300040105"
;       .repository_structure <STRUCTURE_NAME>_CRITERIA
;       .field MODE, pos(2, 4), fpos(2, 14)
;       .field FIELD1, fpos(2, 38)
;       .field FIELD2, fpos(3, 38)
;       .field FIELD3, fpos(4, 38)
;       .field FIELD4, fpos(5, 38)
;       .field FIELD5, fpos(6, 38)
;       .set ALL, <STRUCTURE_NAME>_CRITERIA, MODE, FIELD1, FIELD2, FIELD3, FIELD4, FIELD5
;       .set DATA, <STRUCTURE_NAME>_CRITERIA, FIELD1, FIELD2, FIELD3, FIELD4, FIELD5
;       .end
;
; Search results list input window
; --------------------------------
;
; MUST be named <STRUCTURE_NAME>_LUP and MUST be one row high
;
; MUST be based on the Repository structure of the master file being maintained,
; and should contain the fields to define the columns to view in the results
; list.  Fields should have prompts and methods disabled, and should be
; positioned adjacent to each other.
;
; An example of a search results list input window would be:
;
;    .input <STRUCTURE_NAME>_LUP, 1, 67
;    .border on, dragbar(on)
;    .repository_structure <STRUCTURE_NAME>
;    .field CODE, noprompt, fpos(1, 1), nochange_method, nodrill_method
;    .field NAME, noprompt, fpos(1, 7)
;    .field CITY, noprompt, fpos(1, 33)
;    .field STATE, noprompt, fpos(1, 54), nochange_method, nodrill_method
;    .field AKEY, noprompt, fpos(1, 57)
;    .end
;
; Maintenance tabset input windows
; --------------------------------
;
; Must be named <STRUCTURE_NAME>n (e.g. <STRUCTURE_NAME>1, <STRUCTURE_NAME>2 etc.)
;
; The size of the largest window determines the size of the maintenance tabset.
; The title of each window will be the selection text on that windows tab. Each
; window MUST be based on the repository structure being maintained.  This MAY
; be a super-structure which contains the actual master file's structure and
; additional local display field definitions. If this is the case, then the
; group representing the actual master file MUST be the first field in the
; super-structure, followed by the additional display fields, which MUST be
; named in the format <field>_DSP, and MUST have either the disabled or
; read-only attribute set.  The name of the super-structure MUST be defined as
; <STRUCTURE_NAME>_INPUT.
;
; In ALL windows the first set MUST be called ALL and must contain ALL fields
; (including local display fields). The FIRST window must also have 2 additional
; sets, one called KEY (which must include only the primary key field) and one
; called DATA (which must include all fields except the primary key field).
;
;******************************************************************************
;
subroutine <structure_name>_maint_tab

    ;Required arguments
    a_base_title        ,a      ;Base text for tabset titles (e.g."Customer")

    ;Optional arguments
    a_channel           ,n      ;Master file update mode channel
    a_lst_header        ,a      ;Search list column headers
    a_lst_footer        ,a      ;Search list footer
    a_icon              ,a      ;Icon file name
    a_no_amend          ,n      ;Suppress "Amend" (view obly)
    a_no_create         ,n      ;Suppress "New" button
    a_no_delete         ,n      ;Suppress "Delete" button
    a_no_print          ,n      ;Suppress "Print" button
    a_no_help           ,n      ;Suppress "Help" button

    endparams

    .include "WND:tools.def"
    .include "WND:fldinf.def"
    .include "WND:setinf.def"
    .include "WND:windows.def"
    .include "DBLDIR:activex.def"
    .include "CODEGEN_INC:system.def"
    .include "CODEGEN_INC:structure_io.def"

    ;Main data buffers
    .include "<STRUCTURE_NOALIAS>" repository, stack record="<structure_name>", nofields
    .include "<STRUCTURE_NOALIAS>" repository, stack record="<structure_name>_save", nofields
    .include "<STRUCTURE_NOALIAS>_INPUT" repository, stack record="<structure_name>_input", nofields
    .include "<STRUCTURE_NOALIAS>_CRITERIA" repository, stack record="criteria", nofields
    .include "<STRUCTURE_NOALIAS>_CRITERIA" repository, stack record="last_criteria", nofields

    stack record ivars

        ok              ,i4     ;OK to continue
        error           ,i4     ;An error was detected

        channel         ,i4     ;Master file channel

        idi_criteria    ,i4     ;Search criteria input window
        idi_results     ,i4     ;Search list input window ID
        clsid           ,i4     ;Search list class
        idl_results     ,i4     ;Search results list
        req             ,i4     ;List processor request flag
        control         ,i4     ;Search results list AX control ID
        idt_search      ,i4     ;Search criteria / results tabset
        headers         ,i4     ;# of search list header lines
        footers         ,i4     ;# of search list footer lines

        idi_maint       ,[10]i4 ;Maintenance window ID's
        idt_maint       ,i4     ;Maintenance tabset ID

        count           ,i4     ;Local counter
        tabcount        ,i4     ;Number of pages in tabset
        nullitem        ,i4     ;Current list item is null

        rows            ,i4     ;Height of window
        maxrows         ,i4     ;Maximum height of any window

        cols            ,i4     ;Width of window
        maxcols         ,i4     ;Maximum width of any window

        creating        ,i4     ;Creating a new record

        set_number      ,i4     ;Input set number

        no_amend        ,i4     ;Suppress "Amend" (view only)
        no_create       ,i4     ;Suppress "New" button
        no_delete       ,i4     ;Suppress "Delete" button
        no_print        ,i4     ;Suppress "Print" button
        no_help         ,i4     ;Suppress "Help" button

    endrecord

    stack record avars

        wndname         ,a15    ;Window name
        setname         ,a5     ;Name of current input set
        wintitle        ,a50    ;Window title
        keynums         ,[10]d2 @wintitle   ;Array of search key numbers extracted from window title
        keynum          ,d2     ;Current key to use
        keyval          ,a80    ;Key value to match on
        winattr         ,2d3    ;Window title attributes
        keyfldname      ,a30    ;Input field name
        msgtext         ,a80    ;Message text

    endrecord

proc

    ;Initialize data
    clear <structure_name>, <structure_name>_save, <structure_name>_input
    clear criteria, last_criteria
    clear ^i(ivars), avars
    ok=true

    ;Validate required parameters

    if ((!^passed(a_base_title))||(!a_base_title))
    begin
        xcall u_msgbox("Parameter 1 (base window title) was not passed or was blank.",
        &              D_MOK+D_MICONSTOP,"Error")
        clear ok
    end

    ;Process optional parameters

    if (ok)
    begin

        if (^passed(a_lst_header)&&a_lst_header)
            headers=1

        if (^passed(a_lst_footer)&&a_lst_footer)
            footers=1

        if (^passed(a_no_create)&&a_no_create)
            no_create = TRUE

        if (^passed(a_no_delete)&&a_no_delete)
            no_delete = TRUE

        if (^passed(a_no_print)&&a_no_print)
            no_print = TRUE

        if (^passed(a_no_help)&&a_no_help)
            no_help = TRUE

        if (^passed(a_no_amend)&&a_no_amend)
        begin
            no_amend = TRUE
            no_create = TRUE
            no_delete = TRUE
        end

    end

    xcall e_enter

    ;Open master file (if not passed an open channel to the file)

    if (^passed(a_channel)&&a_channel&&%chopen(a_channel)) then
        channel = a_channel
    else
    begin

        if (%<Structure_Name>Io(IO_OPEN_UPD,channel)!=IO_OK)
        begin
            xcall u_msgbox("Failed to open file <FILE_NAME>",D_MOK+D_MICONSTOP,"Error")
            clear ok
        end
    end

    ;Build the search tabset

    if (ok)
    begin

        ;Load search criteria input window
        xcall i_ldinp(idi_criteria,,"<STRUCTURE_NAME>_CTA",D_NOPLC,,error)
        if (error) then
        begin
            xcall u_msgbox("Failed to load input window <STRUCTURE_NAME>_CTA.",D_MOK+D_MICONSTOP,"Error")
            ok=false
        end
        else
        begin
            ;Get window dimensions
            rows = %w_info(WIF_ROWS,idi_criteria)
            cols = %w_info(WIF_COLS,idi_criteria)

            ;Extract key numbers, set title & disable fields
            xcall w_info(WI_TITLE,idi_criteria,wintitle,winattr)
            xcall w_brdr(idi_criteria,WB_TITLE,"Criteria")
            xcall i_disable(D_SET,idi_criteria,"DATA")
            xcall i_enable(D_FLDS,idi_criteria,"FIELD1")
            xcall i_next(idi_criteria,,"FIELD1")
        end

        ;Create search results list
        if (ok)
        begin

            ;Load list input window
            if (ok)
            begin
                xcall i_ldinp(idi_results,,"<STRUCTURE_NAME>_LUP",D_NOPLC,,error)
                if (error) then
                begin
                    xcall u_msgbox("Failed to load input window <STRUCTURE_NAME>_LUP.",D_MOK+D_MICONSTOP,"Error")
                    clear ok
                end
                else
                    xcall w_brdr(idi_results,WB_TITLE,"Results")
            end

            ;Create list class
            if (ok)
            begin
                xcall l_class(clsid,"TKM_SRCHCLASS",2,2,15,headers,,footers,1,,,"<structure_name>_mntload","ACTIVEX",error)
                if (error)
                begin
                    xcall u_msgbox("Failed to create list class TKM_SRCHCLASS",D_MOK+D_MICONSTOP,"Error")
                    clear ok
                end
            end

            ;Create list
            if (ok)
            begin
                xcall l_create(idl_results,idi_results,<structure_name>,,"TKM_SRCHCLASS",,,D_NOPLC,,,,error)
                if (error)
                begin
                    xcall u_msgbox("Failed to create search list",D_MOK+D_MICONSTOP,"Error")
                    clear ok
                end

            end

            ;Configure list
            if (ok)
            begin

                ;Header
                if (headers)
                    xcall l_sect(idl_results,a_lst_header,D_HEADER)

                ;Footer
                if (footers)
                    xcall l_sect(idl_results,a_lst_footer,D_FOOTER)

                ;Customize AX control parameters
                xcall l_status(idl_results, D_LAXCTRL, control)
                xcall ax_set(control,"RowMode",1)
                xcall ax_set(control,"LightItemColor",RGB_VALUE(255,255,180))
                xcall ax_set(control,"SelBackColor",RGB_VALUE(0,0,180))

            end

        end

        ;Create search tabset

        if (ok)
        begin

            ;Create tab container and add pages

            idt_search=%ts_tabset(DTS_CREATE,"TKM_SEARCH",rows,cols)
            xcall ts_tabset(DTS_WINDOW,idt_search,idi_criteria,"<structure_name>_mntcta",,"Specify search criteria")
            xcall ts_tabset(DTS_LIST,  idt_search,idl_results, "<structure_name>_mntlst",,"View search results")

            ;Set tab container title

            xcall w_brdr(idt_search,WB_TITLE,%atrim(a_base_title) + " Search")

            ;Add buttons to tab container

            xcall ts_tabset(DTS_BUTTON,idt_search,"SEARCH",DSB_TEXT,"Search")

            if (no_amend) then
                xcall ts_tabset(DTS_BUTTON,idt_search,"AMEND", DSB_TEXT,"View")
            else
                xcall ts_tabset(DTS_BUTTON,idt_search,"AMEND", DSB_TEXT,"Amend")

            if (!no_create)
                xcall ts_tabset(DTS_BUTTON,idt_search,"CREATE",DSB_TEXT,"Create")

            if (!no_delete)
                xcall ts_tabset(DTS_BUTTON,idt_search,"DELETE",DSB_TEXT,"Delete")

            if (!no_print)
                xcall ts_tabset(DTS_BUTTON,idt_search,"PRINT", DSB_TEXT,"Print")

            if (!no_help)
                xcall ts_tabset(DTS_BUTTON,idt_search,"O_HELP",DSB_TEXT,"Help")

            xcall ts_tabset(DTS_BUTTON,idt_search,"CANCEL",DSB_TEXT,"Close")
            xcall ts_tabset(DTS_BUTTONSET,idt_search,,,DSB_END,"SEARCH")

            if (wndevent_close)
            begin
                xcall u_wndevents(D_ASSIGN,wndevent_close,idt_search)
                if (^passed(a_icon)&&a_icon)
                    xcall u_icon(D_ICONSET,a_icon,1,idt_search)
            end

        end

    end

    ;Build the maintenance tabset
    if (ok)
    begin

        ;Load input windows
        repeat
        begin

            tabcount+=1

            if (tabcount>10)
            begin
                tabcount-=1
                xcall u_msgbox("Too many input windows, using first 10.",D_MOK+D_MICONEXCLAM,"Warning")
                exitloop
            end

            wndname = "<STRUCTURE_NAME>" + %string(tabcount)

            xcall i_ldinp(idi_maint[tabcount],,wndname,,,error)
            if (error) then
            begin

                if (tabcount==1) then
                begin
                    xcall s_bld(msgtext,,"Failed to load window %a.",wndname)
                    xcall u_msgbox(msgtext,D_MOK+D_MICONSTOP,"Error")
                    ok=false
                end
                else
                    tabcount-=1
                exitloop

            end
            else
            begin

                ;Make sure the first set is called "ALL"
                xcall i_setinf(idi_maint[tabcount],setname="",1)
                if (setname!="ALL ")
                begin
                    xcall s_bld(msgtext,,"First SET in window %a should be ALL.  It is actually %a.",wndname,setname)
                    xcall u_message(msgtext,D_MOK+D_MICONSTOP)
                    ok = FALSE
                    exitloop
                end

                ;For first window, make sure we have key and data sets
                if (tabcount==1)
                begin

                    xcall i_setinf(idi_maint[tabcount],setname="",2)
                    if (setname!="KEY ")
                    begin
                        xcall s_bld(msgtext,,"Second SET in window %a should be KEY.  It is actually %a.",wndname,setname)
                        xcall u_message(%atrim(msgtext))
                        ok = FALSE
                    end

                    xcall i_setinf(idi_maint[tabcount],setname="",3)
                    if (setname!="DATA ")
                    begin
                        xcall s_bld(msgtext,,"Third SET in window %a should be DATA.  It is actually %a.",wndname,setname)
                        xcall u_message(%atrim(msgtext))
                        ok = FALSE
                    end

                    if (!ok)
                        exitloop

                end

                ;Get window dimensions

                if ((rows=%w_info(WIF_ROWS,idi_maint[tabcount])) > maxrows )
                    maxrows=rows

                if ((cols=%w_info(WIF_COLS,idi_maint[tabcount])) > maxcols)
                    maxcols=cols

                ;For window 1 make sure there are no drill or change methods on the key field
                if (tabcount==1)
                begin
                    xcall i_setinf(idi_maint[tabcount],"KEY",set_number,,gs_fldset)
                    clear keyfldname
                    xcall i_fldinf(idi_maint[tabcount],keyfldname,gs_setfldi(1),,gs_inpfld)
                    xcall i_fldmod(idi_maint[tabcount],keyfldname,,,D_OFF,D_FLD_DRILL,D_FLD_CHANGE)
                end

            end

        end

        if (ok)
        begin

            ;Create tabset
            idt_maint=%ts_tabset(DTS_CREATE,"TKM_MAINT",maxrows,maxcols)

            ;Add tab pages
            for count from 1 thru tabcount
                xcall ts_tabset(DTS_WINDOW,idt_maint,idi_maint[count],"<structure_name>_mntinp")

            ;Add buttons
            xcall ts_tabset(DTS_BUTTON,idt_maint,"OK",DSB_TEXT,"OK")
            xcall ts_tabset(DTS_BUTTON,idt_maint,"CANCEL",DSB_TEXT,"Cancel")
            xcall ts_tabset(DTS_BUTTON,idt_maint,"O_HELP",DSB_TEXT,"Help")
            xcall ts_tabset(DTS_BUTTONSET,idt_maint,,,DSB_END)

            ;Set title
            xcall w_brdr(idt_maint,WB_TITLE,%atrim(a_base_title) + " Maintenance")

            if (wndevent_close)
            begin
                xcall u_wndevents(D_ASSIGN,wndevent_close,idt_maint)
                if (^passed(a_icon)&&a_icon)
                    xcall u_icon(D_ICONSET,a_icon,1,idt_maint)
            end
        end

    end

    ;Process search tabset
    if (ok)
    begin

        xcall position_window(idt_search)
        criteria = "1"
        xcall i_display(idi_criteria,"ALL",criteria)
        xcall i_next(idi_criteria,"ALL","FIELD1")
        keynum = keynums[1]
        clear keyval

        repeat
        begin

            xcall ts_process(idt_search,idt_search,channel,criteria,
            &                <structure_name>,keynums,keynum,keyval,last_criteria,
            &                no_create,no_delete,no_print)

            using g_entnam select
            ("SEARCH"),
            begin
                ;Criteria page was active, go to results page
                xcall ts_tabset(DTS_ACTIVE,idt_search,2)
            end
            ("AMEND"),
            begin
                call check_null
                if (!nullitem)
                begin
                    clear creating
                    call maintain
                end
            end
            ("CREATE"),
            begin
                creating = TRUE
                call maintain
            end
            ("DELETE"),
            begin
                call check_null
                if (!nullitem)
                    call delete
            end
            ("PRINT"),
            begin
                call check_null
                if (!nullitem)
                    call print_search_results
            end
            ("CANCEL"),
                exitloop
            endusing

        end

    end

    xcall e_exit

    xreturn

check_null,

    xcall l_status(idl_results,D_LNULL,nullitem)
    if (nullitem)
    begin
        xcall u_msgbox("No records match your search criteria.\nTry different search criteria.",D_MOK+D_MICONINFO,"No Matches")
        xcall ts_tabset(DTS_ACTIVE,idt_search,1)
    end

    return

;---------------------------------------------------------------------------------------------------
;
maintain,

    ok=TRUE
    clear <structure_name>_input

    ;Save data as it currently appears in search results list
    <structure_name>_save = <structure_name>

    if (!creating)
    begin
        ;Read record from file to lock and ensure latest copy
        if (%<Structure_Name>Io(IO_READ,channel,%keyval(channel,<structure_name>,0),0,<structure_name>,IO_LOCK)==IO_OK) then
        begin
            ;Save data as read from file
            <structure_name>_save = <structure_name>
        end
        else
        begin
            ;Read failed
            xcall u_msgbox("Unable to lock record.",D_MOK+D_MICONEXCLAM)
            <structure_name> = <structure_name>_save
            ok=FALSE
        end
    end

    if (ok)
    begin

        if (creating) then
        begin
            ;Enable key set on page 1
            xcall i_enable(D_SET,idi_maint[1],setname="KEY")

        end
        else
        begin
            ;Load the data into the input record
            <structure_name>_input = <structure_name>
            ;Disable key set on pae 1
            xcall i_disable(D_SET,idi_maint[1],setname="KEY")
        end

        ;Load data into input forms
        for count from 1 thru tabcount
        begin
            xcall i_init(idi_maint[count],"ALL")
            if (!creating)
            begin
                xcall i_display(idi_maint[count],"ALL",<structure_name>_input)
                xcall i_next(idi_maint[count],"ALL","*FRST*")
                xcall display_local_fields(idi_maint[count],<structure_name>_input)
                if (no_amend)
                    xcall i_disable(D_SET,idi_maint[count],"ALL")
            end
        end

        ;Make sure tab 1 is displayed
        xcall ts_tabset(DTS_ACTIVE,idt_maint,1)

        ;Place maintenance tabset on screen
        xcall position_window(idt_maint,,idt_search,2,5)

        ;Process maintenance tabset
        repeat
        begin

            xcall ts_process(idt_maint,<structure_name>_input)

            using g_entnam select

            ("OK"),
            begin

                ;Validate required fields
                ok=TRUE
                for count from 1 thru tabcount
                begin
                    if (!%i_checkdata(idi_maint[count],"ALL",<structure_name>_input))
                    begin
                        xcall ts_tabset(DTS_ACTIVE,idt_maint,count)
                        ok=FALSE
                        exitloop
                    end
                end

                ;Back to input if required fields are missing
                if (!ok)
                    nextloop

                call save_record

                if (ok)
                    exitloop

            end

            ("CANCEL"),
            begin
                ;Drop the record lock
                unlock channel
                <structure_name> = <structure_name>_save
                exitloop
            end

            endusing

        end

        xcall u_window(D_REMOVE,idt_maint)

    end

    return


save_record,

    ok=TRUE

    ;Load data into master file record
    <structure_name> = <structure_name>_input

    if (creating) then
    begin

        ;CREATE NEW RECORD

        if ((error=%<Structure_Name>Io(IO_CREATE,channel,,,<structure_name>))==IO_OK) then
        begin

            ;If we're on the search results list page
            if (%ts_tabset(DTS_ACTIVE,idt_search)==2)
            begin
                ;Add the new record to the list
                xcall l_process(idl_results,req=D_LAPPEND,<structure_name>_save)
                xcall l_process(idl_results,req=D_LNOP,<structure_name>)
                xcall i_display(idi_results,,<structure_name>)
            end

        end
        else
        begin

            if (error==IO_DUP_KEY) then
            begin
                ;Back to maintenance to change primary key
                xcall u_msgbox("Record already exists",D_MOK+D_MICONINFO)
                xcall i_init(idi_maint[1],"ALL",<structure_name>_input,keyfldname)
                xcall i_next(idi_maint[1],"ALL",keyfldname)
                xcall ts_tabset(DTS_ACTIVE,idt_maint,1)
                ok=false
            end
            else
            begin
                xcall u_msgbox("Failed to save new record",D_MOK+D_MICONINFO)
            end
        end

    end
    else
    begin

        ;AMEND EXISTING RECORD

        ;Update record in file
        if (%<Structure_Name>Io(IO_UPDATE,channel,,,<structure_name>)!=IO_OK) then
        begin
            xcall u_msgbox("Unable to update record.",D_MOK+D_MICONEXCLAM)
            <structure_name> = <structure_name>_save
        end
        else
            xcall i_display(idi_results,,<structure_name>)
    end

    return

delete,

    ;Save data as it currently appears in search results list
    <structure_name>_save = <structure_name>

    ;Read record from file to lock and ensure latest copy
    if (%<Structure_Name>Io(IO_READ,channel,%keyval(channel,<structure_name>,0),0,<structure_name>,IO_LOCK)==IO_OK) then
    begin
        xcall s_bld(msgtext,,"Delete %a %d ?",a_base_title,%keyval(channel,<structure_name>,0))
        if (%u_msgbox(msgtext,D_MYESNO+D_MICONQUESTION+D_MDEFBUTTON2,"Confirm")==D_MIDYES)
        begin
            if (%<Structure_Name>Io(IO_DELETE,channel)==IO_OK) then
                xcall l_queue(idl_results,D_LDELITEM)
            else
            begin
                <structure_name> = <structure_name>_save
                xcall u_msgbox("Failed to delete record.",D_MOK+D_MICONEXCLAM)
            end
        end
    end
    else
    begin
        <structure_name> = <structure_name>_save
        xcall u_msgbox("Unable to lock record.",D_MOK+D_MICONEXCLAM)
    end

    return

print_search_results,

    ;Force list to completely load then position to top
    xcall w_proc(WP_HOURGLASS_ON)
    xcall u_update
    xcall u_update(FALSE)
    xcall l_queue(idl_results,D_LBOTTOM)
    xcall l_process(idl_results,req=D_LBOTTOM,<structure_name>,,channel,keynum,keyval)
    xcall w_proc(WP_HOURGLASS_OFF)
    xcall u_update(TRUE)

    ;Print the list contents
    xcall s_bld(msgtext,,"%a Search Results",a_base_title)
    xcall print_list(idl_results,<structure_name>,"TEMP:<structure_name>.smf",msgtext,,1)

    return

endsubroutine

;===================================================================================================
;
subroutine <structure_name>_mntcta

    ;Arguments
    a_inpid             ,n      ;Criteria input window ID

    ;Method data
    a_tabset            ,n      ;Tabset ID
    a_channel           ,n      ;Master file channel
    a_criteria          ,a      ;Criteria record
    a_<structure_name>       ,a      ;Selected master file record
    a_keynums           ,[*]n   ;Array of key numbers
    a_keynum            ,n      ;Key number to use
    a_keyval            ,a      ;Key value to match
    a_last_criteria     ,a      ;Last used criteria
    a_no_create         ,n      ;Supress "New" button
    a_no_delete         ,n      ;Supress "Delete" button
    a_no_print          ,n      ;Supress "Print" button

    ;End of arguments

.include "WND:tools.def"
.include "WND:fldinf.def"

proc

    ;Setup UI for criteria window processing

    ;xcall ui_edit(D_ON)
    ;xcall ui_okcancel(D_ON)

    xcall b_enable(a_tabset,"SEARCH")
    xcall b_disable(a_tabset,"AMEND")

    if (!a_no_delete)
        xcall b_disable(a_tabset,"DELETE")

    if (!a_no_print)
        xcall b_disable(a_tabset,"PRINT")

    xcall b_buttonset(a_tabset,,,,"SEARCH")

    ;Process the criteria input window

    repeat
    begin
        xcall i_input(a_inpid,"ALL",a_criteria,,,,D_NOTERM)
        if (g_setsts) then
            exitloop
        else
            xcall i_next(a_inpid,"ALL","*FRST*")

    end

    ;Reset UI

    ;xcall ui_edit(D_OFF)
    ;xcall ui_okcancel(D_OFF)

    ;Set current key number
    a_keynum = a_keynums[^d(a_criteria(1:1))]

    ;Extract partial key value
    xcall i_fldinf(a_inpid,"FIELD"+a_criteria(1:1),,,gs_inpfld)
    a_keyval = a_criteria(gs_pos:gs_siz)

    xreturn

endsubroutine

;===================================================================================================
;This is the change method for the search mode field on the criteria page
;The criteria window that the calling passes must specify this as a change
;method on the required MODE field.  The routine enables and disables the
;appropriate filter field for the currently selected search mode (key).

function <structure_name>_mntmode ,^val ,reentrant

    ;Arguments
    a_data_entered      ,a      ;Data as entered by the user.
    a_data_stored       ,a      ;Data as stroed in variable
    a_pending_status    ,n      ;Result of Toolkit's field validations.
    .include "WND:inpinf.def"   ;Input information structure
    a_criteria          ,a      ;Input data area
    ;End of arguments

.include "WND:tools.def"

.align
stack record
    status              ,i4
    newfield            ,a10

proc

    status = a_pending_status

    ;Delete current data field content
    xcall i_init(inp_wndid,"DATA")

    ;Clear same data from input record
    clear a_criteria(2,%len(a_criteria))

    ;Disable previous and enable new data field
    newfield = "FIELD" + a_data_stored(1:1)
    xcall i_disable(D_SET,inp_wndid,"DATA")
    xcall i_enable(D_FLDS,inp_wndid,newfield)

    ;Activate new data field
    xcall i_next(inp_wndid,,newfield)

    freturn status

endfunction

;===================================================================================================
;This routine processes the list on the search results tab.
;
subroutine <structure_name>_mntlst

    ;Arguments
    a_lstid             ,n      ;Search results list ID

    ;Method data
    a_tabset            ,n      ;Tabset ID
    a_channel           ,n      ;Master file channel
    a_criteria          ,a      ;Criteria record
    a_<structure_name>       ,a      ;Selected master file record
    a_keynums           ,[*]n   ;Array of key numbers
    a_keynum            ,n      ;Key number to use
    a_keyval            ,a      ;Key value to match
    a_last_criteria     ,a      ;Last used criteria
    a_no_create         ,n      ;Supress "New" button
    a_no_delete         ,n      ;Supress "Delete" button
    a_no_print          ,n      ;Supress "Print" button

    ;End of arguments


.include "WND:tools.def"

stack record
    req                 ,i4     ;List processor request

proc

    ;Configure UI for search results list processing

    ;xcall ui_okcancel(D_ON)

    xcall b_disable(a_tabset,"SEARCH")
    xcall b_enable(a_tabset,"AMEND")

    if (!a_no_delete)
        xcall b_enable(a_tabset,"DELETE")

    if (!a_no_print)
        xcall b_enable(a_tabset,"PRINT")

    xcall b_buttonset(a_tabset,,,,"AMEND")

    ;Process the search results

    if (a_criteria!=a_last_criteria)
        xcall l_restart(a_lstid)

    xcall l_select(a_lstid,req=D_LNOP,a_<structure_name>,,,,,,,,,,,,,a_channel,a_keynum,a_keyval)

    if (!g_select)
        xcall m_signal("AMEND")

    a_last_criteria = a_criteria

    ;xcall ui_okcancel(D_OFF)

    xreturn

endsubroutine

;===================================================================================================
;This is the load method for the search results list.
;
subroutine <structure_name>_mntload

    ;Arguments
    a_listid        ,n      ;Search results list ID
    a_reqest        ,n      ;List processor request
    a_<structure_name>   ,a      ;Master file record
    a_inpid         ,n      ;Search results list input window
    a_disable       ,n      ;Current item disabled
    a_index         ,n      ;Item index being requested

    ;Method data
    a_channel       ,n      ;Master file channel
    a_keynum        ,n      ;Key number to use
    a_keyval        ,a      ;Key value to match

    ;End of arguments

.include "WND:tools.def"
.include "CODEGEN_INC:structure_io.def"

proc

    ;If it's the first record, position to the correct starting position in
    ;the master file

    if (a_index==1)
    begin

        if (a_keyval) then
        begin
            ;Position to first match in specified key
            if (%<Structure_Name>Io(IO_FIND,a_channel,a_keyval,a_keynum,,,IO_PARTIAL)!=IO_OK)
                a_reqest=D_LEOF
        end
        else
        begin
            ;Position to first record in specified key
            if (%<Structure_Name>Io(IO_FIND_FIRST,a_channel,,a_keynum)!=IO_OK)
            begin
                xcall u_msgbox("No records found",D_MOK+D_MICONINFO)
                a_reqest=D_LEOF
            end
        end

    end

    if (a_reqest!=D_LEOF)
    begin

        ;Read next record in key sequence

        repeat
        begin
            if (%<Structure_Name>Io(IO_READ_NEXT,a_channel,,,a_<structure_name>)==IO_OK) then
            begin

                ;Ignore MCBA deleted records
                if (%instr(1,a_<structure_name>,']]]]'))
                    nextloop

                ;If matching a value, make sure we're still in range
                if (a_keyval&&(%keyval(a_channel,a_<structure_name>,a_keynum)!=%atrim(a_keyval)))
                begin
                    a_reqest = D_LEOF
                    exitloop
                end

                ;Got a metching record, return it
                xcall i_display(a_inpid,,a_<structure_name>)

                exitloop

            end
            else
            begin
                ;End of file, close the list
                a_reqest = D_LEOF
                exitloop
            end
        end

    end

    xreturn

endsubroutine

;===================================================================================================
;This is the input processor for the maintenance tab pages.
;
subroutine <structure_name>_mntinp

    inp_wndid           ,n      ;ID of input window on current tab page
    a_<structure_name>_input ,a      ;Input record

.include "WND:tools.def"

proc

    ;Enable menu and toolbar options for input processing

    ;xcall ui_edit(D_ON)
    ;xcall ui_okcancel(D_ON)
    ;xcall ui_lookup(D_ON)
    ;xcall ui_print(D_ON)

    ;Process the input window on the current tab page

    repeat
    begin
        xcall i_input(inp_wndid,"ALL",a_<structure_name>_input,,,,D_NOTERM)

        if (g_setsts) then
            exitloop
        else
            xcall i_next(inp_wndid,,"*FRST*")

    end

    ;Reset menu and toolbar options

    ;xcall ui_print(D_OFF)
    ;xcall ui_lookup(D_OFF)
    ;xcall ui_okcancel(D_OFF)
    ;xcall ui_edit(D_OFF)

    xreturn

endsubroutine


